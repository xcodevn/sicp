<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.7</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.7"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e1.xhtml#g_t4_002e1" rel="prev" title="4.1"/>
<link href="4_002e2.xhtml#g_t4_002e2" rel="next" title="4.2"/>
<link href="4_002e1_002e6.xhtml#g_t4_002e1_002e6" rel="prev" title="4.1.6"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e1_002e7"></a>
<nav class="header">
<p>
Next: <a href="4_002e2.xhtml#g_t4_002e2" accesskey="n" rel="next">4.2</a>, Previous: <a href="4_002e1_002e6.xhtml#g_t4_002e1_002e6" accesskey="p" rel="prev">4.1.6</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Separating-Syntactic-Analysis-from-Execution"></a>
<h4 class="subsection"><span class="secnum">4.1.7</span><span class="sectitle">Separating Syntactic Analysis from Execution</span></h4>

<p>The evaluator implemented above is simple, but it is very inefficient, because
the syntactic analysis of expressions is interleaved with their execution.
Thus if a program is executed many times, its syntax is analyzed many times.
Consider, for example, evaluating <code>(factorial 4)</code> using the following
definition of <code>factorial</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</pre></div>

<p>Each time <code>factorial</code> is called, the evaluator must determine that the
body is an <code>if</code> expression and extract the predicate.  Only then can it
evaluate the predicate and dispatch on its value.  Each time it evaluates the
expression <code>(* (factorial (- n 1)) n)</code>, or the subexpressions
<code>(factorial (- n 1))</code> and <code>(- n 1)</code>, the evaluator must perform the
case analysis in <code>eval</code> to determine that the expression is an
application, and must extract its operator and operands.  This analysis is
expensive.  Performing it repeatedly is wasteful.
</p>
<p>We can transform the evaluator to be significantly more efficient by arranging
things so that syntactic analysis is performed only once.<a class="footnote_link" id="DOCF232" href="#FOOT232"><sup>232</sup></a> We split <code>eval</code>, which takes an expression and an
environment, into two parts.  The procedure <code>analyze</code> takes only the
expression.  It performs the syntactic analysis and returns a new procedure,
the <a id="index-execution-procedure"></a>
<em>execution procedure</em>, that encapsulates the work to be done in
executing the analyzed expression.  The execution procedure takes an
environment as its argument and completes the evaluation.  This saves work
because <code>analyze</code> will be called only once on an expression, while the
execution procedure may be called many times.
</p>
<p>With the separation into analysis and execution, <code>eval</code> now becomes
</p>
<div class="lisp">
<pre class="lisp">(define (eval exp env) ((analyze exp) env))
</pre></div>

<p>The result of calling <code>analyze</code> is the execution procedure to be applied
to the environment.  The <code>analyze</code> procedure is the same case analysis as
performed by the original <code>eval</code> of <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a>, except that the
procedures to which we dispatch perform only analysis, not full evaluation:
</p>
<div class="lisp">
<pre class="lisp">(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) 
         (analyze-quoted exp))
        ((variable? exp) 
         (analyze-variable exp))
        ((assignment? exp) 
         (analyze-assignment exp))
        ((definition? exp) 
         (analyze-definition exp))
        ((if? exp) 
         (analyze-if exp))
        ((lambda? exp) 
         (analyze-lambda exp))
        ((begin? exp) 
         (analyze-sequence 
          (begin-actions exp)))
        ((cond? exp) 
         (analyze (cond-&gt;if exp)))
        ((application? exp) 
         (analyze-application exp))
        (else
         (error &quot;Unknown expression 
                 type: ANALYZE&quot; 
                exp))))
</pre></div>

<p>Here is the simplest syntactic analysis procedure, which handles
self-evaluating expressions.  It returns an execution procedure that ignores
its environment argument and just returns the expression:
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-self-evaluating exp)
  (lambda (env) exp))
</pre></div>

<p>For a quoted expression, we can gain a little efficiency by extracting the text
of the quotation only once, in the analysis phase, rather than in the execution
phase.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
</pre></div>

<p>Looking up a variable value must still be done in the execution phase, since
this depends upon knowing the environment.<a class="footnote_link" id="DOCF233" href="#FOOT233"><sup>233</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-variable exp)
  (lambda (env) 
    (lookup-variable-value exp env)))
</pre></div>

<p><code>Analyze-assignment</code> also must defer actually setting the variable until
the execution, when the environment has been supplied.  However, the fact that
the <code>assignment-value</code> expression can be analyzed (recursively) during
analysis is a major gain in efficiency, because the <code>assignment-value</code>
expression will now be analyzed only once.  The same holds true for
definitions.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze 
                (assignment-value exp))))
    (lambda (env)
      (set-variable-value! 
       var (vproc env) env)
      'ok)))

(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze 
                (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
</pre></div>

<p>For <code>if</code> expressions, we extract and analyze the predicate, consequent,
and alternative at analysis time.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))
</pre></div>

<p>Analyzing a <code>lambda</code> expression also achieves a major gain in efficiency:
We analyze the <code>lambda</code> body only once, even though procedures resulting
from evaluation of the <code>lambda</code> may be applied many times.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence 
                (lambda-body exp))))
    (lambda (env) 
      (make-procedure vars bproc env))))
</pre></div>

<p>Analysis of a sequence of expressions (as in a <code>begin</code> or the body of a
<code>lambda</code> expression) is more involved.<a class="footnote_link" id="DOCF234" href="#FOOT234"><sup>234</sup></a> Each expression in the
sequence is analyzed, yielding an execution procedure.  These execution
procedures are combined to produce an execution procedure that takes an
environment as argument and sequentially calls each individual execution
procedure with the environment as argument.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc 
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence: ANALYZE&quot;))
    (loop (car procs) (cdr procs))))
</pre></div>

<p>To analyze an application, we analyze the operator and operands and construct
an execution procedure that calls the operator execution procedure (to obtain
the actual procedure to be applied) and the operand execution procedures (to
obtain the actual arguments).  We then pass these to
<code>execute-application</code>, which is the analog of <code>apply</code> in 
<a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a>.  <code>Execute-application</code> differs from <code>apply</code> in that the
procedure body for a compound procedure has already been analyzed, so there is
no need to do further analysis.  Instead, we just call the execution procedure
for the body on the extended environment.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application 
       (fproc env)
       (map (lambda (aproc) (aproc env))
            aprocs)))))

(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment 
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else (error &quot;Unknown procedure type: 
                      EXECUTE-APPLICATION&quot;
                     proc))))
</pre></div>

<p>Our new evaluator uses the same data structures, syntax procedures, and
run-time support procedures as in <a href="4_002e1_002e2.xhtml#g_t4_002e1_002e2">4.1.2</a>, <a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3">4.1.3</a>, and
<a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4">4.1.4</a>.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e22"></a>Exercise 4.22:</strong> Extend the evaluator in this
section to support the special form <code>let</code>.  (See <a href="4_002e1_002e2.xhtml#Exercise-4_002e6">Exercise 4.6</a>.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e23"></a>Exercise 4.23:</strong> Alyssa P. Hacker doesn’t
understand why <code>analyze-sequence</code> needs to be so complicated.  All the
other analysis procedures are straightforward transformations of the
corresponding evaluation procedures (or <code>eval</code> clauses) in 
<a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a>.  She expected <code>analyze-sequence</code> to look like this:
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) 
           ((car procs) env))
          (else ((car procs) env)
                (execute-sequence 
                 (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence: 
                ANALYZE&quot;))
    (lambda (env) 
      (execute-sequence procs env))))
</pre></div>

<p>Eva Lu Ator explains to Alyssa that the version in the text does more of the
work of evaluating a sequence at analysis time.  Alyssa’s sequence-execution
procedure, rather than having the calls to the individual execution procedures
built in, loops through the procedures in order to call them: In effect,
although the individual expressions in the sequence have been analyzed, the
sequence itself has not been.
</p>
<p>Compare the two versions of <code>analyze-sequence</code>.  For example, consider the
common case (typical of procedure bodies) where the sequence has just one
expression.  What work will the execution procedure produced by Alyssa’s
program do?  What about the execution procedure produced by the program in the
text above?  How do the two versions compare for a sequence with two
expressions?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e24"></a>Exercise 4.24:</strong> Design and carry out some
experiments to compare the speed of the original metacircular evaluator with
the version in this section.  Use your results to estimate the fraction of time
that is spent in analysis versus execution for various procedures.
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT232"><p><a class="footnote_backlink" href="#DOCF232"><sup>232</sup></a>
This
technique is an integral part of the compilation process, which we shall
discuss in <a href="Chapter-5.xhtml#Chapter-5">Chapter 5</a>.  Jonathan Rees wrote a Scheme interpreter like this
in about 1982 for the T project (<a href="References.xhtml#Rees-and-Adams-1982">Rees and Adams 1982</a>).  Marc <a href="References.xhtml#Feeley-_00281986_0029">Feeley (1986)</a> (see
also <a href="References.xhtml#Feeley-and-Lapalme-1987">Feeley and Lapalme 1987</a>) independently invented this technique in his
master’s thesis.</p>
</div>
<div id="FOOT233"><p><a class="footnote_backlink" href="#DOCF233"><sup>233</sup></a>
There is, however, an
important part of the variable search that <em>can</em> be done as part of the
syntactic analysis.  As we will show in <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6">5.5.6</a>, one can determine
the position in the environment structure where the value of the variable will
be found, thus obviating the need to scan the environment for the entry that
matches the variable.</p>
</div>
<div id="FOOT234"><p><a class="footnote_backlink" href="#DOCF234"><sup>234</sup></a>
See <a href="#Exercise-4_002e23">Exercise 4.23</a>
for some insight into the processing of sequences.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="4_002e2.xhtml#g_t4_002e2" accesskey="n" rel="next">4.2</a>, Previous: <a href="4_002e1_002e6.xhtml#g_t4_002e1_002e6" accesskey="p" rel="prev">4.1.6</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
