<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 5.5.3</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 5.5.3"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 5.5.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5"/>
<link href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" rel="next" title="5.5.4"/>
<link href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" rel="prev" title="5.5.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e3"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="n" rel="next">5.5.4</a>, Previous: <a href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" accesskey="p" rel="prev">5.5.2</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Compiling-Combinations"></a>
<h4 class="subsection"><span class="secnum">5.5.3</span><span class="sectitle">Compiling Combinations</span></h4>

<p>The essence of the compilation process is the compilation of procedure
applications.  The code for a combination compiled with a given target and
linkage has the form
</p>
<div class="lisp">
<pre class="lisp">⟨<em>compilation of operator, 
 target <code>proc</code>, linkage <code>next</code></em>⟩
⟨<em>evaluate operands and construct 
 argument list in <code>argl</code></em>⟩
⟨<em>compilation of procedure call 
 with given target and linkage</em>⟩
</pre></div>

<p>The registers <code>env</code>, <code>proc</code>, and <code>argl</code> may have to be saved and
restored during evaluation of the operator and operands.  Note that this is the
only place in the compiler where a target other than <code>val</code> is specified.
</p>
<p>The required code is generated by <code>compile-application</code>.  This recursively
compiles the operator, to produce code that puts the procedure to be applied
into <code>proc</code>, and compiles the operands, to produce code that evaluates the
individual operands of the application.  The instruction sequences for the
operands are combined (by <code>construct-arglist</code>) with code that constructs
the list of arguments in <code>argl</code>, and the resulting argument-list code is
combined with the procedure code and the code that performs the procedure call
(produced by <code>compile-procedure-call</code>).  In appending the code sequences,
the <code>env</code> register must be preserved around the evaluation of the operator
(since evaluating the operator might modify <code>env</code>, which will be needed to
evaluate the operands), and the <code>proc</code> register must be preserved around
the construction of the argument list (since evaluating the operands might
modify <code>proc</code>, which will be needed for the actual procedure application).
<code>Continue</code> must also be preserved throughout, since it is needed for the
linkage in the procedure call.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-application 
         exp target linkage)
  (let ((proc-code 
         (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand)
                (compile operand 'val 'next))
              (operands exp))))
    (preserving 
     '(env continue)
     proc-code
     (preserving 
      '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call 
       target
       linkage)))))
</pre></div>

<p>The code to construct the argument list will evaluate each operand into
<code>val</code> and then <code>cons</code> that value onto the argument list being
accumulated in <code>argl</code>.  Since we <code>cons</code> the arguments onto
<code>argl</code> in sequence, we must start with the last argument and end with the
first, so that the arguments will appear in order from first to last in the
resulting list.  Rather than waste an instruction by initializing <code>argl</code>
to the empty list to set up for this sequence of evaluations, we make the first
code sequence construct the initial <code>argl</code>.  The general form of the
argument-list construction is thus as follows:
</p>
<div class="lisp">
<pre class="lisp">⟨<em>compilation of last operand, targeted to <code>val</code></em>⟩
(assign argl (op list) (reg val))
⟨<em>compilation of next operand, targeted to <code>val</code></em>⟩
(assign argl (op cons) (reg val) (reg argl))
<span class="roman">…</span>
⟨<em>compilation of first operand, targeted to <code>val</code></em>⟩
(assign argl (op cons) (reg val) (reg argl))
</pre></div>

<p><code>Argl</code> must be preserved around each operand evaluation except the first
(so that arguments accumulated so far won’t be lost), and <code>env</code> must be
preserved around each operand evaluation except the last (for use by subsequent
operand evaluations).
</p>
<p>Compiling this argument code is a bit tricky, because of the special treatment
of the first operand to be evaluated and the need to preserve <code>argl</code> and
<code>env</code> in different places.  The <code>construct-arglist</code> procedure takes
as arguments the code that evaluates the individual operands.  If there are no
operands at all, it simply emits the instruction
</p>
<div class="lisp">
<pre class="lisp">(assign argl (const ()))
</pre></div>

<p>Otherwise, <code>construct-arglist</code> creates code that initializes <code>argl</code>
with the last argument, and appends code that evaluates the rest of the
arguments and adjoins them to <code>argl</code> in succession.  In order to process
the arguments from last to first, we must reverse the list of operand code
sequences from the order supplied by <code>compile-application</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (construct-arglist operand-codes)
  (let ((operand-codes 
         (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence 
         '() 
         '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence 
                 '(val)
                 '(argl)
                 '((assign argl
                           (op list)
                           (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving 
               '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving 
          '(argl)
          (car operand-codes)
          (make-instruction-sequence 
           '(val argl)
           '(argl)
           '((assign argl
                     (op cons)
                     (reg val)
                     (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving 
         '(env)
         code-for-next-arg
         (code-to-get-rest-args 
          (cdr operand-codes))))))
</pre></div>

<a id="Applying-procedures"></a>
<h5 class="subsubheading">Applying procedures</h5>

<p>After evaluating the elements of a combination, the compiled code must apply
the procedure in <code>proc</code> to the arguments in <code>argl</code>.  The code
performs essentially the same dispatch as the <code>apply</code> procedure in the
metacircular evaluator of <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a> or the <code>apply-dispatch</code>
entry point in the explicit-control evaluator of <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1">5.4.1</a>.  It
checks whether the procedure to be applied is a primitive procedure or a
compiled procedure.  For a primitive procedure, it uses
<code>apply-primitive-procedure</code>; we will see shortly how it handles compiled
procedures.  The procedure-application code has the following form:
</p>
<div class="lisp">
<pre class="lisp">(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 ⟨<em>code to apply compiled procedure 
  with given target and appropriate linkage</em>⟩
primitive-branch
 (assign ⟨<var>target</var>⟩
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 ⟨<var>linkage</var>⟩
after-call
</pre></div>

<p>Observe that the compiled branch must skip around the primitive branch.
Therefore, if the linkage for the original procedure call was <code>next</code>, the
compound branch must use a linkage that jumps to a label that is inserted after
the primitive branch.  (This is similar to the linkage used for the true branch
in <code>compile-if</code>.)
</p>
<div class="lisp">
<pre class="lisp">(define (compile-procedure-call
         target linkage)
  (let ((primitive-branch 
         (make-label 'primitive-branch))
        (compiled-branch 
         (make-label 'compiled-branch))
        (after-call
         (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next)
               after-call
               linkage)))
      (append-instruction-sequences
       (make-instruction-sequence 
        '(proc)
        '()
        `((test 
           (op primitive-procedure?)
           (reg proc))
          (branch 
           (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl 
          target
          compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '(proc argl)
           (list target)
           `((assign 
              ,target
              (op apply-primitive-procedure)
              (reg proc)
              (reg argl)))))))
       after-call))))
</pre></div>

<p>The primitive and compound branches, like the true and false branches in
<code>compile-if</code>, are appended using <code>parallel-instruction-sequences</code>
rather than the ordinary <code>append-instruction-sequences</code>, because they will
not be executed sequentially.
</p>
<a id="Applying-compiled-procedures"></a>
<h5 class="subsubheading">Applying compiled procedures</h5>

<p>The code that handles procedure application is the most subtle part of the
compiler, even though the instruction sequences it generates are very short.  A
compiled procedure (as constructed by <code>compile-lambda</code>) has an entry
point, which is a label that designates where the code for the procedure
starts.  The code at this entry point computes a result in <code>val</code> and
returns by executing the instruction <code>(goto (reg continue))</code>.  Thus, we
might expect the code for a compiled-procedure application (to be generated by
<code>compile-proc-appl</code>) with a given target and linkage to look like this if
the linkage is a label
</p>
<div class="lisp">
<pre class="lisp">(assign continue 
        (label proc-return))
 (assign val
         (op compiled-procedure-entry)
         (reg proc))
 (goto (reg val))
proc-return
 (assign ⟨<var>target</var>⟩ 
         (reg val))   <span class="roman">; included if target is not <code>val</code></span>
 (goto (label ⟨<var>linkage</var>⟩))   <span class="roman">; linkage code</span>
</pre></div>

<p>or like this if the linkage is <code>return</code>.
</p>
<div class="lisp">
<pre class="lisp">(save continue)
 (assign continue 
         (label proc-return))
 (assign val 
         (op compiled-procedure-entry)
         (reg proc))
 (goto (reg val))
proc-return
 (assign ⟨<var>target</var>⟩
         (reg val))   <span class="roman">; included if target is not <code>val</code></span>
 (restore continue)
 (goto (reg continue))   <span class="roman">; linkage code</span>
</pre></div>

<p>This code sets up <code>continue</code> so that the procedure will return to a label
<code>proc-return</code> and jumps to the procedure’s entry point.  The code at
<code>proc-return</code> transfers the procedure’s result from <code>val</code> to the
target register (if necessary) and then jumps to the location specified by the
linkage.  (The linkage is always <code>return</code> or a label, because
<code>compile-procedure-call</code> replaces a <code>next</code> linkage for the
compound-procedure branch by an <code>after-call</code> label.)
</p>
<p>In fact, if the target is not <code>val</code>, that is exactly the code our compiler
will generate.<a class="footnote_link" id="DOCF324" href="#FOOT324"><sup>324</sup></a>  Usually, however, the target is
<code>val</code> (the only time the compiler specifies a different register is when
targeting the evaluation of an operator to <code>proc</code>), so the procedure
result is put directly into the target register and there is no need to return
to a special location that copies it.  Instead, we simplify the code by setting
up <code>continue</code> so that the procedure will “return” directly to the place
specified by the caller’s linkage:
</p>
<div class="lisp">
<pre class="lisp">⟨<em>set up <code>continue</code> for linkage</em>⟩
(assign val 
        (op compiled-procedure-entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>If the linkage is a label, we set up <code>continue</code> so that the procedure will
return to that label.  (That is, the <code>(goto (reg continue))</code> the procedure
ends with becomes equivalent to the <code>(goto (label ⟨<var>linkage</var>⟩))</code> at
<code>proc-return</code> above.)
</p>
<div class="lisp">
<pre class="lisp">(assign continue 
        (label ⟨<var>linkage</var>⟩))
(assign val
        (op compiled-procedure-entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>If the linkage is <code>return</code>, we don’t need to set up <code>continue</code> at
all: It already holds the desired location.  (That is, the <code>(goto (reg
continue))</code> the procedure ends with goes directly to the place where the
<code>(goto (reg continue))</code> at <code>proc-return</code> would have gone.)
</p>
<div class="lisp">
<pre class="lisp">(assign val
        (op compiled-procedure-entry)
        (reg proc))
(goto (reg val))
</pre></div>

<p>With this implementation of the <code>return</code> linkage, the compiler generates
tail-recursive code.  Calling a procedure as the final step in a procedure body
does a direct transfer, without saving any information on the stack.
</p>
<p>Suppose instead that we had handled the case of a procedure call with a linkage
of <code>return</code> and a target of <code>val</code> as shown above for a non-<code>val</code>
target.  This would destroy tail recursion.  Our system would still give the
same value for any expression.  But each time we called a procedure, we would
save <code>continue</code> and return after the call to undo the (useless) save.
These extra saves would accumulate during a nest of procedure
calls.<a class="footnote_link" id="DOCF325" href="#FOOT325"><sup>325</sup></a>
</p>
<p><code>Compile-proc-appl</code> generates the above procedure-application code by
considering four cases, depending on whether the target for the call is
<code>val</code> and whether the linkage is <code>return</code>.  Observe that the
instruction sequences are declared to modify all the registers, since executing
the procedure body can change the registers in arbitrary ways.<a class="footnote_link" id="DOCF326" href="#FOOT326"><sup>326</sup></a>
Also note that the code sequence for the case with target <code>val</code> and
linkage <code>return</code> is declared to need <code>continue</code>: Even though
<code>continue</code> is not explicitly used in the two-instruction sequence, we must
be sure that <code>continue</code> will have the correct value when we enter the
compiled procedure.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val)
              (not (eq? linkage 'return)))
         (make-instruction-sequence 
          '(proc)
          all-regs
          `((assign continue (label ,linkage))
            (assign 
             val 
             (op compiled-procedure-entry)
             (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return 
                (make-label 'proc-return)))
           (make-instruction-sequence 
            '(proc)
            all-regs
            `((assign continue 
                      (label ,proc-return))
              (assign 
               val 
               (op compiled-procedure-entry)
               (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val)
              (eq? linkage 'return))
         (make-instruction-sequence 
          '(proc continue) 
          all-regs
          '((assign 
             val 
             (op compiled-procedure-entry)
             (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (eq? linkage 'return))
         (error &quot;return linkage, 
                 target not val: COMPILE&quot;
                target))))
</pre></div>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT324"><p><a class="footnote_backlink" href="#DOCF324"><sup>324</sup></a>
Actually, we signal an error when the target is not
<code>val</code> and the linkage is <code>return</code>, since the only place we request
<code>return</code> linkages is in compiling procedures, and our convention is that
procedures return their values in <code>val</code>.</p>
</div>
<div id="FOOT325"><p><a class="footnote_backlink" href="#DOCF325"><sup>325</sup></a>
Making a compiler generate tail-recursive code might seem like
a straightforward idea.  But most compilers for common languages, including C
and Pascal, do not do this, and therefore these languages cannot represent
iterative processes in terms of procedure call alone.  The difficulty with tail
recursion in these languages is that their implementations use the stack to
store procedure arguments and local variables as well as return addresses.  The
Scheme implementations described in this book store arguments and variables in
memory to be garbage-collected.  The reason for using the stack for variables
and arguments is that it avoids the need for garbage collection in languages
that would not otherwise require it, and is generally believed to be more
efficient.  Sophisticated Lisp compilers can, in fact, use the stack for
arguments without destroying tail recursion.  (See <a href="References.xhtml#Hanson-1990">Hanson 1990</a> for a
description.)  There is also some debate about whether stack allocation is
actually more efficient than garbage collection in the first place, but the
details seem to hinge on fine points of computer architecture.  (See <a href="References.xhtml#Appel-1987">Appel 1987</a>
and <a href="References.xhtml#Miller-and-Rozas-1994">Miller and Rozas 1994</a> for opposing views on this issue.)</p>
</div>
<div id="FOOT326"><p><a class="footnote_backlink" href="#DOCF326"><sup>326</sup></a>
The
variable <code>all-regs</code> is bound to the list of names of all the registers:
</p>
<div class="lisp">
<pre class="lisp">(define all-regs '(env proc val argl continue))
</pre></div>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="n" rel="next">5.5.4</a>, Previous: <a href="5_002e5_002e2.xhtml#g_t5_002e5_002e2" accesskey="p" rel="prev">5.5.2</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
