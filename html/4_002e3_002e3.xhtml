<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 4.3.3</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 4.3.3"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 4.3.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e3.xhtml#g_t4_002e3" rel="prev" title="4.3"/>
<link href="4_002e4.xhtml#g_t4_002e4" rel="next" title="4.4"/>
<link href="4_002e3_002e2.xhtml#g_t4_002e3_002e2" rel="prev" title="4.3.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e3_002e3"></a>
<nav class="header">
<p>
Next: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="n" rel="next">4.4</a>, Previous: <a href="4_002e3_002e2.xhtml#g_t4_002e3_002e2" accesskey="p" rel="prev">4.3.2</a>, Up: <a href="4_002e3.xhtml#g_t4_002e3" accesskey="u" rel="prev">4.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Implementing-the-Amb-Evaluator"></a>
<h4 class="subsection"><span class="secnum">4.3.3</span><span class="sectitle">Implementing the <code>Amb</code> Evaluator</span></h4>

<p>The evaluation of an ordinary Scheme expression may return a value, may never
terminate, or may signal an error.  In nondeterministic Scheme the evaluation
of an expression may in addition result in the discovery of a dead end, in
which case evaluation must backtrack to a previous choice point.  The
interpretation of nondeterministic Scheme is complicated by this extra case.
</p>
<p>We will construct the <code>amb</code> evaluator for nondeterministic Scheme by
modifying the analyzing evaluator of <a href="4_002e1_002e7.xhtml#g_t4_002e1_002e7">4.1.7</a>.<a class="footnote_link" id="DOCF259" href="#FOOT259"><sup>259</sup></a>  As in the analyzing
evaluator, evaluation of an expression is accomplished by calling an execution
procedure produced by analysis of that expression.  The difference between the
interpretation of ordinary Scheme and the interpretation of nondeterministic
Scheme will be entirely in the execution procedures.
</p>
<a id="Execution-procedures-and-continuations"></a>
<h5 class="subsubheading">Execution procedures and continuations</h5>

<p>Recall that the execution procedures for the ordinary evaluator take one
argument: the environment of execution.  In contrast, the execution procedures
in the <code>amb</code> evaluator take three arguments: the environment, and two
procedures called <a id="index-continuation-procedures"></a>
<em>continuation procedures</em>.  The evaluation of an
expression will finish by calling one of these two continuations: If the
evaluation results in a value, the <a id="index-success-continuation"></a>
<em>success continuation</em> is called
with that value; if the evaluation results in the discovery of a dead end, the
<a id="index-failure-continuation"></a>
<em>failure continuation</em> is called.  Constructing and calling appropriate
continuations is the mechanism by which the nondeterministic evaluator
implements backtracking.
</p>
<p>It is the job of the success continuation to receive a value and proceed with
the computation.  Along with that value, the success continuation is passed
another failure continuation, which is to be called subsequently if the use of
that value leads to a dead end.
</p>
<p>It is the job of the failure continuation to try another branch of the
nondeterministic process.  The essence of the nondeterministic language is in
the fact that expressions may represent choices among alternatives.  The
evaluation of such an expression must proceed with one of the indicated
alternative choices, even though it is not known in advance which choices will
lead to acceptable results.  To deal with this, the evaluator picks one of the
alternatives and passes this value to the success continuation.  Together with
this value, the evaluator constructs and passes along a failure continuation
that can be called later to choose a different alternative.
</p>
<p>A failure is triggered during evaluation (that is, a failure continuation is
called) when a user program explicitly rejects the current line of attack (for
example, a call to <code>require</code> may result in execution of <code>(amb)</code>, an
expression that always fails—see <a href="4_002e3_002e1.xhtml#g_t4_002e3_002e1">4.3.1</a>).  The failure
continuation in hand at that point will cause the most recent choice point to
choose another alternative.  If there are no more alternatives to be considered
at that choice point, a failure at an earlier choice point is triggered, and so
on.  Failure continuations are also invoked by the driver loop in response to a
<code>try-again</code> request, to find another value of the expression.
</p>
<p>In addition, if a side-effect operation (such as assignment to a variable)
occurs on a branch of the process resulting from a choice, it may be necessary,
when the process finds a dead end, to undo the side effect before making a new
choice.  This is accomplished by having the side-effect operation produce a
failure continuation that undoes the side effect and propagates the failure.
</p>
<p>In summary, failure continuations are constructed by
</p>
<ul>
<li> <code>amb</code> expressions—to provide a mechanism to make alternative choices if
the current choice made by the <code>amb</code> expression leads to a dead end;

</li><li> the top-level driver—to provide a mechanism to report failure when the
choices are exhausted;

</li><li> assignments—to intercept failures and undo assignments during backtracking.

</li></ul>

<p>Failures are initiated only when a dead end is encountered.  This occurs
</p>
<ul>
<li> if the user program executes <code>(amb)</code>;

</li><li> if the user types <code>try-again</code> at the top-level driver.

</li></ul>

<p>Failure continuations are also called during processing of a failure:
</p>
<ul>
<li> When the failure continuation created by an assignment finishes undoing a side
effect, it calls the failure continuation it intercepted, in order to propagate
the failure back to the choice point that led to this assignment or to the top
level.

</li><li> When the failure continuation for an <code>amb</code> runs out of choices, it calls
the failure continuation that was originally given to the <code>amb</code>, in order
to propagate the failure back to the previous choice point or to the top level.

</li></ul>

<a id="Structure-of-the-evaluator"></a>
<h5 class="subsubheading">Structure of the evaluator</h5>

<p>The syntax- and data-representation procedures for the <code>amb</code> evaluator,
and also the basic <code>analyze</code> procedure, are identical to those in the
evaluator of <a href="4_002e1_002e7.xhtml#g_t4_002e1_002e7">4.1.7</a>, except for the fact that we need additional
syntax procedures to recognize the <code>amb</code> special form:<a class="footnote_link" id="DOCF260" href="#FOOT260"><sup>260</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
</pre></div>

<p>We must also add to the dispatch in <code>analyze</code> a clause that will recognize
this special form and generate an appropriate execution procedure:
</p>
<div class="lisp">
<pre class="lisp">((amb? exp) (analyze-amb exp))
</pre></div>

<p>The top-level procedure <code>ambeval</code> (similar to the version of <code>eval</code>
given in <a href="4_002e1_002e7.xhtml#g_t4_002e1_002e7">4.1.7</a>) analyzes the given expression and applies the
resulting execution procedure to the given environment, together with two given
continuations:
</p>
<div class="lisp">
<pre class="lisp">(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
</pre></div>

<p>A success continuation is a procedure of two arguments: the value just obtained
and another failure continuation to be used if that value leads to a subsequent
failure. A failure continuation is a procedure of no arguments.  So the general
form of an execution procedure is
</p>
<div class="lisp">
<pre class="lisp">(lambda (env succeed fail)
  <span class="roman">;; <code>succeed</code> is <code>(lambda (value fail) <span class="roman">…</span>)</code></span>
  <span class="roman">;; <code>fail</code> is <code>(lambda () <span class="roman">…</span>)</code></span>
  <span class="roman">…</span>)
</pre></div>

<p>For example, executing
</p>
<div class="lisp">
<pre class="lisp">(ambeval ⟨<var>exp</var>⟩
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
</pre></div>

<p>will attempt to evaluate the given expression and will return either the
expression’s value (if the evaluation succeeds) or the symbol <code>failed</code> (if
the evaluation fails).  The call to <code>ambeval</code> in the driver loop shown
below uses much more complicated continuation procedures, which continue the
loop and support the <code>try-again</code> request.
</p>
<p>Most of the complexity of the <code>amb</code> evaluator results from the mechanics
of passing the continuations around as the execution procedures call each
other.  In going through the following code, you should compare each of the
execution procedures with the corresponding procedure for the ordinary
evaluator given in <a href="4_002e1_002e7.xhtml#g_t4_002e1_002e7">4.1.7</a>.
</p>
<a id="Simple-expressions"></a>
<h5 class="subsubheading">Simple expressions</h5>

<p>The execution procedures for the simplest kinds of expressions are essentially
the same as those for the ordinary evaluator, except for the need to manage the
continuations.  The execution procedures simply succeed with the value of the
expression, passing along the failure continuation that was passed to them.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))

(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))

(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence 
                (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
</pre></div>

<p>Notice that looking up a variable always ‘succeeds.’  If
<code>lookup-variable-value</code> fails to find the variable, it signals an error,
as usual.  Such a “failure” indicates a program bug—a reference to an
unbound variable; it is not an indication that we should try another
nondeterministic choice instead of the one that is currently being tried.
</p>
<a id="Conditionals-and-sequences"></a>
<h5 class="subsubheading">Conditionals and sequences</h5>

<p>Conditionals are also handled in a similar way as in the ordinary evaluator.
The execution procedure generated by <code>analyze-if</code> invokes the predicate
execution procedure <code>pproc</code> with a success continuation that checks
whether the predicate value is true and goes on to execute either the
consequent or the alternative.  If the execution of <code>pproc</code> fails, the
original failure continuation for the <code>if</code> expression is called.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             <span class="roman">;; success continuation for evaluating</span>
             <span class="roman">;; the predicate to obtain <code>pred-value</code></span>
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             <span class="roman">;; failure continuation for</span>
             <span class="roman">;; evaluating the predicate</span>
             fail))))
</pre></div>

<p>Sequences are also handled in the same way as in the previous evaluator, except
for the machinations in the subprocedure <code>sequentially</code> that are required
for passing the continuations.  Namely, to sequentially execute <code>a</code> and
then <code>b</code>, we call <code>a</code> with a success continuation that calls
<code>b</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         <span class="roman">;; success continuation for calling <code>a</code></span>
         (lambda (a-value fail2)
           (b env succeed fail2))
         <span class="roman">;; failure continuation for calling <code>a</code></span>
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc 
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error &quot;Empty sequence: ANALYZE&quot;))
    (loop (car procs) (cdr procs))))
</pre></div>

<a id="Definitions-and-assignments"></a>
<h5 class="subsubheading">Definitions and assignments</h5>

<p>Definitions are another case where we must go to some trouble to manage the
continuations, because it is necessary to evaluate the definition-value
expression before actually defining the new variable.  To accomplish this, the
definition-value execution procedure <code>vproc</code> is called with the
environment, a success continuation, and the failure continuation.  If the
execution of <code>vproc</code> succeeds, obtaining a value <code>val</code> for the
defined variable, the variable is defined and the success is propagated:
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze 
                (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
</pre></div>

<p>Assignments are more interesting.  This is the first place where we really use
the continuations, rather than just passing them around.  The execution
procedure for assignments starts out like the one for definitions.  It first
attempts to obtain the new value to be assigned to the variable. If this
evaluation of <code>vproc</code> fails, the assignment fails.
</p>
<p>If <code>vproc</code> succeeds, however, and we go on to make the assignment, we must
consider the possibility that this branch of the computation might later fail,
which will require us to backtrack out of the assignment.  Thus, we must
arrange to undo the assignment as part of the backtracking process.<a class="footnote_link" id="DOCF261" href="#FOOT261"><sup>261</sup></a>
</p>
<p>This is accomplished by giving <code>vproc</code> a success continuation (marked with
the comment “*1*” below) that saves the old value of the variable before
assigning the new value to the variable and proceeding from the assignment.
The failure continuation that is passed along with the value of the assignment
(marked with the comment “*2*” below) restores the old value of the variable
before continuing the failure.  That is, a successful assignment provides a
failure continuation that will intercept a subsequent failure; whatever failure
would otherwise have called <code>fail2</code> calls this procedure instead, to undo
the assignment before actually calling <code>fail2</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze 
                (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)    <span class="roman">; *1*</span>
               (let ((old-value
                      (lookup-variable-value 
                       var 
                       env)))
                 (set-variable-value! var 
                                      val 
                                      env)
                 (succeed 
                  'ok
                  (lambda ()    <span class="roman">; *2*</span>
                    (set-variable-value! 
                     var
                     old-value
                     env)
                    (fail2)))))
               fail))))
</pre></div>

<a id="Procedure-applications"></a>
<h5 class="subsubheading">Procedure applications</h5>

<p>The execution procedure for applications contains no new ideas except for the
technical complexity of managing the continuations.  This complexity arises in
<code>analyze-application</code>, due to the need to keep track of the success and
failure continuations as we evaluate the operands.  We use a procedure
<code>get-args</code> to evaluate the list of operands, rather than a simple
<code>map</code> as in the ordinary evaluator.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args 
                aprocs
                env
                (lambda (args fail3)
                  (execute-application
                   proc args succeed fail3))
                fail2))
             fail))))
</pre></div>

<p>In <code>get-args</code>, notice how <code>cdr</code>-ing down the list of <code>aproc</code>
execution procedures and <code>cons</code>ing up the resulting list of <code>args</code> is
accomplished by calling each <code>aproc</code> in the list with a success
continuation that recursively calls <code>get-args</code>.  Each of these recursive
calls to <code>get-args</code> has a success continuation whose value is the
<code>cons</code> of the newly obtained argument onto the list of accumulated
arguments:
</p>
<div class="lisp">
<pre class="lisp">(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) 
       env
       ;; <span class="roman">success continuation for this <code>aproc</code></span>
       (lambda (arg fail2)
         (get-args 
          (cdr aprocs)
          env
          ;; <span class="roman">success continuation for</span>
          ;; <span class="roman">recursive call to <code>get-args</code></span>
          (lambda (args fail3)
            (succeed (cons arg args)
                     fail3))
          fail2))
       fail)))
</pre></div>

<p>The actual procedure application, which is performed by
<code>execute-application</code>, is accomplished in the same way as for the ordinary
evaluator, except for the need to manage the continuations.
</p>
<div class="lisp">
<pre class="lisp">(define (execute-application 
         proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed 
          (apply-primitive-procedure 
           proc args)
          fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment 
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else (error &quot;Unknown procedure type: 
                      EXECUTE-APPLICATION&quot;
                     proc))))
</pre></div>

<a id="Evaluating-amb-expressions"></a>
<h5 class="subsubheading">Evaluating <code>amb</code> expressions</h5>

<p>The <code>amb</code> special form is the key element in the nondeterministic
language.  Here we see the essence of the interpretation process and the reason
for keeping track of the continuations.  The execution procedure for <code>amb</code>
defines a loop <code>try-next</code> that cycles through the execution procedures for
all the possible values of the <code>amb</code> expression.  Each execution procedure
is called with a failure continuation that will try the next one.  When there
are no more alternatives to try, the entire <code>amb</code> expression fails.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-amb exp)
  (let ((cprocs (map analyze 
                     (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) 
             env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
</pre></div>

<a id="Driver-loop-1"></a>
<h5 class="subsubheading">Driver loop</h5>

<p>The driver loop for the <code>amb</code> evaluator is complex, due to the mechanism
that permits the user to try again in evaluating an expression.  The driver
uses a procedure called <code>internal-loop</code>, which takes as argument a
procedure <code>try-again</code>.  The intent is that calling <code>try-again</code> should
go on to the next untried alternative in the nondeterministic evaluation.
<code>Internal-loop</code> either calls <code>try-again</code> in response to the user
typing <code>try-again</code> at the driver loop, or else starts a new evaluation by
calling <code>ambeval</code>.
</p>
<p>The failure continuation for this call to <code>ambeval</code> informs the user that
there are no more values and re-invokes the driver loop.
</p>
<p>The success continuation for the call to <code>ambeval</code> is more subtle.  We
print the obtained value and then invoke the internal loop again with a
<code>try-again</code> procedure that will be able to try the next alternative.  This
<code>next-alternative</code> procedure is the second argument that was passed to the
success continuation.  Ordinarily, we think of this second argument as a
failure continuation to be used if the current evaluation branch later fails.
In this case, however, we have completed a successful evaluation, so we can
invoke the “failure” alternative branch in order to search for additional
successful evaluations.
</p>
<div class="lisp">
<pre class="lisp">(define input-prompt  &quot;;;; Amb-Eval input:&quot;)
(define output-prompt &quot;;;; Amb-Eval value:&quot;)

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display 
             &quot;;;; Starting a new problem &quot;)
            (ambeval 
             input
             the-global-environment
             <span class="roman">;; <code>ambeval</code> success</span>
             (lambda (val next-alternative)
               (announce-output 
                output-prompt)
               (user-print val)
               (internal-loop 
                next-alternative))
             <span class="roman">;; <code>ambeval</code> failure</span>
             (lambda ()
               (announce-output
                &quot;;;; There are no 
                 more values of&quot;)
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display 
      &quot;;;; There is no current problem&quot;)
     (driver-loop))))
</pre></div>

<p>The initial call to <code>internal-loop</code> uses a <code>try-again</code> procedure that
complains that there is no current problem and restarts the driver loop.  This
is the behavior that will happen if the user types <code>try-again</code> when there
is no evaluation in progress.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e50"></a>Exercise 4.50:</strong> Implement a new special form
<code>ramb</code> that is like <code>amb</code> except that it searches alternatives in a
random order, rather than from left to right.  Show how this can help with
Alyssa’s problem in <a href="4_002e3_002e2.xhtml#Exercise-4_002e49">Exercise 4.49</a>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e51"></a>Exercise 4.51:</strong> Implement a new kind of
assignment called <code>permanent-set!</code> that is not undone upon failure.  For
example, we can choose two distinct elements from a list and count the number
of trials required to make a successful choice as follows:
</p>
<div class="lisp">
<pre class="lisp">(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))

<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(a b 2)</i>

<i>;;; Amb-Eval input:</i>
try-again

<i>;;; Amb-Eval value:</i>
<i>(a c 3)</i>
</pre></div>

<p>What values would have been displayed if we had used <code>set!</code> here
rather than <code>permanent-set!</code>?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e52"></a>Exercise 4.52:</strong> Implement a new construct called
<code>if-fail</code> that permits the user to catch the failure of an expression.
<code>If-fail</code> takes two expressions.  It evaluates the first expression as
usual and returns as usual if the evaluation succeeds.  If the evaluation
fails, however, the value of the second expression is returned, as in the
following example:
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Amb-Eval input:</i>
(if-fail 
 (let ((x (an-element-of '(1 3 5))))
   (require (even? x))
   x)
 'all-odd)

<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>all-odd</i>

<i>;;; Amb-Eval input:</i>
(if-fail
 (let ((x (an-element-of '(1 3 5 8))))
   (require (even? x))
   x)
 'all-odd)

<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>8</i>
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e53"></a>Exercise 4.53:</strong> With <code>permanent-set!</code> as
described in <a href="#Exercise-4_002e51">Exercise 4.51</a> and <code>if-fail</code> as in <a href="#Exercise-4_002e52">Exercise 4.52</a>,
what will be the result of evaluating
</p>
<div class="lisp">
<pre class="lisp">(let ((pairs '()))
  (if-fail 
   (let ((p (prime-sum-pair 
             '(1 3 5 8) 
             '(20 35 110))))
     (permanent-set! pairs 
                     (cons p pairs))
     (amb))
   pairs))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e54"></a>Exercise 4.54:</strong> If we had not realized that
<code>require</code> could be implemented as an ordinary procedure that uses
<code>amb</code>, to be defined by the user as part of a nondeterministic program, we
would have had to implement it as a special form.  This would require syntax
procedures
</p>
<div class="lisp">
<pre class="lisp">(define (require? exp) 
  (tagged-list? exp 'require))

(define (require-predicate exp) 
  (cadr exp))
</pre></div>

<p>and a new clause in the dispatch in <code>analyze</code>
</p>
<div class="lisp">
<pre class="lisp">((require? exp) (analyze-require exp))
</pre></div>

<p>as well the procedure <code>analyze-require</code> that handles <code>require</code>
expressions.  Complete the following definition of <code>analyze-require</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (analyze-require exp)
  (let ((pproc (analyze 
                (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ⟨??⟩
                   ⟨??⟩
                   (succeed 'ok fail2)))
             fail))))
</pre></div>
</blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT259"><p><a class="footnote_backlink" href="#DOCF259"><sup>259</sup></a>
We chose to
implement the lazy evaluator in <a href="4_002e2.xhtml#g_t4_002e2">4.2</a> as a modification of the
ordinary metacircular evaluator of <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1">4.1.1</a>.  In contrast, we will
base the <code>amb</code> evaluator on the analyzing evaluator of 
<a href="4_002e1_002e7.xhtml#g_t4_002e1_002e7">4.1.7</a>, because the execution procedures in that evaluator provide a
convenient framework for implementing backtracking.</p>
</div>
<div id="FOOT260"><p><a class="footnote_backlink" href="#DOCF260"><sup>260</sup></a>
We assume
that the evaluator supports <code>let</code> (see <a href="4_002e1_002e7.xhtml#Exercise-4_002e22">Exercise 4.22</a>), which we have
used in our nondeterministic programs.</p>
</div>
<div id="FOOT261"><p><a class="footnote_backlink" href="#DOCF261"><sup>261</sup></a>
We
didn’t worry about undoing definitions, since we can assume that internal
definitions are scanned out (<a href="4_002e1_002e6.xhtml#g_t4_002e1_002e6">4.1.6</a>).</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="n" rel="next">4.4</a>, Previous: <a href="4_002e3_002e2.xhtml#g_t4_002e3_002e2" accesskey="p" rel="prev">4.3.2</a>, Up: <a href="4_002e3.xhtml#g_t4_002e3" accesskey="u" rel="prev">4.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
