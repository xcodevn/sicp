<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.4.2</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.4.2"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.4.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e4.xhtml#g_t5_002e4" rel="prev" title="5.4"/>
<link href="5_002e4_002e3.xhtml#g_t5_002e4_002e3" rel="next" title="5.4.3"/>
<link href="5_002e4_002e1.xhtml#g_t5_002e4_002e1" rel="prev" title="5.4.1"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e4_002e2"></a>
<nav class="header">
<p>
Next: <a href="5_002e4_002e3.xhtml#g_t5_002e4_002e3" accesskey="n" rel="next">5.4.3</a>, Previous: <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1" accesskey="p" rel="prev">5.4.1</a>, Up: <a href="5_002e4.xhtml#g_t5_002e4" accesskey="u" rel="prev">5.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Sequence-Evaluation-and-Tail-Recursion"></a>
<h4 class="subsection"><span class="secnum">5.4.2</span><span class="sectitle">Sequence Evaluation and Tail Recursion</span></h4>

<p>The portion of the explicit-control evaluator at <code>ev-sequence</code> is
analogous to the metacircular evaluator’s <code>eval-sequence</code> procedure.  It
handles sequences of expressions in procedure bodies or in explicit
<code>begin</code> expressions.
</p>
<p>Explicit <code>begin</code> expressions are evaluated by placing the sequence of
expressions to be evaluated in <code>unev</code>, saving <code>continue</code> on the
stack, and jumping to <code>ev-sequence</code>.
</p>
<div class="lisp">
<pre class="lisp">ev-begin
  (assign unev
          (op begin-actions)
          (reg exp))
  (save continue)
  (goto (label ev-sequence))
</pre></div>

<p>The implicit sequences in procedure bodies are handled by jumping to
<code>ev-sequence</code> from <code>compound-apply</code>, at which point <code>continue</code>
is already on the stack, having been saved at <code>ev-application</code>.
</p>
<p>The entries at <code>ev-sequence</code> and <code>ev-sequence-continue</code> form a loop
that successively evaluates each expression in a sequence.  The list of
unevaluated expressions is kept in <code>unev</code>.  Before evaluating each
expression, we check to see if there are additional expressions to be evaluated
in the sequence.  If so, we save the rest of the unevaluated expressions (held
in <code>unev</code>) and the environment in which these must be evaluated (held in
<code>env</code>) and call <code>eval-dispatch</code> to evaluate the expression.  The two
saved registers are restored upon the return from this evaluation, at
<code>ev-sequence-continue</code>.
</p>
<p>The final expression in the sequence is handled differently, at the entry point
<code>ev-sequence-last-exp</code>.  Since there are no more expressions to be
evaluated after this one, we need not save <code>unev</code> or <code>env</code> before
going to <code>eval-dispatch</code>.  The value of the whole sequence is the value of
the last expression, so after the evaluation of the last expression there is
nothing left to do except continue at the entry point currently held on the
stack (which was saved by <code>ev-application</code> or <code>ev-begin</code>.)  Rather
than setting up <code>continue</code> to arrange for <code>eval-dispatch</code> to return
here and then restoring <code>continue</code> from the stack and continuing at that
entry point, we restore <code>continue</code> from the stack before going to
<code>eval-dispatch</code>, so that <code>eval-dispatch</code> will continue at that entry
point after evaluating the expression.
</p>
<div class="lisp">
<pre class="lisp">ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue
          (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev
          (op rest-exps)
          (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
</pre></div>

<a id="Tail-recursion"></a>
<h5 class="subsubheading">Tail recursion</h5>

<p>In <a href="Chapter-1.xhtml#Chapter-1">Chapter 1</a> we said that the process described by a procedure such as
</p>
<div class="lisp">
<pre class="lisp">(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
</pre></div>

<p>is an iterative process.  Even though the procedure is syntactically recursive
(defined in terms of itself), it is not logically necessary for an evaluator to
save information in passing from one call to <code>sqrt-iter</code> to the
next.<a class="footnote_link" id="DOCF310" href="#FOOT310"><sup>310</sup></a> An evaluator that can execute a procedure such as
<code>sqrt-iter</code> without requiring increasing storage as the procedure
continues to call itself is called a <a id="index-tail_002drecursive-1"></a>
<em>tail-recursive</em> evaluator.  The
metacircular implementation of the evaluator in <a href="Chapter-4.xhtml#Chapter-4">Chapter 4</a> does not
specify whether the evaluator is tail-recursive, because that evaluator
inherits its mechanism for saving state from the underlying Scheme.  With the
explicit-control evaluator, however, we can trace through the evaluation
process to see when procedure calls cause a net accumulation of information on
the stack.
</p>
<p>Our evaluator is tail-recursive, because in order to evaluate the final
expression of a sequence we transfer directly to <code>eval-dispatch</code> without
saving any information on the stack.  Hence, evaluating the final expression in
a sequence—even if it is a procedure call (as in <code>sqrt-iter</code>, where the
<code>if</code> expression, which is the last expression in the procedure body,
reduces to a call to <code>sqrt-iter</code>)—will not cause any information to be
accumulated on the stack.<a class="footnote_link" id="DOCF311" href="#FOOT311"><sup>311</sup></a>
</p>
<p>If we did not think to take advantage of the fact that it was unnecessary to
save information in this case, we might have implemented <code>eval-sequence</code>
by treating all the expressions in a sequence in the same way—saving the
registers, evaluating the expression, returning to restore the registers, and
repeating this until all the expressions have been evaluated:<a class="footnote_link" id="DOCF312" href="#FOOT312"><sup>312</sup></a>
</p>
<div class="lisp">
<pre class="lisp">ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue
          (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
</pre></div>

<p>This may seem like a minor change to our previous code for evaluation of a
sequence: The only difference is that we go through the save-restore cycle for
the last expression in a sequence as well as for the others.  The interpreter
will still give the same value for any expression.  But this change is fatal to
the tail-recursive implementation, because we must now return after evaluating
the final expression in a sequence in order to undo the (useless) register
saves.  These extra saves will accumulate during a nest of procedure calls.
Consequently, processes such as <code>sqrt-iter</code> will require space
proportional to the number of iterations rather than requiring constant space.
This difference can be significant.  For example, with tail recursion, an
infinite loop can be expressed using only the procedure-call mechanism:
</p>
<div class="lisp">
<pre class="lisp">(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
</pre></div>

<p>Without tail recursion, such a procedure would eventually run out of stack
space, and expressing a true iteration would require some control mechanism
other than procedure call.
</p>
<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT310"><p><a class="footnote_backlink" href="#DOCF310"><sup>310</sup></a>
We saw in <a href="5_002e1.xhtml#g_t5_002e1">5.1</a> how to implement such a process with
a register machine that had no stack; the state of the process was stored in a
fixed set of registers.</p>
</div>
<div id="FOOT311"><p><a class="footnote_backlink" href="#DOCF311"><sup>311</sup></a>
This implementation of tail recursion in
<code>ev-sequence</code> is one variety of a well-known optimization technique used
by many compilers.  In compiling a procedure that ends with a procedure call,
one can replace the call by a jump to the called procedure’s entry point.
Building this strategy into the interpreter, as we have done in this section,
provides the optimization uniformly throughout the language.</p>
</div>
<div id="FOOT312"><p><a class="footnote_backlink" href="#DOCF312"><sup>312</sup></a>
We can
define <code>no-more-exps?</code> as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (no-more-exps? seq) (null? seq))
</pre></div>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="5_002e4_002e3.xhtml#g_t5_002e4_002e3" accesskey="n" rel="next">5.4.3</a>, Previous: <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1" accesskey="p" rel="prev">5.4.1</a>, Up: <a href="5_002e4.xhtml#g_t5_002e4" accesskey="u" rel="prev">5.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
