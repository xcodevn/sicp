<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 2.2.4</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 2.2.4"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 2.2.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="2_002e2.xhtml#g_t2_002e2" rel="prev" title="2.2"/>
<link href="2_002e3.xhtml#g_t2_002e3" rel="next" title="2.3"/>
<link href="2_002e2_002e3.xhtml#g_t2_002e2_002e3" rel="prev" title="2.2.3"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t2_002e2_002e4"></a>
<nav class="header">
<p>
Next: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="n" rel="next">2.3</a>, Previous: <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3" accesskey="p" rel="prev">2.2.3</a>, Up: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="u" rel="prev">2.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Example_003a-A-Picture-Language"></a>
<h4 class="subsection"><span class="secnum">2.2.4</span><span class="sectitle">Example: A Picture Language</span></h4>

<p>This section presents a simple language for drawing pictures that illustrates
the power of data abstraction and closure, and also exploits higher-order
procedures in an essential way.  The language is designed to make it easy to
experiment with patterns such as the ones in <a href="#Figure-2_002e9">Figure 2.9</a>, which are
composed of repeated elements that are shifted and scaled.<a class="footnote_link" id="DOCF88" href="#FOOT88"><sup>88</sup></a> In this language, the data
objects being combined are represented as procedures rather than as list
structure.  Just as <code>cons</code>, which satisfies the closure property, allowed
us to easily build arbitrarily complicated list structure, the operations in
this language, which also satisfy the closure property, allow us to easily
build arbitrarily complicated patterns.
</p>
<figure class="float">
<a id="Figure-2_002e9"></a>
<object style="width: 55.86ex; height: 31.34ex;" data="fig/chap2/Fig2.9.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.9:</strong> Designs generated with the picture language.</p>
</figcaption>
</figure>

<a id="The-picture-language"></a>
<h5 class="subsubheading">The picture language</h5>

<p>When we began our study of programming in <a href="1_002e1.xhtml#g_t1_002e1">1.1</a>, we emphasized the
importance of describing a language by focusing on the language’s primitives,
its means of combination, and its means of abstraction.  We’ll follow that
framework here.
</p>
<p>Part of the elegance of this picture language is that there is only one kind of
element, called a <a id="index-painter"></a>
<em>painter</em>.  A painter draws an image that is shifted
and scaled to fit within a designated parallelogram-shaped frame.  For example,
there’s a primitive painter we’ll call <code>wave</code> that makes a crude line
drawing, as shown in <a href="#Figure-2_002e10">Figure 2.10</a>.  The actual shape of the drawing
depends on the frame—all four images in figure 2.10 are produced by the
same <code>wave</code> painter, but with respect to four different frames.  Painters
can be more elaborate than this: The primitive painter called <code>rogers</code>
paints a picture of <abbr>MIT</abbr>’s founder, William Barton Rogers, as shown in
<a href="#Figure-2_002e11">Figure 2.11</a>.<a class="footnote_link" id="DOCF89" href="#FOOT89"><sup>89</sup></a> The four images in figure 2.11 are drawn with respect to the same four
frames as the <code>wave</code> images in figure 2.10.
</p>
<figure class="float">
<a id="Figure-2_002e10"></a>
<object style="width: 28.23ex; height: 30.22ex;" data="fig/chap2/Fig2.10.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.10:</strong> Images produced by the <code>wave</code> painter, with respect to four different frames.  The frames, shown with dotted lines, are not part of the images.</p>
</figcaption>
</figure>

<figure class="float">
<a id="Figure-2_002e11"></a>
<object style="width: 28.23ex; height: 31.26ex;" data="fig/chap2/Fig2.11.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.11:</strong> Images of William Barton Rogers, founder and first president of <abbr>MIT</abbr>, painted with respect to the same four frames as in <a href="#Figure-2_002e10">Figure 2.10</a> (original image from Wikimedia Commons).</p>
</figcaption>
</figure>

<p>To combine images, we use various operations that construct new painters from
given painters.  For example, the <code>beside</code> operation takes two painters
and produces a new, compound painter that draws the first painter’s image in
the left half of the frame and the second painter’s image in the right half of
the frame.  Similarly, <code>below</code> takes two painters and produces a compound
painter that draws the first painter’s image below the second painter’s image.
Some operations transform a single painter to produce a new painter.  For
example, <code>flip-vert</code> takes a painter and produces a painter that draws its
image upside-down, and <code>flip-horiz</code> produces a painter that draws the
original painter’s image left-to-right reversed.
</p>
<p><a href="#Figure-2_002e12">Figure 2.12</a> shows the drawing of a painter called
<code>wave4</code> that is built up in two stages starting from <code>wave</code>:
</p>
<div class="lisp">
<pre class="lisp">(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
</pre></div>

<figure class="float">
<a id="Figure-2_002e12"></a>
<object style="width: 47.06ex; height: 26.07ex;" data="fig/chap2/Fig2.12.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.12:</strong> Creating a complex figure, starting from the <code>wave</code> painter of <a href="#Figure-2_002e10">Figure 2.10</a>.</p>
</figcaption>
</figure>

<p>In building up a complex image in this manner we are exploiting the fact that
painters are closed under the language’s means of combination.  The
<code>beside</code> or <code>below</code> of two painters is itself a painter; therefore,
we can use it as an element in making more complex painters.  As with building
up list structure using <code>cons</code>, the closure of our data under the means of
combination is crucial to the ability to create complex structures while using
only a few operations.
</p>
<p>Once we can combine painters, we would like to be able to abstract typical
patterns of combining painters.  We will implement the painter operations as
Scheme procedures.  This means that we don’t need a special abstraction
mechanism in the picture language: Since the means of combination are ordinary
Scheme procedures, we automatically have the capability to do anything with
painter operations that we can do with procedures.  For example, we can
abstract the pattern in <code>wave4</code> as
</p>
<div class="lisp">
<pre class="lisp">(define (flipped-pairs painter)
  (let ((painter2 
         (beside painter 
                 (flip-vert painter))))
    (below painter2 painter2)))
</pre></div>

<p>and define <code>wave4</code> as an instance of this pattern:
</p>
<div class="lisp">
<pre class="lisp">(define wave4 (flipped-pairs wave))
</pre></div>

<p>We can also define recursive operations.  Here’s one that makes painters split
and branch towards the right as shown in <a href="#Figure-2_002e13">Figure 2.13</a>
and <a href="#Figure-2_002e14">Figure 2.14</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter 
                                  (- n 1))))
        (beside painter 
                (below smaller smaller)))))
</pre></div>

<figure class="float">
<a id="Figure-2_002e13"></a>
<object style="width: 52.15ex; height: 68.90ex;" data="fig/chap2/Fig2.13a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.13:</strong> Recursive plans for <code>right-split</code> and <code>corner-split</code>.</p>
</figcaption>
</figure>

<p>We can produce balanced patterns by branching upwards as well as towards the
right (see <a href="#Exercise-2_002e44">Exercise 2.44</a>, <a href="#Figure-2_002e13">Figure 2.13</a> and <a href="#Figure-2_002e14">Figure 2.14</a>):
</p>
<div class="lisp">
<pre class="lisp">(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter 
                                (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right 
                                   right))
              (corner (corner-split painter 
                                    (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right 
                         corner))))))
</pre></div>

<figure class="float">
<a id="Figure-2_002e14"></a>
<object style="width: 52.93ex; height: 62.25ex;" data="fig/chap2/Fig2.14b.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.14:</strong> The recursive operations <code>right-split</code> and <code>corner-split</code> applied to the painters <code>wave</code> and <code>rogers</code>.  Combining four <code>corner-split</code> figures produces symmetric <code>square-limit</code> designs as shown in <a href="#Figure-2_002e9">Figure 2.9</a>.</p>
</figcaption>
</figure>

<p>By placing four copies of a <code>corner-split</code> appropriately, we obtain a
pattern called <code>square-limit</code>, whose application to <code>wave</code> and
<code>rogers</code> is shown in <a href="#Figure-2_002e9">Figure 2.9</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) 
                        quarter)))
      (below (flip-vert half) half))))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-2_002e44"></a>Exercise 2.44:</strong> Define the procedure
<code>up-split</code> used by <code>corner-split</code>.  It is similar to
<code>right-split</code>, except that it switches the roles of <code>below</code> and
<code>beside</code>.
</p></blockquote>

<a id="Higher_002dorder-operations"></a>
<h5 class="subsubheading">Higher-order operations</h5>

<p>In addition to abstracting patterns of combining painters, we can work at a
higher level, abstracting patterns of combining painter operations.  That is,
we can view the painter operations as elements to manipulate and can write
means of combination for these elements—procedures that take painter
operations as arguments and create new painter operations.
</p>
<p>For example, <code>flipped-pairs</code> and <code>square-limit</code> each arrange four
copies of a painter’s image in a square pattern; they differ only in how they
orient the copies.  One way to abstract this pattern of painter combination is
with the following procedure, which takes four one-argument painter operations
and produces a painter operation that transforms a given painter with those
four operations and arranges the results in a square.  <code>Tl</code>, <code>tr</code>,
<code>bl</code>, and <code>br</code> are the transformations to apply to the top left copy,
the top right copy, the bottom left copy, and the bottom right copy,
respectively.
</p>
<div class="lisp">
<pre class="lisp">(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) 
                       (tr painter)))
          (bottom (beside (bl painter) 
                          (br painter))))
      (below bottom top))))
</pre></div>

<p>Then <code>flipped-pairs</code> can be defined in terms of <code>square-of-four</code> as
follows:<a class="footnote_link" id="DOCF90" href="#FOOT90"><sup>90</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (flipped-pairs painter)
  (let ((combine4 
         (square-of-four identity 
                         flip-vert
                         identity 
                         flip-vert)))
    (combine4 painter)))
</pre></div>

<p>and <code>square-limit</code> can be expressed as<a class="footnote_link" id="DOCF91" href="#FOOT91"><sup>91</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (square-limit painter n)
  (let ((combine4 
         (square-of-four flip-horiz 
                         identity
                         rotate180 
                         flip-vert)))
    (combine4 (corner-split painter n))))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-2_002e45"></a>Exercise 2.45:</strong> <code>Right-split</code> and
<code>up-split</code> can be expressed as instances of a general splitting operation.
Define a procedure <code>split</code> with the property that evaluating
</p>
<div class="lisp">
<pre class="lisp">(define right-split (split beside below))
(define up-split (split below beside))
</pre></div>

<p>produces procedures <code>right-split</code> and <code>up-split</code> with the same
behaviors as the ones already defined.
</p></blockquote>

<a id="Frames"></a>
<h5 class="subsubheading">Frames</h5>

<p>Before we can show how to implement painters and their means of combination, we
must first consider frames.  A frame can be described by three vectors—an
origin vector and two edge vectors.  The origin vector specifies the offset of
the frame’s origin from some absolute origin in the plane, and the edge vectors
specify the offsets of the frame’s corners from its origin.  If the edges are
perpendicular, the frame will be rectangular.  Otherwise the frame will be a
more general parallelogram.
</p>
<p><a href="#Figure-2_002e15">Figure 2.15</a> shows a frame and its associated vectors.
In accordance with data abstraction, we need not be specific yet about how
frames are represented, other than to say that there is a constructor
<code>make-frame</code>, which takes three vectors and produces a frame, and three
corresponding selectors <code>origin-frame</code>, <code>edge1-frame</code>, and
<code>edge2-frame</code> (see <a href="#Exercise-2_002e47">Exercise 2.47</a>).
</p>
<figure class="float">
<a id="Figure-2_002e15"></a>
<object style="width: 34.02ex; height: 32.03ex;" data="fig/chap2/Fig2.15a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.15:</strong> A frame is described by three vectors — an origin and two edges.</p>
</figcaption>
</figure>

<p>We will use coordinates in the unit square \( {(0 \le x, y \le 1)} \) to specify
images.  With each frame, we associate a <a id="index-frame-coordinate-map"></a>
<em>frame coordinate map</em>, which
will be used to shift and scale images to fit the frame.  The map transforms
the unit square into the frame by mapping the vector \( {{\bf v} = (x, y)} \) to
the vector sum
\[ % :40:
  {\text{Origin(Frame)}} + {x \cdot \text{Edge}_1\text{(Frame)}} + {y \cdot \text{Edge}_2\text{(Frame)}.} \]
For example, (0, 0) is mapped to the origin of the frame, (1, 1) to the vertex
diagonally opposite the origin, and (0.5, 0.5) to the center of the frame.  We
can create a frame’s coordinate map with the following
procedure:<a class="footnote_link" id="DOCF92" href="#FOOT92"><sup>92</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect 
      (scale-vect (xcor-vect v)
                  (edge1-frame frame))
      (scale-vect (ycor-vect v)
                  (edge2-frame frame))))))
</pre></div>

<p>Observe that applying <code>frame-coord-map</code> to a frame returns a procedure
that, given a vector, returns a vector.  If the argument vector is in the unit
square, the result vector will be in the frame.  For example,
</p>
<div class="lisp">
<pre class="lisp">((frame-coord-map a-frame) (make-vect 0 0))
</pre></div>

<p>returns the same vector as
</p>
<div class="lisp">
<pre class="lisp">(origin-frame a-frame)
</pre></div>

<blockquote>
<p><strong><a id="Exercise-2_002e46"></a>Exercise 2.46:</strong> A two-dimensional vector \( \bf v \)
running from the origin to a point can be represented as a pair consisting of
an \( x \)-coordinate and a \( y \)-coordinate.  Implement a data abstraction for
vectors by giving a constructor <code>make-vect</code> and corresponding selectors
<code>xcor-vect</code> and <code>ycor-vect</code>.  In terms of your selectors and
constructor, implement procedures <code>add-vect</code>, <code>sub-vect</code>, and
<code>scale-vect</code> that perform the operations vector addition, vector
subtraction, and multiplying a vector by a scalar:
\[ % :41:
  
\begin{eqnarray}
	(x_1, y_1) + (x_2, y_2)  &amp;=&amp;  (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2)  &amp;=&amp;  (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 		 &amp;=&amp;  (sx, sy).
\end{eqnarray}
\]
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e47"></a>Exercise 2.47:</strong> Here are two possible
constructors for frames:
</p>
<div class="lisp">
<pre class="lisp">(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
</pre></div>

<p>For each constructor supply the appropriate selectors to produce an
implementation for frames.
</p></blockquote>

<a id="Painters"></a>
<h5 class="subsubheading">Painters</h5>

<p>A painter is represented as a procedure that, given a frame as argument, draws
a particular image shifted and scaled to fit the frame.  That is to say, if
<code>p</code> is a painter and <code>f</code> is a frame, then we produce <code>p</code>’s image
in <code>f</code> by calling <code>p</code> with <code>f</code> as argument.
</p>
<p>The details of how primitive painters are implemented depend on the particular
characteristics of the graphics system and the type of image to be drawn.  For
instance, suppose we have a procedure <code>draw-line</code> that draws a line on the
screen between two specified points.  Then we can create painters for line
drawings, such as the <code>wave</code> painter in <a href="#Figure-2_002e10">Figure 2.10</a>, from lists of
line segments as follows:<a class="footnote_link" id="DOCF93" href="#FOOT93"><sup>93</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (segments-&gt;painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) 
         (start-segment segment))
        ((frame-coord-map frame) 
         (end-segment segment))))
     segment-list)))
</pre></div>

<p>The segments are given using coordinates with respect to the unit square.  For
each segment in the list, the painter transforms the segment endpoints with the
frame coordinate map and draws a line between the transformed points.
</p>
<p>Representing painters as procedures erects a powerful abstraction barrier in
the picture language.  We can create and intermix all sorts of primitive
painters, based on a variety of graphics capabilities. The details of their
implementation do not matter.  Any procedure can serve as a painter, provided
that it takes a frame as argument and draws something scaled to fit the
frame.<a class="footnote_link" id="DOCF94" href="#FOOT94"><sup>94</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e48"></a>Exercise 2.48:</strong> A directed line segment in the
plane can be represented as a pair of vectors—the vector running from the
origin to the start-point of the segment, and the vector running from the
origin to the end-point of the segment.  Use your vector representation from
<a href="#Exercise-2_002e46">Exercise 2.46</a> to define a representation for segments with a constructor
<code>make-segment</code> and selectors <code>start-segment</code> and <code>end-segment</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e49"></a>Exercise 2.49:</strong> Use <code>segments-&gt;painter</code>
to define the following primitive painters:
</p>
<ol>
<li> The painter that draws the outline of the designated frame.

</li><li> The painter that draws an “X” by connecting opposite corners of the frame.

</li><li> The painter that draws a diamond shape by connecting the midpoints of the sides
of the frame.

</li><li> The <code>wave</code> painter.

</li></ol>
</blockquote>

<a id="Transforming-and-combining-painters"></a>
<h5 class="subsubheading">Transforming and combining painters</h5>

<p>An operation on painters (such as <code>flip-vert</code> or <code>beside</code>) works by
creating a painter that invokes the original painters with respect to frames
derived from the argument frame.  Thus, for example, <code>flip-vert</code> doesn’t
have to know how a painter works in order to flip it—it just has to know how
to turn a frame upside down: The flipped painter just uses the original
painter, but in the inverted frame.
</p>
<p>Painter operations are based on the procedure <code>transform-painter</code>, which
takes as arguments a painter and information on how to transform a frame and
produces a new painter.  The transformed painter, when called on a frame,
transforms the frame and calls the original painter on the transformed frame.
The arguments to <code>transform-painter</code> are points (represented as vectors)
that specify the corners of the new frame: When mapped into the frame, the
first point specifies the new frame’s origin and the other two specify the ends
of its edge vectors.  Thus, arguments within the unit square specify a frame
contained within the original frame.
</p>
<div class="lisp">
<pre class="lisp">(define (transform-painter 
         painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame new-origin
                  (sub-vect (m corner1) 
                            new-origin)
                  (sub-vect (m corner2)
                            new-origin)))))))
</pre></div>

<p>Here’s how to flip painter images vertically:
</p>
<div class="lisp">
<pre class="lisp">(define (flip-vert painter)
  (transform-painter 
   painter
   (make-vect 0.0 1.0)   <span class="roman">; new <code>origin</code></span>
   (make-vect 1.0 1.0)   <span class="roman">; new end of <code>edge1</code></span>
   (make-vect 0.0 0.0))) <span class="roman">; new end of <code>edge2</code></span>
</pre></div>

<p>Using <code>transform-painter</code>, we can easily define new transformations.
For example, we can define a painter that shrinks its image to the
upper-right quarter of the frame it is given:
</p>
<div class="lisp">
<pre class="lisp">(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
</pre></div>

<p>Other transformations rotate images counterclockwise by 90
degrees<a class="footnote_link" id="DOCF95" href="#FOOT95"><sup>95</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
</pre></div>

<p>or squash images towards the center of the frame:<a class="footnote_link" id="DOCF96" href="#FOOT96"><sup>96</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
</pre></div>

<p>Frame transformation is also the key to defining means of combining two or more
painters.  The <code>beside</code> procedure, for example, takes two painters,
transforms them to paint in the left and right halves of an argument frame
respectively, and produces a new, compound painter.  When the compound painter
is given a frame, it calls the first transformed painter to paint in the left
half of the frame and calls the second transformed painter to paint in the
right half of the frame:
</p>
<div class="lisp">
<pre class="lisp">(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left  (transform-painter 
                        painter1
                        (make-vect 0.0 0.0)
                        split-point
                        (make-vect 0.0 1.0)))
          (paint-right (transform-painter
                        painter2
                        split-point
                        (make-vect 1.0 0.0)
                        (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
</pre></div>

<p>Observe how the painter data abstraction, and in particular the representation
of painters as procedures, makes <code>beside</code> easy to implement.  The
<code>beside</code> procedure need not know anything about the details of the
component painters other than that each painter will draw something in its
designated frame.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e50"></a>Exercise 2.50:</strong> Define the transformation
<code>flip-horiz</code>, which flips painters horizontally, and transformations that
rotate painters counterclockwise by 180 degrees and 270 degrees.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e51"></a>Exercise 2.51:</strong> Define the <code>below</code> operation
for painters.  <code>Below</code> takes two painters as arguments.  The resulting
painter, given a frame, draws with the first painter in the bottom of the frame
and with the second painter in the top.  Define <code>below</code> in two different
ways—first by writing a procedure that is analogous to the <code>beside</code>
procedure given above, and again in terms of <code>beside</code> and suitable
rotation operations (from <a href="#Exercise-2_002e50">Exercise 2.50</a>).
</p></blockquote>

<a id="Levels-of-language-for-robust-design"></a>
<h5 class="subsubheading">Levels of language for robust design</h5>

<p>The picture language exercises some of the critical ideas we’ve introduced
about abstraction with procedures and data.  The fundamental data abstractions,
painters, are implemented using procedural representations, which enables the
language to handle different basic drawing capabilities in a uniform way.  The
means of combination satisfy the closure property, which permits us to easily
build up complex designs.  Finally, all the tools for abstracting procedures
are available to us for abstracting means of combination for painters.
</p>
<p>We have also obtained a glimpse of another crucial idea about languages and
program design.  This is the approach of <a id="index-stratified-design"></a>
<em>stratified design</em>, the
notion that a complex system should be structured as a sequence of levels that
are described using a sequence of languages.  Each level is constructed by
combining parts that are regarded as primitive at that level, and the parts
constructed at each level are used as primitives at the next level.  The
language used at each level of a stratified design has primitives, means of
combination, and means of abstraction appropriate to that level of detail.
</p>
<p>Stratified design pervades the engineering of complex systems.  For example, in
computer engineering, resistors and transistors are combined (and described
using a language of analog circuits) to produce parts such as and-gates and
or-gates, which form the primitives of a language for digital-circuit
design.<a class="footnote_link" id="DOCF97" href="#FOOT97"><sup>97</sup></a> These parts
are combined to build processors, bus structures, and memory systems, which are
in turn combined to form computers, using languages appropriate to computer
architecture.  Computers are combined to form distributed systems, using
languages appropriate for describing network interconnections, and so on.
</p>
<p>As a tiny example of stratification, our picture language uses primitive
elements (primitive painters) that are created using a language that specifies
points and lines to provide the lists of line segments for
<code>segments-&gt;painter</code>, or the shading details for a painter like
<code>rogers</code>.  The bulk of our description of the picture language focused on
combining these primitives, using geometric combiners such as <code>beside</code> and
<code>below</code>.  We also worked at a higher level, regarding <code>beside</code> and
<code>below</code> as primitives to be manipulated in a language whose operations,
such as <code>square-of-four</code>, capture common patterns of combining geometric
combiners.
</p>
<p>Stratified design helps make programs <a id="index-robust"></a>
<em>robust</em>, that is, it makes it
likely that small changes in a specification will require correspondingly small
changes in the program.  For instance, suppose we wanted to change the image
based on <code>wave</code> shown in <a href="#Figure-2_002e9">Figure 2.9</a>.  We could work at the lowest
level to change the detailed appearance of the <code>wave</code> element; we could
work at the middle level to change the way <code>corner-split</code> replicates the
<code>wave</code>; we could work at the highest level to change how
<code>square-limit</code> arranges the four copies of the corner.  In general, each
level of a stratified design provides a different vocabulary for expressing the
characteristics of the system, and a different kind of ability to change it.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e52"></a>Exercise 2.52:</strong> Make changes to the square limit
of <code>wave</code> shown in <a href="#Figure-2_002e9">Figure 2.9</a> by working at each of the levels
described above.  In particular:
</p>
<ol>
<li> Add some segments to the primitive <code>wave</code> painter of <a href="#Exercise-2_002e49">Exercise 2.49</a>
(to add a smile, for example).

</li><li> Change the pattern constructed by <code>corner-split</code> (for example, by using
only one copy of the <code>up-split</code> and <code>right-split</code> images instead of
two).

</li><li> Modify the version of <code>square-limit</code> that uses <code>square-of-four</code> so as
to assemble the corners in a different pattern.  (For example, you might make
the big Mr. Rogers look outward from each corner of the square.)

</li></ol>
</blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT88"><p><a class="footnote_backlink" href="#DOCF88"><sup>88</sup></a>
The picture
language is based on the language Peter Henderson created to construct images
like M.C. Escher’s “Square Limit” woodcut (see <a href="References.xhtml#Henderson-1982">Henderson 1982</a>).  The woodcut
incorporates a repeated scaled pattern, similar to the arrangements drawn using
the <code>square-limit</code> procedure in this section.</p>
</div>
<div id="FOOT89"><p><a class="footnote_backlink" href="#DOCF89"><sup>89</sup></a>
William Barton Rogers (1804-1882) was the founder
and first president of <abbr>MIT</abbr>.  A geologist and talented teacher, he
taught at William and Mary College and at the University of Virginia.  In 1859
he moved to Boston, where he had more time for research, worked on a plan for
establishing a “polytechnic institute,” and served as Massachusetts’s first
State Inspector of Gas Meters.
</p>
<p>When <abbr>MIT</abbr> was established in 1861, Rogers was elected its first
president.  Rogers espoused an ideal of “useful learning” that was different
from the university education of the time, with its overemphasis on the
classics, which, as he wrote, “stand in the way of the broader, higher and
more practical instruction and discipline of the natural and social sciences.”
This education was likewise to be different from narrow trade-school education.
In Rogers’s words:
</p>
<blockquote>
<p>The world-enforced distinction between the practical and the scientific worker
is utterly futile, and the whole experience of modern times has demonstrated
its utter worthlessness.
</p></blockquote>

<p>Rogers served as president of <abbr>MIT</abbr> until 1870, when he resigned due to
ill health.  In 1878 the second president of <abbr>MIT</abbr>, John Runkle,
resigned under the pressure of a financial crisis brought on by the Panic of
1873 and strain of fighting off attempts by Harvard to take over <abbr>MIT</abbr>.
Rogers returned to hold the office of president until 1881.
</p>
<p>Rogers collapsed and died while addressing <abbr>MIT</abbr>’s graduating class at
the commencement exercises of 1882.  Runkle quoted Rogers’s last words in a
memorial address delivered that same year:
</p>
<blockquote>
<p>“As I stand here today and see what the Institute is, … I call to mind
the beginnings of science.  I remember one hundred and fifty years ago Stephen
Hales published a pamphlet on the subject of illuminating gas, in which he
stated that his researches had demonstrated that 128 grains of bituminous coal
– ” “Bituminous coal,” these were his last words on earth.  Here he bent
forward, as if consulting some notes on the table before him, then slowly
regaining an erect position, threw up his hands, and was translated from the
scene of his earthly labors and triumphs to “the tomorrow of death,” where
the mysteries of life are solved, and the disembodied spirit finds unending
satisfaction in contemplating the new and still unfathomable mysteries of the
infinite future.
</p></blockquote>

<p>In the words of Francis A. Walker (<abbr>MIT</abbr>’s third president):
</p>
<blockquote>
<p>All his life he had borne himself most faithfully and heroically, and he died
as so good a knight would surely have wished, in harness, at his post, and in
the very part and act of public duty.
</p></blockquote>
</div>
<div id="FOOT90"><p><a class="footnote_backlink" href="#DOCF90"><sup>90</sup></a>
Equivalently, we could write
</p>
<div class="lisp">
<pre class="lisp">(define flipped-pairs
  (square-of-four 
   identity flip-vert identity flip-vert))
</pre></div>
</div>
<div id="FOOT91"><p><a class="footnote_backlink" href="#DOCF91"><sup>91</sup></a>
<code>Rotate180</code> rotates a
painter by 180 degrees (see <a href="#Exercise-2_002e50">Exercise 2.50</a>).  Instead of <code>rotate180</code>
we could say <code>(compose flip-vert flip-horiz)</code>, using the <code>compose</code>
procedure from <a href="1_002e3_002e4.xhtml#Exercise-1_002e42">Exercise 1.42</a>.</p>
</div>
<div id="FOOT92"><p><a class="footnote_backlink" href="#DOCF92"><sup>92</sup></a>
<code>Frame-coord-map</code> uses the vector operations described
in <a href="#Exercise-2_002e46">Exercise 2.46</a> below, which we assume have been implemented using some
representation for vectors.  Because of data abstraction, it doesn’t matter
what this vector representation is, so long as the vector operations behave
correctly.</p>
</div>
<div id="FOOT93"><p><a class="footnote_backlink" href="#DOCF93"><sup>93</sup></a>
<code>Segments-&gt;painter</code> uses the
representation for line segments described in <a href="#Exercise-2_002e48">Exercise 2.48</a> below.  It
also uses the <code>for-each</code> procedure described in <a href="2_002e2_002e1.xhtml#Exercise-2_002e23">Exercise 2.23</a>.</p>
</div>
<div id="FOOT94"><p><a class="footnote_backlink" href="#DOCF94"><sup>94</sup></a>
For example, the <code>rogers</code> painter of <a href="#Figure-2_002e11">Figure 2.11</a> was
constructed from a gray-level image.  For each point in a given frame, the
<code>rogers</code> painter determines the point in the image that is mapped to it
under the frame coordinate map, and shades it accordingly.  By allowing
different types of painters, we are capitalizing on the abstract data idea
discussed in <a href="2_002e1_002e3.xhtml#g_t2_002e1_002e3">2.1.3</a>, where we argued that a rational-number
representation could be anything at all that satisfies an appropriate
condition.  Here we’re using the fact that a painter can be implemented in any
way at all, so long as it draws something in the designated frame.  
<a href="2_002e1_002e3.xhtml#g_t2_002e1_002e3">2.1.3</a> also showed how pairs could be implemented as procedures.  Painters
are our second example of a procedural representation for data.</p>
</div>
<div id="FOOT95"><p><a class="footnote_backlink" href="#DOCF95"><sup>95</sup></a>
<code>Rotate90</code> is a pure rotation only for square frames,
because it also stretches and shrinks the image to fit into the rotated frame.</p>
</div>
<div id="FOOT96"><p><a class="footnote_backlink" href="#DOCF96"><sup>96</sup></a>
The diamond-shaped
images in <a href="#Figure-2_002e10">Figure 2.10</a> and <a href="#Figure-2_002e11">Figure 2.11</a> were created with
<code>squash-inwards</code> applied to <code>wave</code> and <code>rogers</code>.</p>
</div>
<div id="FOOT97"><p><a class="footnote_backlink" href="#DOCF97"><sup>97</sup></a>
Section <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a> describes one such language.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="n" rel="next">2.3</a>, Previous: <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3" accesskey="p" rel="prev">2.2.3</a>, Up: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="u" rel="prev">2.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
