<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.3.4</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.3.4"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.3.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="3_002e3.xhtml#g_t3_002e3" rel="prev" title="3.3"/>
<link href="3_002e3_002e5.xhtml#g_t3_002e3_002e5" rel="next" title="3.3.5"/>
<link href="3_002e3_002e3.xhtml#g_t3_002e3_002e3" rel="prev" title="3.3.3"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e3_002e4"></a>
<nav class="header">
<p>
Next: <a href="3_002e3_002e5.xhtml#g_t3_002e3_002e5" accesskey="n" rel="next">3.3.5</a>, Previous: <a href="3_002e3_002e3.xhtml#g_t3_002e3_002e3" accesskey="p" rel="prev">3.3.3</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="A-Simulator-for-Digital-Circuits"></a>
<h4 class="subsection"><span class="secnum">3.3.4</span><span class="sectitle">A Simulator for Digital Circuits</span></h4>

<p>Designing complex digital systems, such as computers, is an important
engineering activity.  Digital systems are constructed by interconnecting
simple elements.  Although the behavior of these individual elements is simple,
networks of them can have very complex behavior.  Computer simulation of
proposed circuit designs is an important tool used by digital systems
engineers.  In this section we design a system for performing digital logic
simulations.  This system typifies a kind of program called an
<a id="index-event_002ddriven-simulation"></a>
<em>event-driven simulation</em>, in which actions (“events”) trigger
further events that happen at a later time, which in turn trigger more events,
and so on.
</p>
<p>Our computational model of a circuit will be composed of objects that
correspond to the elementary components from which the circuit is constructed.
There are <a id="index-wires"></a>
<em>wires</em>, which carry <a id="index-digital-signals"></a>
<em>digital signals</em>.  A digital
signal may at any moment have only one of two possible values, 0 and 1.  There
are also various types of digital <a id="index-function-boxes"></a>
<em>function boxes</em>, which connect wires
carrying input signals to other output wires.  Such boxes produce output
signals computed from their input signals.  The output signal is delayed by a
time that depends on the type of the function box.  For example, an
<a id="index-inverter"></a>
<em>inverter</em> is a primitive function box that inverts its input.  If the
input signal to an inverter changes to 0, then one inverter-delay later the
inverter will change its output signal to 1.  If the input signal to an
inverter changes to 1, then one inverter-delay later the inverter will change
its output signal to 0.  We draw an inverter symbolically as in <a href="#Figure-3_002e24">Figure 3.24</a>.  
An <a id="index-and_002dgate"></a>
<em>and-gate</em>, also shown in figure 3.24, is a primitive
function box with two inputs and one output.  It drives its output signal to a
value that is the <a id="index-logical-and"></a>
<em>logical and</em> of the inputs.  That is, if both of its
input signals become 1, then one and-gate-delay time later the and-gate will
force its output signal to be 1; otherwise the output will be 0.  An
<a id="index-or_002dgate"></a>
<em>or-gate</em> is a similar two-input primitive function box that drives its
output signal to a value that is the <a id="index-logical-or"></a>
<em>logical or</em> of the inputs.  That
is, the output will become 1 if at least one of the input signals is 1;
otherwise the output will become 0.
</p>
<figure class="float">
<a id="Figure-3_002e24"></a>
<object style="width: 49.30ex; height: 11.14ex;" data="fig/chap3/Fig3.24a.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.24:</strong> Primitive functions in the digital logic simulator.</p>
</figcaption>
</figure>

<p>We can connect primitive functions together to construct more complex
functions.  To accomplish this we wire the outputs of some function boxes to
the inputs of other function boxes.  For example, the <a id="index-half_002dadder"></a>
<em>half-adder</em>
circuit shown in <a href="#Figure-3_002e25">Figure 3.25</a> consists of an or-gate, two and-gates, and
an inverter.  It takes two input signals, A and B, and has two output signals,
S and C.  S will become 1 whenever precisely one of A and B is 1, and C will
become 1 whenever A and B are both 1.  We can see from the figure that, because
of the delays involved, the outputs may be generated at different times.  Many
of the difficulties in the design of digital circuits arise from this fact.
</p>
<figure class="float">
<a id="Figure-3_002e25"></a>
<object style="width: 48.52ex; height: 19.17ex;" data="fig/chap3/Fig3.25c.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.25:</strong> A half-adder circuit.</p>
</figcaption>
</figure>

<p>We will now build a program for modeling the digital logic circuits we wish to
study.  The program will construct computational objects modeling the wires,
which will “hold” the signals.  Function boxes will be modeled by procedures
that enforce the correct relationships among the signals.
</p>
<p>One basic element of our simulation will be a procedure <code>make-wire</code>, which
constructs wires.  For example, we can construct six wires as follows:
</p>
<div class="lisp">
<pre class="lisp">(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
</pre></div>

<p>We attach a function box to a set of wires by calling a procedure that
constructs that kind of box.  The arguments to the constructor procedure are
the wires to be attached to the box.  For example, given that we can construct
and-gates, or-gates, and inverters, we can wire together the half-adder shown
in <a href="#Figure-3_002e25">Figure 3.25</a>:
</p>
<div class="lisp">
<pre class="lisp">(or-gate a b d)
<i>ok</i>

(and-gate a b c)
<i>ok</i>

(inverter c e)
<i>ok</i>

(and-gate d e s)
<i>ok</i>
</pre></div>

<p>Better yet, we can explicitly name this operation by defining a procedure
<code>half-adder</code> that constructs this circuit, given the four external wires
to be attached to the half-adder:
</p>
<div class="lisp">
<pre class="lisp">(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
</pre></div>

<p>The advantage of making this definition is that we can use <code>half-adder</code>
itself as a building block in creating more complex circuits.  <a href="#Figure-3_002e26">Figure 3.26</a>, 
for example, shows a <a id="index-full_002dadder"></a>
<em>full-adder</em> composed of two half-adders
and an or-gate.<a class="footnote_link" id="DOCF154" href="#FOOT154"><sup>154</sup></a> We can construct a full-adder as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (full-adder a b c-in sum c-out)
  (let ((c1 (make-wire)) 
        (c2 (make-wire))
        (s  (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
</pre></div>

<figure class="float">
<a id="Figure-3_002e26"></a>
<object style="width: 51.29ex; height: 19.17ex;" data="fig/chap3/Fig3.26.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.26:</strong> A full-adder circuit.</p>
</figcaption>
</figure>

<p>Having defined <code>full-adder</code> as a procedure, we can now use it as a
building block for creating still more complex circuits.  (For example, see
<a href="#Exercise-3_002e30">Exercise 3.30</a>.)
</p>
<p>In essence, our simulator provides us with the tools to construct a language of
circuits.  If we adopt the general perspective on languages with which we
approached the study of Lisp in <a href="1_002e1.xhtml#g_t1_002e1">1.1</a>, we can say that the
primitive function boxes form the primitive elements of the language, that
wiring boxes together provides a means of combination, and that specifying
wiring patterns as procedures serves as a means of abstraction.
</p>
<a id="Primitive-function-boxes"></a>
<h5 class="subsubheading">Primitive function boxes</h5>

<p>The primitive function boxes implement the “forces” by which a change in the
signal on one wire influences the signals on other wires.  To build function
boxes, we use the following operations on wires:
</p>
<ul>
<li> <code>(get-signal ⟨<var>wire</var>⟩)</code>

<p>returns the current value of the signal on the wire.
</p>
</li><li> <code>(set-signal! ⟨<var>wire</var>⟩ ⟨<var>new value</var>⟩)</code>

<p>changes the value of the signal on the wire to the new value.
</p>
</li><li> <code>(add-action! ⟨<var>wire</var>⟩ ⟨<var>procedure of no arguments</var>⟩)</code>

<p>asserts that the designated procedure should be run whenever the signal on the
wire changes value.  Such procedures are the vehicles by which changes in the
signal value on the wire are communicated to other wires.
</p>
</li></ul>

<p>In addition, we will make use of a procedure <code>after-delay</code> that takes a
time delay and a procedure to be run and executes the given procedure after the
given delay.
</p>
<p>Using these procedures, we can define the primitive digital logic functions.
To connect an input to an output through an inverter, we use <code>add-action!</code>
to associate with the input wire a procedure that will be run whenever the
signal on the input wire changes value.  The procedure computes the
<code>logical-not</code> of the input signal, and then, after one
<code>inverter-delay</code>, sets the output signal to be this new value:
</p>
<div class="lisp">
<pre class="lisp">(define (inverter input output)
  (define (invert-input)
    (let ((new-value 
           (logical-not (get-signal input))))
      (after-delay 
       inverter-delay
       (lambda ()
         (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error &quot;Invalid signal&quot; s))))
</pre></div>

<p>An and-gate is a little more complex.  The action procedure must be run if
either of the inputs to the gate changes.  It computes the <code>logical-and</code>
(using a procedure analogous to <code>logical-not</code>) of the values of the
signals on the input wires and sets up a change to the new value to occur on
the output wire after one <code>and-gate-delay</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) 
                        (get-signal a2))))
      (after-delay 
       and-gate-delay
       (lambda ()
         (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
</pre></div>

<blockquote>
<p><strong><a id="Exercise-3_002e28"></a>Exercise 3.28:</strong> Define an or-gate as a primitive
function box.  Your <code>or-gate</code> constructor should be similar to
<code>and-gate</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e29"></a>Exercise 3.29:</strong> Another way to construct an
or-gate is as a compound digital logic device, built from and-gates and
inverters.  Define a procedure <code>or-gate</code> that accomplishes this.  What is
the delay time of the or-gate in terms of <code>and-gate-delay</code> and
<code>inverter-delay</code>?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e30"></a>Exercise 3.30:</strong> <a href="#Figure-3_002e27">Figure 3.27</a> shows a
<a id="index-ripple_002dcarry-adder"></a>
<em>ripple-carry adder</em> formed by stringing together \( n \) full-adders.
This is the simplest form of parallel adder for adding two \( n \)-bit binary
numbers.  The inputs \( A_1 \), \( A_2 \), \( A_3 \), …, \( A_n \) and 
\( B_1 \), \( B_2 \), \( B_3 \),
…, \( B_n \) are the two binary numbers to be added (each \( A_k \) and
\( B_k \) is a 0 or a 1).  The circuit generates \( S_1 \), \( S_2 \), 
\( S_3 \), …, \( S_n \),
the \( n \) bits of the sum, and \( C \), the carry from the addition.  Write a
procedure <code>ripple-carry-adder</code> that generates this circuit.  The procedure
should take as arguments three lists of \( n \) wires each—the \( A_k \), the
\( B_k \), and the \( S_k \)—and also another wire \( C \).  The major drawback of the
ripple-carry adder is the need to wait for the carry signals to propagate.
What is the delay needed to obtain the complete output from an \( n \)-bit
ripple-carry adder, expressed in terms of the delays for and-gates, or-gates,
and inverters?
</p></blockquote>

<figure class="float">
<a id="Figure-3_002e27"></a>
<object style="width: 50.16ex; height: 15.54ex;" data="fig/chap3/Fig3.27b.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.27:</strong> A ripple-carry adder for \( n \)-bit numbers.</p>
</figcaption>
</figure>

<a id="Representing-wires"></a>
<h5 class="subsubheading">Representing wires</h5>

<p>A wire in our simulation will be a computational object with two local state
variables: a <code>signal-value</code> (initially taken to be 0) and a collection of
<code>action-procedures</code> to be run when the signal changes value.  We implement
the wire, using message-passing style, as a collection of local procedures
together with a <code>dispatch</code> procedure that selects the appropriate local
operation, just as we did with the simple bank-account object in 
<a href="3_002e1_002e1.xhtml#g_t3_002e1_002e1">3.1.1</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (make-wire)
  (let ((signal-value 0) 
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each 
                  action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures 
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) 
             signal-value)
            ((eq? m 'set-signal!) 
             set-my-signal!)
            ((eq? m 'add-action!) 
             accept-action-procedure!)
            (else (error &quot;Unknown operation: 
                          WIRE&quot; m))))
    dispatch))
</pre></div>

<p>The local procedure <code>set-my-signal!</code> tests whether the new signal value
changes the signal on the wire.  If so, it runs each of the action procedures,
using the following procedure <code>call-each</code>, which calls each of the items
in a list of no-argument procedures:
</p>
<div class="lisp">
<pre class="lisp">(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))
</pre></div>

<p>The local procedure <code>accept-action-procedure!</code> adds the given procedure to
the list of procedures to be run, and then runs the new procedure once.  (See
<a href="#Exercise-3_002e31">Exercise 3.31</a>.)
</p>
<p>With the local <code>dispatch</code> procedure set up as specified, we can provide
the following procedures to access the local operations on
wires:<a class="footnote_link" id="DOCF155" href="#FOOT155"><sup>155</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
</pre></div>

<p>Wires, which have time-varying signals and may be incrementally attached to
devices, are typical of mutable objects.  We have modeled them as procedures
with local state variables that are modified by assignment.  When a new wire is
created, a new set of state variables is allocated (by the <code>let</code>
expression in <code>make-wire</code>) and a new <code>dispatch</code> procedure is
constructed and returned, capturing the environment with the new state
variables.
</p>
<p>The wires are shared among the various devices that have been connected to
them.  Thus, a change made by an interaction with one device will affect all
the other devices attached to the wire.  The wire communicates the change to
its neighbors by calling the action procedures provided to it when the
connections were established.
</p>
<a id="The-agenda"></a>
<h5 class="subsubheading">The agenda</h5>

<p>The only thing needed to complete the simulator is <code>after-delay</code>.  The
idea here is that we maintain a data structure, called an <a id="index-agenda"></a>
<em>agenda</em>,
that contains a schedule of things to do.  The following operations are defined
for agendas:
</p>
<ul>
<li> <code>(make-agenda)</code> returns a new empty agenda.

</li><li> <code>(empty-agenda? ⟨<var>agenda</var>⟩)</code> is true if the specified agenda is
empty.

</li><li> <code>(first-agenda-item ⟨<var>agenda</var>⟩)</code> returns the first item on the
agenda.

</li><li> <code>(remove-first-agenda-item! ⟨<var>agenda</var>⟩)</code> modifies the agenda by
removing the first item.

</li><li> <code>(add-to-agenda! ⟨<var>time</var>⟩ ⟨<var>action</var>⟩ ⟨<var>agenda</var>⟩)</code> 
modifies the agenda by adding the given action procedure to be run at the 
specified time.

</li><li> <code>(current-time ⟨<var>agenda</var>⟩)</code> returns the current simulation time.

</li></ul>

<p>The particular agenda that we use is denoted by <code>the-agenda</code>.  The
procedure <code>after-delay</code> adds new elements to <code>the-agenda</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (after-delay delay action)
  (add-to-agenda! 
   (+ delay (current-time the-agenda))
   action
   the-agenda))
</pre></div>

<p>The simulation is driven by the procedure <code>propagate</code>, which operates on
<code>the-agenda</code>, executing each procedure on the agenda in sequence.  In
general, as the simulation runs, new items will be added to the agenda, and
<code>propagate</code> will continue the simulation as long as there are items on the
agenda:
</p>
<div class="lisp">
<pre class="lisp">(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item 
             (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
</pre></div>

<a id="A-sample-simulation"></a>
<h5 class="subsubheading">A sample simulation</h5>

<p>The following procedure, which places a “probe” on a wire, shows the
simulator in action.  The probe tells the wire that, whenever its signal
changes value, it should print the new signal value, together with the current
time and a name that identifies the wire:
</p>
<div class="lisp">
<pre class="lisp">(define (probe name wire)
  (add-action! 
   wire
   (lambda ()
     (newline)
     (display name)
     (display &quot; &quot;)
     (display (current-time the-agenda))
     (display &quot;  New-value = &quot;)
     (display (get-signal wire)))))
</pre></div>

<p>We begin by initializing the agenda and specifying delays for the primitive
function boxes:
</p>
<div class="lisp">
<pre class="lisp">(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
</pre></div>

<p>Now we define four wires, placing probes on two of them:
</p>
<div class="lisp">
<pre class="lisp">(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
<i>sum 0  New-value = 0</i>

(probe 'carry carry)
<i>carry 0  New-value = 0</i>
</pre></div>

<p>Next we connect the wires in a half-adder circuit (as in <a href="#Figure-3_002e25">Figure 3.25</a>),
set the signal on <code>input-1</code> to 1, and run the simulation:
</p>
<div class="lisp">
<pre class="lisp">(half-adder input-1 input-2 sum carry)
<i>ok</i>

(set-signal! input-1 1)
<i>done</i>

(propagate)
<i>sum 8  New-value = 1</i>
<i>done</i>
</pre></div>

<p>The <code>sum</code> signal changes to 1 at time 8.  We are now eight time units from
the beginning of the simulation.  At this point, we can set the signal on
<code>input-2</code> to 1 and allow the values to propagate:
</p>
<div class="lisp">
<pre class="lisp">(set-signal! input-2 1)
<i>done</i>

(propagate)
<i>carry 11  New-value = 1</i>
<i>sum 16  New-value = 0</i>
<i>done</i>
</pre></div>

<p>The <code>carry</code> changes to 1 at time 11 and the <code>sum</code> changes to 0 at
time 16.
</p>
<blockquote>
<p><strong><a id="Exercise-3_002e31"></a>Exercise 3.31:</strong> The internal procedure
<code>accept-action-procedure!</code> defined in <code>make-wire</code> specifies that when
a new action procedure is added to a wire, the procedure is immediately run.
Explain why this initialization is necessary.  In particular, trace through the
half-adder example in the paragraphs above and say how the system’s response
would differ if we had defined <code>accept-action-procedure!</code> as
</p>
<div class="lisp">
<pre class="lisp">(define (accept-action-procedure! proc)
  (set! action-procedures 
        (cons proc action-procedures)))
</pre></div>
</blockquote>

<a id="Implementing-the-agenda"></a>
<h5 class="subsubheading">Implementing the agenda</h5>

<p>Finally, we give details of the agenda data structure, which holds the
procedures that are scheduled for future execution.
</p>
<p>The agenda is made up of <a id="index-time-segments"></a>
<em>time segments</em>.  Each time segment is a pair
consisting of a number (the time) and a queue (see <a href="#Exercise-3_002e32">Exercise 3.32</a>) that
holds the procedures that are scheduled to be run during that time segment.
</p>
<div class="lisp">
<pre class="lisp">(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
</pre></div>

<p>We will operate on the time-segment queues using the queue operations described
in <a href="3_002e3_002e2.xhtml#g_t3_002e3_002e2">3.3.2</a>.
</p>
<p>The agenda itself is a one-dimensional table of time segments.  It differs from
the tables described in <a href="3_002e3_002e3.xhtml#g_t3_002e3_002e3">3.3.3</a> in that the segments will be sorted
in order of increasing time.  In addition, we store the <a id="index-current-time"></a>
<em>current time</em>
(i.e., the time of the last action that was processed) at the head of the
agenda.  A newly constructed agenda has no time segments and has a current time
of 0:<a class="footnote_link" id="DOCF156" href="#FOOT156"><sup>156</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) 
  (car (segments agenda)))
(define (rest-segments agenda) 
  (cdr (segments agenda)))
</pre></div>

<p>An agenda is empty if it has no time segments:
</p>
<div class="lisp">
<pre class="lisp">(define (empty-agenda? agenda)
  (null? (segments agenda)))
</pre></div>

<p>To add an action to an agenda, we first check if the agenda is empty.  If so,
we create a time segment for the action and install this in the agenda.
Otherwise, we scan the agenda, examining the time of each segment.  If we find
a segment for our appointed time, we add the action to the associated queue.
If we reach a time later than the one to which we are appointed, we insert a
new time segment into the agenda just before it.  If we reach the end of the
agenda, we must create a new time segment at the end.
</p>
<div class="lisp">
<pre class="lisp">(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time 
           (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! 
         (segment-queue (car segments))
         action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment 
                      time 
                      action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment 
                time 
                action)
               segments))
        (add-to-segments! segments))))
</pre></div>

<p>The procedure that removes the first item from the agenda deletes the item at
the front of the queue in the first time segment.  If this deletion makes the
time segment empty, we remove it from the list of segments:<a class="footnote_link" id="DOCF157" href="#FOOT157"><sup>157</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue 
            (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! 
         agenda 
         (rest-segments agenda)))))
</pre></div>

<p>The first agenda item is found at the head of the queue in the first time
segment.  Whenever we extract an item, we also update the current
time:<a class="footnote_link" id="DOCF158" href="#FOOT158"><sup>158</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error &quot;Agenda is empty: 
              FIRST-AGENDA-ITEM&quot;)
      (let ((first-seg 
             (first-segment agenda)))
        (set-current-time! 
         agenda 
         (segment-time first-seg))
        (front-queue 
         (segment-queue first-seg)))))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-3_002e32"></a>Exercise 3.32:</strong> The procedures to be run during
each time segment of the agenda are kept in a queue.  Thus, the procedures for
each segment are called in the order in which they were added to the agenda
(first in, first out).  Explain why this order must be used.  In particular,
trace the behavior of an and-gate whose inputs change from 0, 1 to 1, 0 in the
same segment and say how the behavior would differ if we stored a segment’s
procedures in an ordinary list, adding and removing procedures only at the
front (last in, first out).
</p></blockquote>


<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT154"><p><a class="footnote_backlink" href="#DOCF154"><sup>154</sup></a>
A full-adder is a basic circuit element used in adding
two binary numbers.  Here A and B are the bits at corresponding positions in
the two numbers to be added, and \( \rm C_{in} \) is the carry bit from the
addition one place to the right.  The circuit generates SUM, which is the sum
bit in the corresponding position, and \( \rm C_{out} \), which is the carry
bit to be propagated to the left.</p>
</div>
<div id="FOOT155"><p><a class="footnote_backlink" href="#DOCF155"><sup>155</sup></a>
<a id="Footnote-155"></a>These procedures are simply
syntactic sugar that allow us to use ordinary procedural syntax to access the
local procedures of objects.  It is striking that we can interchange the role
of “procedures” and “data” in such a simple way.  For example, if we write
<code>(wire 'get-signal)</code> we think of <code>wire</code> as a procedure that is called
with the message <code>get-signal</code> as input.  Alternatively, writing
<code>(get-signal wire)</code> encourages us to think of <code>wire</code> as a data object
that is the input to a procedure <code>get-signal</code>.  The truth of the matter is
that, in a language in which we can deal with procedures as objects, there is
no fundamental difference between “procedures” and “data,” and we can
choose our syntactic sugar to allow us to program in whatever style we choose.</p>
</div>
<div id="FOOT156"><p><a class="footnote_backlink" href="#DOCF156"><sup>156</sup></a>
The agenda is a headed list, like the tables in 
<a href="3_002e3_002e3.xhtml#g_t3_002e3_002e3">3.3.3</a>, but since the list is headed by the time, we do not need an
additional dummy header (such as the <code>*table*</code> symbol used with tables).</p>
</div>
<div id="FOOT157"><p><a class="footnote_backlink" href="#DOCF157"><sup>157</sup></a>
Observe
that the <code>if</code> expression in this procedure has no <code>⟨</code><var>alternative</var><code>⟩</code>
expression.  Such a “one-armed <code>if</code> statement” is used to decide whether
to do something, rather than to select between two expressions.  An <code>if</code>
expression returns an unspecified value if the predicate is false and there is
no <code>⟨</code><var>alternative</var><code>⟩</code>.</p>
</div>
<div id="FOOT158"><p><a class="footnote_backlink" href="#DOCF158"><sup>158</sup></a>
In this way, the current time will always be the time of the
action most recently processed.  Storing this time at the head of the agenda
ensures that it will still be available even if the associated time segment has
been deleted.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="3_002e3_002e5.xhtml#g_t3_002e3_002e5" accesskey="n" rel="next">3.3.5</a>, Previous: <a href="3_002e3_002e3.xhtml#g_t3_002e3_002e3" accesskey="p" rel="prev">3.3.3</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
