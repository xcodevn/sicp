<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.4.5</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.4.5"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.4.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e4_002e4.xhtml#g_t4_002e4_002e4" rel="prev" title="4.4.4"/>
<link href="4_002e4_002e4_002e6.xhtml#g_t4_002e4_002e4_002e6" rel="next" title="4.4.4.6"/>
<link href="4_002e4_002e4_002e4.xhtml#g_t4_002e4_002e4_002e4" rel="prev" title="4.4.4.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e4_002e4_002e5"></a>
<nav class="header">
<p>
Next: <a href="4_002e4_002e4_002e6.xhtml#g_t4_002e4_002e4_002e6" accesskey="n" rel="next">4.4.4.6</a>, Previous: <a href="4_002e4_002e4_002e4.xhtml#g_t4_002e4_002e4_002e4" accesskey="p" rel="prev">4.4.4.4</a>, Up: <a href="4_002e4_002e4.xhtml#g_t4_002e4_002e4" accesskey="u" rel="prev">4.4.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Maintaining-the-Data-Base"></a>
<h5 class="subsubsection"><span class="secnum">4.4.4.5</span><span class="sectitle">Maintaining the Data Base</span></h5>

<p>One important problem in designing logic programming languages is that of
arranging things so that as few irrelevant data-base entries as possible will
be examined in checking a given pattern.  In our system, in addition to storing
all assertions in one big stream, we store all assertions whose <code>car</code>s are
constant symbols in separate streams, in a table indexed by the symbol.  To
fetch an assertion that may match a pattern, we first check to see if the
<code>car</code> of the pattern is a constant symbol.  If so, we return (to be tested
using the matcher) all the stored assertions that have the same <code>car</code>.  If
the patternâ€™s <code>car</code> is not a constant symbol, we return all the stored
assertions.  Cleverer methods could also take advantage of information in the
frame, or try also to optimize the case where the <code>car</code> of the pattern is
not a constant symbol.  We avoid building our criteria for indexing (using the
<code>car</code>, handling only the case of constant symbols) into the program;
instead we call on predicates and selectors that embody our criteria.
</p>
<div class="lisp">
<pre class="lisp">(define THE-ASSERTIONS the-empty-stream)

(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))

(define (get-all-assertions) THE-ASSERTIONS)

(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern)
              'assertion-stream))
</pre></div>

<p><code>Get-stream</code> looks up a stream in the table and returns an empty stream if
nothing is stored there.
</p>
<div class="lisp">
<pre class="lisp">(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
</pre></div>

<p>Rules are stored similarly, using the <code>car</code> of the rule conclusion.  Rule
conclusions are arbitrary patterns, however, so they differ from assertions in
that they can contain variables.  A pattern whose <code>car</code> is a constant
symbol can match rules whose conclusions start with a variable as well as rules
whose conclusions have the same <code>car</code>.  Thus, when fetching rules that
might match a pattern whose <code>car</code> is a constant symbol we fetch all rules
whose conclusions start with a variable as well as those whose conclusions have
the same <code>car</code> as the pattern.  For this purpose we store all rules whose
conclusions start with a variable in a separate stream in our table, indexed by
the symbol <code>?</code>.
</p>
<div class="lisp">
<pre class="lisp">(define THE-RULES the-empty-stream)

(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))

(define (get-all-rules) THE-RULES)

(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern)
               'rule-stream)
   (get-stream '? 'rule-stream)))
</pre></div>

<p><code>Add-rule-or-assertion!</code> is used by <code>query-driver-loop</code> to add
assertions and rules to the data base.  Each item is stored in the index, if
appropriate, and in a stream of all assertions or rules in the data base.
</p>
<div class="lisp">
<pre class="lisp">(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))

(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion 
                       old-assertions))
    'ok))

(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES
          (cons-stream rule old-rules))
    'ok))
</pre></div>

<p>To actually store an assertion or a rule, we check to see if it can be indexed.
If so, we store it in the appropriate stream.
</p>
<div class="lisp">
<pre class="lisp">(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream 
                key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream 
                assertion
                current-assertion-stream))))))

(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream 
                  key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream 
                  rule
                  current-rule-stream)))))))
</pre></div>

<p>The following procedures define how the data-base index is used.  A pattern (an
assertion or a rule conclusion) will be stored in the table if it starts with a
variable or a constant symbol.
</p>
<div class="lisp">
<pre class="lisp">(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
</pre></div>

<p>The key under which a pattern is stored in the table is either <code>?</code> (if it
starts with a variable) or the constant symbol with which it starts.
</p>
<div class="lisp">
<pre class="lisp">(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
</pre></div>

<p>The index will be used to retrieve items that might match a pattern if the
pattern starts with a constant symbol.
</p>
<div class="lisp">
<pre class="lisp">(define (use-index? pat)
  (constant-symbol? (car pat)))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-4_002e70"></a>Exercise 4.70:</strong> What is the purpose of the
<code>let</code> bindings in the procedures <code>add-assertion!</code> and
<code>add-rule!</code>?  What would be wrong with the following implementation of
<code>add-assertion!</code>?  Hint: Recall the definition of the infinite stream of
ones in <a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2">3.5.2</a>: <code>(define ones (cons-stream 1 ones))</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion 
                     THE-ASSERTIONS))
  'ok)
</pre></div>
</blockquote>

<hr/>
<nav class="header">
<p>
Next: <a href="4_002e4_002e4_002e6.xhtml#g_t4_002e4_002e4_002e6" accesskey="n" rel="next">4.4.4.6</a>, Previous: <a href="4_002e4_002e4_002e4.xhtml#g_t4_002e4_002e4_002e4" accesskey="p" rel="prev">4.4.4.4</a>, Up: <a href="4_002e4_002e4.xhtml#g_t4_002e4_002e4" accesskey="u" rel="prev">4.4.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
