<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.2</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.2"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e1.xhtml#g_t4_002e1" rel="prev" title="4.1"/>
<link href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" rel="next" title="4.1.3"/>
<link href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" rel="prev" title="4.1.1"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e1_002e2"></a>
<nav class="header">
<p>
Next: <a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" accesskey="n" rel="next">4.1.3</a>, Previous: <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" accesskey="p" rel="prev">4.1.1</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Representing-Expressions"></a>
<h4 class="subsection"><span class="secnum">4.1.2</span><span class="sectitle">Representing Expressions</span></h4>

<p>The evaluator is reminiscent of the symbolic differentiation program discussed
in <a href="2_002e3_002e2.xhtml#g_t2_002e3_002e2">2.3.2</a>.  Both programs operate on symbolic expressions.  In
both programs, the result of operating on a compound expression is determined
by operating recursively on the pieces of the expression and combining the
results in a way that depends on the type of the expression.  In both programs
we used data abstraction to decouple the general rules of operation from the
details of how expressions are represented.  In the differentiation program
this meant that the same differentiation procedure could deal with algebraic
expressions in prefix form, in infix form, or in some other form.  For the
evaluator, this means that the syntax of the language being evaluated is
determined solely by the procedures that classify and extract pieces of
expressions.
</p>
<p>Here is the specification of the syntax of our language:
</p>
<ul>
<li> The only self-evaluating items are numbers and strings:

<div class="lisp">
<pre class="lisp">(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
</pre></div>

</li><li> Variables are represented by symbols:

<div class="lisp">
<pre class="lisp">(define (variable? exp) (symbol? exp))
</pre></div>

</li><li> Quotations have the form <code>(quote ⟨<var>text-of-quotation</var>⟩)</code>:<a class="footnote_link" id="DOCF213" href="#FOOT213"><sup>213</sup></a>

<div class="lisp">
<pre class="lisp">(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp)
  (cadr exp))
</pre></div>

<p><code>Quoted?</code> is defined in terms of the procedure <code>tagged-list?</code>, which
identifies lists beginning with a designated symbol:
</p>
<div class="lisp">
<pre class="lisp">(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
</pre></div>

</li><li> Assignments have the form <code>(set! ⟨<var>var</var>⟩ ⟨<var>value</var>⟩)</code>:

<div class="lisp">
<pre class="lisp">(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) 
  (cadr exp))

(define (assignment-value exp) (caddr exp))
</pre></div>

</li><li> Definitions have the form

<div class="lisp">
<pre class="lisp">(define ⟨<var>var</var>⟩ ⟨<var>value</var>⟩)
</pre></div>

<p>or the form
</p>
<div class="lisp">
<pre class="lisp">(define (⟨<var>var</var>⟩ ⟨<var>param₁</var>⟩ <span class="roman">…</span> ⟨<var>paramₙ</var>⟩)
  ⟨<var>body</var>⟩)
</pre></div>

<p>The latter form (standard procedure definition) is syntactic sugar for
</p>
<div class="lisp">
<pre class="lisp">(define ⟨<var>var</var>⟩
  (lambda (⟨<var>param₁</var>⟩ <span class="roman">…</span> ⟨<var>paramₙ</var>⟩)
    ⟨<var>body</var>⟩))
</pre></div>

<p>The corresponding syntax procedures are the following:
</p>
<div class="lisp">
<pre class="lisp">(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda 
       (cdadr exp)   <span class="roman">; formal parameters</span>
       (cddr exp)))) <span class="roman">; body</span>
</pre></div>

</li><li> <code>Lambda</code> expressions are lists that begin with the symbol <code>lambda</code>:

<div class="lisp">
<pre class="lisp">(define (lambda? exp) 
  (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
</pre></div>

<p>We also provide a constructor for <code>lambda</code> expressions, which is used by
<code>definition-value</code>, above:
</p>
<div class="lisp">
<pre class="lisp">(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
</pre></div>

</li><li> Conditionals begin with <code>if</code> and have a predicate, a consequent, and an
(optional) alternative.  If the expression has no alternative part, we provide
<code>false</code> as the alternative.<a class="footnote_link" id="DOCF214" href="#FOOT214"><sup>214</sup></a>

<div class="lisp">
<pre class="lisp">(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
</pre></div>

<p>We also provide a constructor for <code>if</code> expressions, to be used by
<code>cond-&gt;if</code> to transform <code>cond</code> expressions into <code>if</code>
expressions:
</p>
<div class="lisp">
<pre class="lisp">(define (make-if predicate 
                 consequent 
                 alternative)
  (list 'if 
        predicate 
        consequent 
        alternative))
</pre></div>

</li><li> <code>Begin</code> packages a sequence of expressions into a single expression.  We
include syntax operations on <code>begin</code> expressions to extract the actual
sequence from the <code>begin</code> expression, as well as selectors that return the
first expression and the rest of the expressions in the
sequence.<a class="footnote_link" id="DOCF215" href="#FOOT215"><sup>215</sup></a>

<div class="lisp">
<pre class="lisp">(define (begin? exp) 
  (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
</pre></div>

<p>We also include a constructor <code>sequence-&gt;exp</code> (for use by <code>cond-&gt;if</code>)
that transforms a sequence into a single expression, using <code>begin</code> if
necessary:
</p>
<div class="lisp">
<pre class="lisp">(define (sequence-&gt;exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))

(define (make-begin seq) (cons 'begin seq))
</pre></div>

</li><li> A procedure application is any compound expression that is not one of the above
expression types.  The <code>car</code> of the expression is the operator, and the
<code>cdr</code> is the list of operands:

<div class="lisp">
<pre class="lisp">(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
</pre></div>

</li></ul>

<a id="Derived-expressions"></a>
<h5 class="subsubheading">Derived expressions</h5>

<p>Some special forms in our language can be defined in terms of expressions
involving other special forms, rather than being implemented directly.  One
example is <code>cond</code>, which can be implemented as a nest of <code>if</code>
expressions.  For example, we can reduce the problem of evaluating the
expression
</p>
<div class="lisp">
<pre class="lisp">(cond ((&gt; x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
</pre></div>

<p>to the problem of evaluating the following expression involving <code>if</code> and
<code>begin</code> expressions:
</p>
<div class="lisp">
<pre class="lisp">(if (&gt; x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
</pre></div>

<p>Implementing the evaluation of <code>cond</code> in this way simplifies the evaluator
because it reduces the number of special forms for which the evaluation process
must be explicitly specified.
</p>
<p>We include syntax procedures that extract the parts of a <code>cond</code>
expression, and a procedure <code>cond-&gt;if</code> that transforms <code>cond</code>
expressions into <code>if</code> expressions.  A case analysis begins with
<code>cond</code> and has a list of predicate-action clauses.  A clause is an
<code>else</code> clause if its predicate is the symbol <code>else</code>.<a class="footnote_link" id="DOCF216" href="#FOOT216"><sup>216</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (cond? exp) 
  (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) 
  (car clause))
(define (cond-actions clause) 
  (cdr clause))
(define (cond-&gt;if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false     <span class="roman">; no <code>else</code> clause</span>
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence-&gt;exp 
                 (cond-actions first))
                (error &quot;ELSE clause isn't 
                        last: COND-&gt;IF&quot;
                       clauses))
            (make-if (cond-predicate first)
                     (sequence-&gt;exp 
                      (cond-actions first))
                     (expand-clauses 
                      rest))))))
</pre></div>

<p>Expressions (such as <code>cond</code>) that we choose to implement as syntactic
transformations are called <a id="index-derived-expressions"></a>
<em>derived expressions</em>.  <code>Let</code>
expressions are also derived expressions (see 
<a href="#Exercise-4_002e6">Exercise 4.6</a>).<a class="footnote_link" id="DOCF217" href="#FOOT217"><sup>217</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e2"></a>Exercise 4.2:</strong> Louis Reasoner plans to reorder the
<code>cond</code> clauses in <code>eval</code> so that the clause for procedure
applications appears before the clause for assignments.  He argues that this
will make the interpreter more efficient: Since programs usually contain more
applications than assignments, definitions, and so on, his modified <code>eval</code>
will usually check fewer clauses than the original <code>eval</code> before
identifying the type of an expression.
</p>
<ol>
<li> What is wrong with Louis’s plan?  (Hint: What will Louis’s evaluator do with
the expression <code>(define x 3)</code>?)

</li><li> Louis is upset that his plan didn’t work.  He is willing to go to any lengths
to make his evaluator recognize procedure applications before it checks for
most other kinds of expressions.  Help him by changing the syntax of the
evaluated language so that procedure applications start with <code>call</code>.  For
example, instead of <code>(factorial 3)</code> we will now have to write <code>(call
factorial 3)</code> and instead of <code>(+ 1 2)</code> we will have to write <code>(call +
1 2)</code>.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e3"></a>Exercise 4.3:</strong> Rewrite <code>eval</code> so that the
dispatch is done in data-directed style.  Compare this with the data-directed
differentiation procedure of <a href="2_002e4_002e3.xhtml#Exercise-2_002e73">Exercise 2.73</a>.  (You may use the <code>car</code>
of a compound expression as the type of the expression, as is appropriate for
the syntax implemented in this section.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e4"></a>Exercise 4.4:</strong> Recall the definitions of the
special forms <code>and</code> and <code>or</code> from <a href="Chapter-1.xhtml#Chapter-1">Chapter 1</a>:
</p>
<ul>
<li> <code>and</code>: The expressions are evaluated from left to right.  If any
expression evaluates to false, false is returned; any remaining expressions are
not evaluated.  If all the expressions evaluate to true values, the value of
the last expression is returned.  If there are no expressions then true is
returned.

</li><li> <code>or</code>: The expressions are evaluated from left to right.  If any expression
evaluates to a true value, that value is returned; any remaining expressions
are not evaluated.  If all expressions evaluate to false, or if there are no
expressions, then false is returned.

</li></ul>

<p>Install <code>and</code> and <code>or</code> as new special forms for the evaluator by
defining appropriate syntax procedures and evaluation procedures
<code>eval-and</code> and <code>eval-or</code>.  Alternatively, show how to implement
<code>and</code> and <code>or</code> as derived expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e5"></a>Exercise 4.5:</strong> Scheme allows an additional syntax
for <code>cond</code> clauses, <code>(⟨<var>test</var>⟩ =&gt; ⟨<var>recipient</var>⟩)</code>.  If
<code>⟨</code><var>test</var><code>⟩</code> evaluates to a true value, then <code>⟨</code><var>recipient</var><code>⟩</code> is evaluated.
Its value must be a procedure of one argument; this procedure is then invoked
on the value of the <code>⟨</code><var>test</var><code>⟩</code>, and the result is returned as the value of
the <code>cond</code> expression.  For example
</p>
<div class="lisp">
<pre class="lisp">(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
      (else false))
</pre></div>

<p>returns 2.  Modify the handling of <code>cond</code> so that it supports this
extended syntax.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e6"></a>Exercise 4.6:</strong> <code>Let</code> expressions are derived
expressions, because
</p>
<div class="lisp">
<pre class="lisp">(let ((⟨<var>var₁</var>⟩ ⟨<var>exp₁</var>⟩) <span class="roman">…</span> (⟨<var>varₙ</var>⟩ ⟨<var>expₙ</var>⟩))
  ⟨<var>body</var>⟩)
</pre></div>

<p>is equivalent to
</p>
<div class="lisp">
<pre class="lisp">((lambda (⟨<var>var₁</var>⟩ <span class="roman">…</span> ⟨<var>varₙ</var>⟩)
   ⟨<var>body</var>⟩)
 ⟨<var>exp₁</var>⟩
 <span class="roman">…</span>
 ⟨<var>expₙ</var>⟩)
</pre></div>

<p>Implement a syntactic transformation <code>let-&gt;combination</code> that reduces
evaluating <code>let</code> expressions to evaluating combinations of the type shown
above, and add the appropriate clause to <code>eval</code> to handle <code>let</code>
expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e7"></a>Exercise 4.7:</strong> <code>Let*</code> is similar to
<code>let</code>, except that the bindings of the <code>let*</code> variables are performed
sequentially from left to right, and each binding is made in an environment in
which all of the preceding bindings are visible.  For example
</p>
<div class="lisp">
<pre class="lisp">(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))
</pre></div>

<p>returns 39.  Explain how a <code>let*</code> expression can be rewritten as a set of
nested <code>let</code> expressions, and write a procedure <code>let*-&gt;nested-lets</code>
that performs this transformation.  If we have already implemented <code>let</code>
(<a href="#Exercise-4_002e6">Exercise 4.6</a>) and we want to extend the evaluator to handle <code>let*</code>,
is it sufficient to add a clause to <code>eval</code> whose action is
</p>
<div class="lisp">
<pre class="lisp">(eval (let*-&gt;nested-lets exp) env)
</pre></div>

<p>or must we explicitly expand <code>let*</code> in terms of non-derived expressions?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e8"></a>Exercise 4.8:</strong> “Named <code>let</code>” is a variant
of <code>let</code> that has the form 
</p>
<div class="lisp">
<pre class="lisp">(let ⟨<var>var</var>⟩ ⟨<var>bindings</var>⟩ ⟨<var>body</var>⟩)
</pre></div>

<p>The <code>⟨</code><var>bindings</var><code>⟩</code> and <code>⟨</code><var>body</var><code>⟩</code> are just as in ordinary <code>let</code>,
except that <code>⟨</code><var>var</var><code>⟩</code> is bound within <code>⟨</code><var>body</var><code>⟩</code> to a procedure whose body
is <code>⟨</code><var>body</var><code>⟩</code> and whose parameters are the variables in the <code>⟨</code><var>bindings</var><code>⟩</code>.
Thus, one can repeatedly execute the <code>⟨</code><var>body</var><code>⟩</code> by invoking the procedure
named <code>⟨</code><var>var</var><code>⟩</code>.  For example, the iterative Fibonacci procedure 
(<a href="1_002e2_002e2.xhtml#g_t1_002e2_002e2">1.2.2</a>) can be rewritten using named <code>let</code> as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (fib n)
  (let fib-iter ((a 1) (b 0) (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) 
                  a 
                  (- count 1)))))
</pre></div>

<p>Modify <code>let-&gt;combination</code> of <a href="#Exercise-4_002e6">Exercise 4.6</a> to also support named
<code>let</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e9"></a>Exercise 4.9:</strong> Many languages support a variety of
iteration constructs, such as <code>do</code>, <code>for</code>, <code>while</code>, and
<code>until</code>.  In Scheme, iterative processes can be expressed in terms of
ordinary procedure calls, so special iteration constructs provide no essential
gain in computational power.  On the other hand, such constructs are often
convenient.  Design some iteration constructs, give examples of their use, and
show how to implement them as derived expressions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e10"></a>Exercise 4.10:</strong> By using data abstraction, we
were able to write an <code>eval</code> procedure that is independent of the
particular syntax of the language to be evaluated.  To illustrate this, design
and implement a new syntax for Scheme by modifying the procedures in this
section, without changing <code>eval</code> or <code>apply</code>.
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT213"><p><a class="footnote_backlink" href="#DOCF213"><sup>213</sup></a>
As
mentioned in <a href="2_002e3_002e1.xhtml#g_t2_002e3_002e1">2.3.1</a>, the evaluator sees a quoted expression as a
list beginning with <code>quote</code>, even if the expression is typed with the
quotation mark.  For example, the expression <code>'a</code> would be seen by the
evaluator as <code>(quote a)</code>.  See <a href="2_002e3_002e1.xhtml#Exercise-2_002e55">Exercise 2.55</a>.</p>
</div>
<div id="FOOT214"><p><a class="footnote_backlink" href="#DOCF214"><sup>214</sup></a>
The value of an <code>if</code> expression
when the predicate is false and there is no alternative is unspecified in
Scheme; we have chosen here to make it false.  We will support the use of the
variables <code>true</code> and <code>false</code> in expressions to be evaluated by
binding them in the global environment.  See <a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4">4.1.4</a>.</p>
</div>
<div id="FOOT215"><p><a class="footnote_backlink" href="#DOCF215"><sup>215</sup></a>
These selectors for a list of expressions—and the
corresponding ones for a list of operands—are not intended as a data
abstraction.  They are introduced as mnemonic names for the basic list
operations in order to make it easier to understand the explicit-control
evaluator in <a href="5_002e4.xhtml#g_t5_002e4">5.4</a>.</p>
</div>
<div id="FOOT216"><p><a class="footnote_backlink" href="#DOCF216"><sup>216</sup></a>
The
value of a <code>cond</code> expression when all the predicates are false and there
is no <code>else</code> clause is unspecified in Scheme; we have chosen here to make
it false.</p>
</div>
<div id="FOOT217"><p><a class="footnote_backlink" href="#DOCF217"><sup>217</sup></a>
Practical Lisp systems provide a mechanism that allows a user
to add new derived expressions and specify their implementation as syntactic
transformations without modifying the evaluator.  Such a user-defined
transformation is called a <a id="index-macro"></a>
<em>macro</em>.  Although it is easy to add an
elementary mechanism for defining macros, the resulting language has subtle
name-conflict problems.  There has been much research on mechanisms for macro
definition that do not cause these difficulties.  See, for example, <a href="References.xhtml#Kohlbecker-1986">Kohlbecker 1986</a>, 
<a href="References.xhtml#Clinger-and-Rees-1991">Clinger and Rees 1991</a>, and <a href="References.xhtml#Hanson-1991">Hanson 1991</a>.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3" accesskey="n" rel="next">4.1.3</a>, Previous: <a href="4_002e1_002e1.xhtml#g_t4_002e1_002e1" accesskey="p" rel="prev">4.1.1</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
