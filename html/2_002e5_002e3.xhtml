<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.5.3</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.5.3"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.5.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="2_002e5.xhtml#g_t2_002e5" rel="prev" title="2.5"/>
<link href="Chapter-3.xhtml#Chapter-3" rel="next" title="Chapter 3"/>
<link href="2_002e5_002e2.xhtml#g_t2_002e5_002e2" rel="prev" title="2.5.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t2_002e5_002e3"></a>
<nav class="header">
<p>
Next: <a href="Chapter-3.xhtml#Chapter-3" accesskey="n" rel="next">Chapter 3</a>, Previous: <a href="2_002e5_002e2.xhtml#g_t2_002e5_002e2" accesskey="p" rel="prev">2.5.2</a>, Up: <a href="2_002e5.xhtml#g_t2_002e5" accesskey="u" rel="prev">2.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Example_003a-Symbolic-Algebra"></a>
<h4 class="subsection"><span class="secnum">2.5.3</span><span class="sectitle">Example: Symbolic Algebra</span></h4>

<p>The manipulation of symbolic algebraic expressions is a complex process that
illustrates many of the hardest problems that occur in the design of
large-scale systems.  An algebraic expression, in general, can be viewed as a
hierarchical structure, a tree of operators applied to operands.  We can
construct algebraic expressions by starting with a set of primitive objects,
such as constants and variables, and combining these by means of algebraic
operators, such as addition and multiplication.  As in other languages, we form
abstractions that enable us to refer to compound objects in simple terms.
Typical abstractions in symbolic algebra are ideas such as linear combination,
polynomial, rational function, or trigonometric function.  We can regard these
as compound “types,” which are often useful for directing the processing of
expressions.  For example, we could describe the expression
\[ % :49:
  {x^2 \sin (y^2 + 1)} + {x \cos 2y} + {\cos(y^3 - 2y^2)}  \]
as a polynomial in \( x \) with coefficients that are trigonometric functions of
polynomials in \( y \) whose coefficients are integers.
</p>
<p>We will not attempt to develop a complete algebraic-manipulation system here.
Such systems are exceedingly complex programs, embodying deep algebraic
knowledge and elegant algorithms.  What we will do is look at a simple but
important part of algebraic manipulation: the arithmetic of polynomials.  We
will illustrate the kinds of decisions the designer of such a system faces, and
how to apply the ideas of abstract data and generic operations to help organize
this effort.
</p>
<a id="Arithmetic-on-polynomials"></a>
<h5 class="subsubheading">Arithmetic on polynomials</h5>

<p>Our first task in designing a system for performing arithmetic on polynomials
is to decide just what a polynomial is.  Polynomials are normally defined
relative to certain variables (the <a id="index-indeterminates"></a>
<em>indeterminates</em> of the polynomial).
For simplicity, we will restrict ourselves to polynomials having just one
indeterminate (<a id="index-univariate-polynomials"></a>
<em>univariate polynomials</em>).<a class="footnote_link" id="DOCF120" href="#FOOT120"><sup>120</sup></a> We will define a polynomial to be a sum of terms, each of
which is either a coefficient, a power of the indeterminate, or a product of a
coefficient and a power of the indeterminate.  A coefficient is defined as an
algebraic expression that is not dependent upon the indeterminate of the
polynomial.  For example,
\[ % :50:
  {5x^2} + {3x} + 7  \]
is a simple polynomial in \( x \), and
\[ % :51:
  {(y^2 + 1)x^3} + {(2y)x + 1}  \]
is a polynomial in \( x \) whose coefficients are polynomials in \( y \).
</p>
<p>Already we are skirting some thorny issues.  Is the first of these polynomials
the same as the polynomial \( {5y^2 + 3y + 7} \), or not?  A reasonable answer
might be “yes, if we are considering a polynomial purely as a mathematical
function, but no, if we are considering a polynomial to be a syntactic form.”
The second polynomial is algebraically equivalent to a polynomial in \( y \)
whose coefficients are polynomials in \( x \).  Should our system recognize this,
or not?  Furthermore, there are other ways to represent a polynomial—for
example, as a product of factors, or (for a univariate polynomial) as the set
of roots, or as a listing of the values of the polynomial at a specified set of
points.<a class="footnote_link" id="DOCF121" href="#FOOT121"><sup>121</sup></a>  We can finesse these questions by
deciding that in our algebraic-manipulation system a “polynomial” will be a
particular syntactic form, not its underlying mathematical meaning.
</p>
<p>Now we must consider how to go about doing arithmetic on polynomials.  In this
simple system, we will consider only addition and multiplication.  Moreover, we
will insist that two polynomials to be combined must have the same
indeterminate.
</p>
<p>We will approach the design of our system by following the familiar discipline
of data abstraction.  We will represent polynomials using a data structure
called a <a id="index-poly"></a>
<em>poly</em>, which consists of a variable and a collection of
terms.  We assume that we have selectors <code>variable</code> and <code>term-list</code>
that extract those parts from a poly and a constructor <code>make-poly</code> that
assembles a poly from a given variable and a term list.  A variable will be
just a symbol, so we can use the <code>same-variable?</code>  procedure of 
<a href="2_002e3_002e2.xhtml#g_t2_002e3_002e2">2.3.2</a> to compare variables.  The following procedures define addition and
multiplication of polys:
</p>
<div class="lisp">
<pre class="lisp">(define (add-poly p1 p2)
  (if (same-variable? (variable p1) 
                      (variable p2))
      (make-poly 
       (variable p1)
       (add-terms (term-list p1)
                  (term-list p2)))
      (error &quot;Polys not in same var: 
              ADD-POLY&quot;
             (list p1 p2))))

(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) 
                      (variable p2))
      (make-poly 
       (variable p1)
       (mul-terms (term-list p1)
                  (term-list p2)))
      (error &quot;Polys not in same var: 
              MUL-POLY&quot;
             (list p1 p2))))
</pre></div>

<p>To incorporate polynomials into our generic arithmetic system, we need to
supply them with type tags.  We’ll use the tag <code>polynomial</code>, and install
appropriate operations on tagged polynomials in the operation table.  We’ll
embed all our code in an installation procedure for the polynomial package,
similar to the ones in <a href="2_002e5_002e1.xhtml#g_t2_002e5_002e1">2.5.1</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (install-polynomial-package)
  <span class="roman">;; internal procedures</span>
  <span class="roman">;; representation of poly</span>
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ⟨<em>procedures <code>same-variable?</code> 
   and <code>variable?</code> from section 2.3.2</em>⟩

  <span class="roman">;; representation of terms and term lists</span>
  ⟨<em>procedures <code>adjoin-term</code> <span class="roman">…</span> <code>coeff</code> 
  from text below</em>⟩

  (define (add-poly p1 p2) <span class="roman">…</span>)
  ⟨<em>procedures used by <code>add-poly</code></em>⟩
  (define (mul-poly p1 p2) <span class="roman">…</span>)
  ⟨<em>procedures used by <code>mul-poly</code></em>⟩

  <span class="roman">;; interface to rest of the system</span>
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) 
         (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) 
         (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) 
         (tag (make-poly var terms))))
  'done)
</pre></div>

<p>Polynomial addition is performed termwise.  Terms of the same order (i.e., with
the same power of the indeterminate) must be combined.  This is done by forming
a new term of the same order whose coefficient is the sum of the coefficients
of the addends.  Terms in one addend for which there are no terms of the same
order in the other addend are simply accumulated into the sum polynomial being
constructed.
</p>
<p>In order to manipulate term lists, we will assume that we have a constructor
<code>the-empty-termlist</code> that returns an empty term list and a constructor
<code>adjoin-term</code> that adjoins a new term to a term list.  We will also assume
that we have a predicate <code>empty-termlist?</code> that tells if a given term list
is empty, a selector <code>first-term</code> that extracts the highest-order term
from a term list, and a selector <code>rest-terms</code> that returns all but the
highest-order term.  To manipulate terms, we will suppose that we have a
constructor <code>make-term</code> that constructs a term with given order and
coefficient, and selectors <code>order</code> and <code>coeff</code> that return,
respectively, the order and the coefficient of the term.  These operations
allow us to consider both terms and term lists as data abstractions, whose
concrete representations we can worry about separately.
</p>
<p>Here is the procedure that constructs the term list for the sum of two
polynomials:<a class="footnote_link" id="DOCF122" href="#FOOT122"><sup>122</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) 
               (t2 (first-term L2)))
           (cond ((&gt; (order t1) (order t2))
                  (adjoin-term
                   t1 
                   (add-terms (rest-terms L1) 
                              L2)))
                 ((&lt; (order t1) (order t2))
                  (adjoin-term
                   t2 
                   (add-terms 
                    L1 
                    (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term 
                    (order t1)
                    (add (coeff t1) 
                         (coeff t2)))
                   (add-terms 
                    (rest-terms L1)
                    (rest-terms L2)))))))))
</pre></div>

<p>The most important point to note here is that we used the generic addition
procedure <code>add</code> to add together the coefficients of the terms being
combined.  This has powerful consequences, as we will see below.
</p>
<p>In order to multiply two term lists, we multiply each term of the first list by
all the terms of the other list, repeatedly using <code>mul-term-by-all-terms</code>,
which multiplies a given term by all terms in a given term list.  The resulting
term lists (one for each term of the first list) are accumulated into a sum.
Multiplying two terms forms a term whose order is the sum of the orders of the
factors and whose coefficient is the product of the coefficients of the
factors:
</p>
<div class="lisp">
<pre class="lisp">(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms 
       (mul-term-by-all-terms 
        (first-term L1) L2)
       (mul-terms (rest-terms L1) L2))))

(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term 
          (+ (order t1) (order t2))
          (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms 
          t1 
          (rest-terms L))))))
</pre></div>

<p>This is really all there is to polynomial addition and multiplication.  Notice
that, since we operate on terms using the generic procedures <code>add</code> and
<code>mul</code>, our polynomial package is automatically able to handle any type of
coefficient that is known about by the generic arithmetic package.  If we
include a coercion mechanism such as one of those discussed in 
<a href="2_002e5_002e2.xhtml#g_t2_002e5_002e2">2.5.2</a>, then we also are automatically able to handle operations on
polynomials of different coefficient types, such as
\[ % :52:
  {[3x^2 + (2 + 3i)x + 7] \cdot} {\left[ x^4 + {2\over3} x^2 + (5 + 3i) \right].}  \]
Because we installed the polynomial addition and multiplication procedures
<code>add-poly</code> and <code>mul-poly</code> in the generic arithmetic system as the
<code>add</code> and <code>mul</code> operations for type <code>polynomial</code>, our system is
also automatically able to handle polynomial operations such as
\[ % :53:
  {\Big[(y + 1)x^2} + {(y^2 + 1)x} + {(y - 1)\Big] \cdot} {\Big[(y - 2)x} + {(y^3 + 7)\Big].}  \]
The reason is that when the system tries to combine coefficients, it will
dispatch through <code>add</code> and <code>mul</code>.  Since the coefficients are
themselves polynomials (in \( y \)), these will be combined using <code>add-poly</code>
and <code>mul-poly</code>.  The result is a kind of “data-directed recursion” in
which, for example, a call to <code>mul-poly</code> will result in recursive calls to
<code>mul-poly</code> in order to multiply the coefficients.  If the coefficients of
the coefficients were themselves polynomials (as might be used to represent
polynomials in three variables), the data direction would ensure that the
system would follow through another level of recursive calls, and so on through
as many levels as the structure of the data dictates.<a class="footnote_link" id="DOCF123" href="#FOOT123"><sup>123</sup></a>
</p>
<a id="Representing-term-lists"></a>
<h5 class="subsubheading">Representing term lists</h5>

<p>Finally, we must confront the job of implementing a good representation for
term lists.  A term list is, in effect, a set of coefficients keyed by the
order of the term.  Hence, any of the methods for representing sets, as
discussed in <a href="2_002e3_002e3.xhtml#g_t2_002e3_002e3">2.3.3</a>, can be applied to this task.  On the other
hand, our procedures <code>add-terms</code> and <code>mul-terms</code> always access term
lists sequentially from highest to lowest order.  Thus, we will use some kind
of ordered list representation.
</p>
<p>How should we structure the list that represents a term list?  One
consideration is the “density” of the polynomials we intend to manipulate.  A
polynomial is said to be <a id="index-dense"></a>
<em>dense</em> if it has nonzero coefficients in
terms of most orders.  If it has many zero terms it is said to be
<a id="index-sparse"></a>
<em>sparse</em>.  For example,
\[ % :55:
  A: \quad {x^5} + {2x^4} + {3x^2} - {2x} - 5  \]
is a dense polynomial, whereas
\[ % :56:
  B: \quad x^{100} + {2x^2} + 1  \]
is sparse.
</p>
<p>The term lists of dense polynomials are most efficiently represented as lists
of the coefficients.  For example, \( A \) above would be nicely represented as
<code>(1 2 0 3 -2 -5)</code>.  The order of a term in this representation is the
length of the sublist beginning with that term’s coefficient, decremented by
1.<a class="footnote_link" id="DOCF124" href="#FOOT124"><sup>124</sup></a>  This would be a terrible representation for
a sparse polynomial such as \( B \): There would be a giant list of zeros
punctuated by a few lonely nonzero terms.  A more reasonable representation of
the term list of a sparse polynomial is as a list of the nonzero terms, where
each term is a list containing the order of the term and the coefficient for
that order.  In such a scheme, polynomial \( B \) is efficiently represented as
<code>((100 1) (2 2) (0 1))</code>.  As most polynomial manipulations are performed
on sparse polynomials, we will use this method.  We will assume that term lists
are represented as lists of terms, arranged from highest-order to lowest-order
term.  Once we have made this decision, implementing the selectors and
constructors for terms and term lists is straightforward:<a class="footnote_link" id="DOCF125" href="#FOOT125"><sup>125</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))
(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) 
  (null? term-list))
(define (make-term order coeff) 
  (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
</pre></div>

<p>where <code>=zero?</code> is as defined in <a href="2_002e5_002e1.xhtml#Exercise-2_002e80">Exercise 2.80</a>.  (See also
<a href="#Exercise-2_002e87">Exercise 2.87</a> below.)
</p>
<p>Users of the polynomial package will create (tagged) polynomials by means of
the procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-2_002e87"></a>Exercise 2.87:</strong> Install <code>=zero?</code> for
polynomials in the generic arithmetic package.  This will allow
<code>adjoin-term</code> to work for polynomials with coefficients that are
themselves polynomials.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e88"></a>Exercise 2.88:</strong> Extend the polynomial system to
include subtraction of polynomials.  (Hint: You may find it helpful to define a
generic negation operation.)
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e89"></a>Exercise 2.89:</strong> Define procedures that implement
the term-list representation described above as appropriate for dense
polynomials.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e90"></a>Exercise 2.90:</strong> Suppose we want to have a
polynomial system that is efficient for both sparse and dense polynomials.  One
way to do this is to allow both kinds of term-list representations in our
system.  The situation is analogous to the complex-number example of 
<a href="2_002e4.xhtml#g_t2_002e4">2.4</a>, where we allowed both rectangular and polar representations.  To do
this we must distinguish different types of term lists and make the operations
on term lists generic.  Redesign the polynomial system to implement this
generalization.  This is a major effort, not a local change.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e91"></a>Exercise 2.91:</strong> A univariate polynomial can be
divided by another one to produce a polynomial quotient and a polynomial
remainder.  For example,
\[ % :57:
  {x^5 - 1 \over x^2 - 1} \,=\, {x^3 + x,} \text{  remainder  } {x - 1.}  \]
Division can be performed via long division.  That is, divide the highest-order
term of the dividend by the highest-order term of the divisor.  The result is
the first term of the quotient.  Next, multiply the result by the divisor,
subtract that from the dividend, and produce the rest of the answer by
recursively dividing the difference by the divisor.  Stop when the order of the
divisor exceeds the order of the dividend and declare the dividend to be the
remainder.  Also, if the dividend ever becomes zero, return zero as both
quotient and remainder.
</p>
<p>We can design a <code>div-poly</code> procedure on the model of <code>add-poly</code> and
<code>mul-poly</code>. The procedure checks to see if the two polys have the same
variable.  If so, <code>div-poly</code> strips off the variable and passes the
problem to <code>div-terms</code>, which performs the division operation on term
lists. <code>Div-poly</code> finally reattaches the variable to the result supplied
by <code>div-terms</code>.  It is convenient to design <code>div-terms</code> to compute
both the quotient and the remainder of a division.  <code>Div-terms</code> can take
two term lists as arguments and return a list of the quotient term list and the
remainder term list.
</p>
<p>Complete the following definition of <code>div-terms</code> by filling in the missing
expressions.  Use this to implement <code>div-poly</code>, which takes two polys as
arguments and returns a list of the quotient and remainder polys.
</p>
<div class="lisp">
<pre class="lisp">(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) 
            (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (&gt; (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) 
                              (coeff t2)))
                  (new-o (- (order t1) 
                            (order t2))))
              (let ((rest-of-result
                     ⟨<var>compute rest of result 
                     recursively</var>⟩ ))
                ⟨<var>form complete result</var>⟩ ))))))
</pre></div>
</blockquote>

<a id="Hierarchies-of-types-in-symbolic-algebra"></a>
<h5 class="subsubheading">Hierarchies of types in symbolic algebra</h5>

<p>Our polynomial system illustrates how objects of one type (polynomials) may in
fact be complex objects that have objects of many different types as parts.
This poses no real difficulty in defining generic operations.  We need only
install appropriate generic operations for performing the necessary
manipulations of the parts of the compound types.  In fact, we saw that
polynomials form a kind of “recursive data abstraction,” in that parts of a
polynomial may themselves be polynomials.  Our generic operations and our
data-directed programming style can handle this complication without much
trouble.
</p>
<p>On the other hand, polynomial algebra is a system for which the data types
cannot be naturally arranged in a tower.  For instance, it is possible to have
polynomials in \( x \) whose coefficients are polynomials in \( y \).  It is also
possible to have polynomials in \( y \) whose coefficients are polynomials in
\( x \).  Neither of these types is “above” the other in any natural way, yet
it is often necessary to add together elements from each set.  There are
several ways to do this.  One possibility is to convert one polynomial to the
type of the other by expanding and rearranging terms so that both polynomials
have the same principal variable.  One can impose a towerlike structure on this
by ordering the variables and thus always converting any polynomial to a
“canonical form” with the highest-priority variable dominant and the
lower-priority variables buried in the coefficients.  This strategy works
fairly well, except that the conversion may expand a polynomial unnecessarily,
making it hard to read and perhaps less efficient to work with.  The tower
strategy is certainly not natural for this domain or for any domain where the
user can invent new types dynamically using old types in various combining
forms, such as trigonometric functions, power series, and integrals.
</p>
<p>It should not be surprising that controlling coercion is a serious problem in
the design of large-scale algebraic-manipulation systems.  Much of the
complexity of such systems is concerned with relationships among diverse types.
Indeed, it is fair to say that we do not yet completely understand coercion.
In fact, we do not yet completely understand the concept of a data type.
Nevertheless, what we know provides us with powerful structuring and modularity
principles to support the design of large systems.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e92"></a>Exercise 2.92:</strong> By imposing an ordering on
variables, extend the polynomial package so that addition and multiplication of
polynomials works for polynomials in different variables.  (This is not easy!)
</p></blockquote>

<a id="Extended-exercise_003a-Rational-functions"></a>
<h5 class="subsubheading">Extended exercise: Rational functions</h5>

<p>We can extend our generic arithmetic system to include <a id="index-rational-functions"></a>
<em>rational functions</em>.  
These are “fractions” whose numerator and denominator are
polynomials, such as
\[ % :58:
  {{x + 1 \over x^3 - 1}.}  \]
The system should be able to add, subtract, multiply, and divide rational
functions, and to perform such computations as
\[ % :59:
  {x + 1 \over x^3 - 1} + {x \over x^2 - 1} \,=\, 
  {{x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}.}  \]
(Here the sum has been simplified by removing common factors.  Ordinary “cross
multiplication” would have produced a fourth-degree polynomial over a
fifth-degree polynomial.)
</p>
<p>If we modify our rational-arithmetic package so that it uses generic
operations, then it will do what we want, except for the problem of reducing
fractions to lowest terms.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e93"></a>Exercise 2.93:</strong> Modify the rational-arithmetic
package to use generic operations, but change <code>make-rat</code> so that it does
not attempt to reduce fractions to lowest terms.  Test your system by calling
<code>make-rational</code> on two polynomials to produce a rational function:
</p>
<div class="lisp">
<pre class="lisp">(define p1 (make-polynomial 'x '((2 1) (0 1))))
(define p2 (make-polynomial 'x '((3 1) (0 1))))
(define rf (make-rational p2 p1))
</pre></div>

<p>Now add <code>rf</code> to itself, using <code>add</code>. You will observe that this
addition procedure does not reduce fractions to lowest terms.
</p></blockquote>

<p>We can reduce polynomial fractions to lowest terms using the same idea we used
with integers: modifying <code>make-rat</code> to divide both the numerator and the
denominator by their greatest common divisor.  The notion of “greatest common
divisor” makes sense for polynomials.  In fact, we can compute the
<abbr>GCD</abbr> of two polynomials using essentially the same Euclid’s Algorithm
that works for integers.<a class="footnote_link" id="DOCF126" href="#FOOT126"><sup>126</sup></a>  The integer version is
</p>
<div class="lisp">
<pre class="lisp">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</pre></div>

<p>Using this, we could make the obvious modification to define a <abbr>GCD</abbr>
operation that works on term lists:
</p>
<div class="lisp">
<pre class="lisp">(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
</pre></div>

<p>where <code>remainder-terms</code> picks out the remainder component of the list
returned by the term-list division operation <code>div-terms</code> that was
implemented in <a href="#Exercise-2_002e91">Exercise 2.91</a>.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e94"></a>Exercise 2.94:</strong> Using <code>div-terms</code>, implement
the procedure <code>remainder-terms</code> and use this to define <code>gcd-terms</code> as
above.  Now write a procedure <code>gcd-poly</code> that computes the polynomial
<abbr>GCD</abbr> of two polys.  (The procedure should signal an error if the two
polys are not in the same variable.)  Install in the system a generic operation
<code>greatest-common-divisor</code> that reduces to <code>gcd-poly</code> for polynomials
and to ordinary <code>gcd</code> for ordinary numbers.  As a test, try
</p>
<div class="lisp">
<pre class="lisp">(define p1 
  (make-polynomial 
   'x '((4 1) (3 -1) (2 -2) (1 2))))

(define p2 
  (make-polynomial 
   'x '((3 1) (1 -1))))

(greatest-common-divisor p1 p2)
</pre></div>

<p>and check your result by hand.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e95"></a>Exercise 2.95:</strong> Define \( P_1 \), \( P_2 \), and
\( P_3 \) to be the polynomials
\[ % :60:
\begin{array}{rl}
  P_1:  &amp;   x^2 - 2x + 1, \\
  P_2:  &amp;   11x^2 + 7,    \\
  P_3:  &amp;   13x + 5.
\end{array}
\]
Now define \( Q_1 \) to be the product of \( P_1 \) and \( P_2 \), and \( Q_2 \) to be
the product of \( P_1 \) and \( P_3 \), and use <code>greatest-common-divisor</code>
(<a href="#Exercise-2_002e94">Exercise 2.94</a>) to compute the <abbr>GCD</abbr> of \( Q_1 \) and \( Q_2 \).
Note that the answer is not the same as \( P_1 \).  This example introduces
noninteger operations into the computation, causing difficulties with the
<abbr>GCD</abbr> algorithm.<a class="footnote_link" id="DOCF127" href="#FOOT127"><sup>127</sup></a>  To understand what is happening, try tracing
<code>gcd-terms</code> while computing the <abbr>GCD</abbr> or try performing the
division by hand.
</p></blockquote>

<p>We can solve the problem exhibited in <a href="#Exercise-2_002e95">Exercise 2.95</a> if we use the
following modification of the <abbr>GCD</abbr> algorithm (which really works only
in the case of polynomials with integer coefficients).  Before performing any
polynomial division in the <abbr>GCD</abbr> computation, we multiply the dividend
by an integer constant factor, chosen to guarantee that no fractions will arise
during the division process.  Our answer will thus differ from the actual
<abbr>GCD</abbr> by an integer constant factor, but this does not matter in the
case of reducing rational functions to lowest terms; the <abbr>GCD</abbr> will be
used to divide both the numerator and denominator, so the integer constant
factor will cancel out.
</p>
<p>More precisely, if \( P \) and \( Q \) are polynomials, let \( O_1 \) be the order of
\( P \) (i.e., the order of the largest term of \( P \)) and let \( O_2 \) be the
order of \( Q \).  Let \( c \) be the leading coefficient of \( Q \).  Then it can be
shown that, if we multiply \( P \) by the <a id="index-integerizing-factor"></a>
<em>integerizing<!-- /@w --> factor<!-- /@w --></em>
\( c^{1 + O_1 - O_2} \), the resulting polynomial can be divided by \( Q \) by
using the <code>div-terms</code> algorithm without introducing any fractions.  The
operation of multiplying the dividend by this constant and then dividing is
sometimes called the <a id="index-pseudodivision"></a>
<em>pseudodivision</em> of \( P \) by \( Q \).  The remainder
of the division is called the <a id="index-pseudoremainder"></a>
<em>pseudoremainder</em>.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e96"></a>Exercise 2.96:</strong>
</p><ol>
<li> Implement the procedure <code>pseudoremainder-terms</code>, which is just like
<code>remainder-terms</code> except that it multiplies the dividend by the
integerizing factor described above before calling <code>div-terms</code>.  Modify
<code>gcd-terms</code> to use <code>pseudoremainder-terms</code>, and verify that
<code>greatest-common-divisor</code> now produces an answer with integer coefficients
on the example in <a href="#Exercise-2_002e95">Exercise 2.95</a>.

</li><li> The <abbr>GCD</abbr> now has integer coefficients, but they are larger than those
of \( P_1 \).  Modify <code>gcd-terms</code> so that it removes common factors from the
coefficients of the answer by dividing all the coefficients by their (integer)
greatest common divisor.

</li></ol>
</blockquote>

<p>Thus, here is how to reduce a rational function to lowest terms:
</p>
<ul>
<li> Compute the <abbr>GCD</abbr> of the numerator and denominator, using the version
of <code>gcd-terms</code> from <a href="#Exercise-2_002e96">Exercise 2.96</a>.

</li><li> When you obtain the <abbr>GCD</abbr>, multiply both numerator and denominator by
the same integerizing factor before dividing through by the <abbr>GCD</abbr>, so
that division by the <abbr>GCD</abbr> will not introduce any noninteger
coefficients.  As the factor you can use the leading coefficient of the
<abbr>GCD</abbr> raised to the power \( {1 + O_1 - O_2} \), where \( O_2 \) is the
order of the <abbr>GCD</abbr> and \( O_1 \) is the maximum of the orders of the
numerator and denominator.  This will ensure that dividing the numerator and
denominator by the <abbr>GCD</abbr> will not introduce any fractions.

</li><li> The result of this operation will be a numerator and denominator with integer
coefficients.  The coefficients will normally be very large because of all of
the integerizing factors, so the last step is to remove the redundant factors
by computing the (integer) greatest common divisor of all the coefficients of
the numerator and the denominator and dividing through by this factor.

</li></ul>

<blockquote>
<p><strong><a id="Exercise-2_002e97"></a>Exercise 2.97:</strong>
</p><ol>
<li> Implement this algorithm as a procedure <code>reduce-terms</code> that takes two term
lists <code>n</code> and <code>d</code> as arguments and returns a list <code>nn</code>,
<code>dd</code>, which are <code>n</code> and <code>d</code> reduced to lowest terms via the
algorithm given above.  Also write a procedure <code>reduce-poly</code>, analogous to
<code>add-poly</code>, that checks to see if the two polys have the same variable.
If so, <code>reduce-poly</code> strips off the variable and passes the problem to
<code>reduce-terms</code>, then reattaches the variable to the two term lists
supplied by <code>reduce-terms</code>.

</li><li> Define a procedure analogous to <code>reduce-terms</code> that does what the original
<code>make-rat</code> did for integers:

<div class="lisp">
<pre class="lisp">(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
</pre></div>

<p>and define <code>reduce</code> as a generic operation that calls <code>apply-generic</code>
to dispatch to either <code>reduce-poly</code> (for <code>polynomial</code> arguments) or
<code>reduce-integers</code> (for <code>scheme-number</code> arguments).  You can now
easily make the rational-arithmetic package reduce fractions to lowest terms by
having <code>make-rat</code> call <code>reduce</code> before combining the given numerator
and denominator to form a rational number.  The system now handles rational
expressions in either integers or polynomials.  To test your program, try the
example at the beginning of this extended exercise:
</p>
<div class="lisp">
<pre class="lisp">(define p1 
  (make-polynomial 'x '((1 1) (0 1))))
(define p2 
  (make-polynomial 'x '((3 1) (0 -1))))
(define p3 
  (make-polynomial 'x '((1 1))))
(define p4 
  (make-polynomial 'x '((2 1) (0 -1))))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))
(add rf1 rf2)
</pre></div>

<p>See if you get the correct answer, correctly reduced to lowest terms.
</p></li></ol>
</blockquote>

<p>The <abbr>GCD</abbr> computation is at the heart of any system that does
operations on rational functions.  The algorithm used above, although
mathematically straightforward, is extremely slow.  The slowness is due partly
to the large number of division operations and partly to the enormous size of
the intermediate coefficients generated by the pseudodivisions.  One of the
active areas in the development of algebraic-manipulation systems is the design
of better algorithms for computing polynomial <abbr>GCD</abbr>s.<a class="footnote_link" id="DOCF128" href="#FOOT128"><sup>128</sup></a>
</p>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT120"><p><a class="footnote_backlink" href="#DOCF120"><sup>120</sup></a>
On the other hand,
we will allow polynomials whose coefficients are themselves polynomials in
other variables.  This will give us essentially the same representational power
as a full multivariate system, although it does lead to coercion problems, as
discussed below.</p>
</div>
<div id="FOOT121"><p><a class="footnote_backlink" href="#DOCF121"><sup>121</sup></a>
For univariate polynomials, giving the value of a polynomial
at a given set of points can be a particularly good representation.  This makes
polynomial arithmetic extremely simple.  To obtain, for example, the sum of two
polynomials represented in this way, we need only add the values of the
polynomials at corresponding points.  To transform back to a more familiar
representation, we can use the Lagrange interpolation formula, which shows how
to recover the coefficients of a polynomial of degree \( n \) given the values of
the polynomial at \( {n + 1} \) points.</p>
</div>
<div id="FOOT122"><p><a class="footnote_backlink" href="#DOCF122"><sup>122</sup></a>
This operation is very much like the ordered
<code>union-set</code> operation we developed in <a href="2_002e3_002e3.xhtml#Exercise-2_002e62">Exercise 2.62</a>.  In
fact, if we think of the terms of the polynomial as a set ordered according to
the power of the indeterminate, then the program that produces the term list
for a sum is almost identical to <code>union-set</code>.</p>
</div>
<div id="FOOT123"><p><a class="footnote_backlink" href="#DOCF123"><sup>123</sup></a>
To make this
work completely smoothly, we should also add to our generic arithmetic system
the ability to coerce a “number” to a polynomial by regarding it as a
polynomial of degree zero whose coefficient is the number.  This is necessary
if we are going to perform operations such as
\[ % :54:
  {[x^2 + (y + 1)x + 5]} + {[x^2 + 2x + 1],}  \]
which requires adding the coefficient \( {y + 1} \) to the coefficient 2.</p>
</div>
<div id="FOOT124"><p><a class="footnote_backlink" href="#DOCF124"><sup>124</sup></a>
In these polynomial examples, we assume that we have implemented
the generic arithmetic system using the type mechanism suggested in
<a href="2_002e5_002e1.xhtml#Exercise-2_002e78">Exercise 2.78</a>.  Thus, coefficients that are ordinary numbers will be
represented as the numbers themselves rather than as pairs whose <code>car</code> is
the symbol <code>scheme-number</code>.</p>
</div>
<div id="FOOT125"><p><a class="footnote_backlink" href="#DOCF125"><sup>125</sup></a>
Although we
are assuming that term lists are ordered, we have implemented
<code>adjoin-term</code> to simply <code>cons</code> the new term onto the existing term
list.  We can get away with this so long as we guarantee that the procedures
(such as <code>add-terms</code>) that use <code>adjoin-term</code> always call it with a
higher-order term than appears in the list.  If we did not want to make such a
guarantee, we could have implemented <code>adjoin-term</code> to be similar to the
<code>adjoin-set</code> constructor for the ordered-list representation of sets
(<a href="2_002e3_002e3.xhtml#Exercise-2_002e61">Exercise 2.61</a>).</p>
</div>
<div id="FOOT126"><p><a class="footnote_backlink" href="#DOCF126"><sup>126</sup></a>
The fact that Euclid’s Algorithm works for
polynomials is formalized in algebra by saying that polynomials form a kind of
algebraic domain called a <a id="index-Euclidean-ring"></a>
<em>Euclidean ring</em>.  A Euclidean ring is a
domain that admits addition, subtraction, and commutative multiplication,
together with a way of assigning to each element \( x \) of the ring a positive
integer “measure” \( {m(x)} \) with the properties that 
\( {m(xy) \ge m(x)} \) for any nonzero \( x \) and \( y \) and that, given any \( x \) and
\( y \), there exists a \( q \) such that \( {y = qx + r} \) and either
\( {r = 0} \) or \( {m(r) &lt; m(x)} \).  From an abstract point of view, this
is what is needed to prove that Euclid’s Algorithm works.  For the domain of
integers, the measure \( m \) of an integer is the absolute value of the integer
itself.  For the domain of polynomials, the measure of a polynomial is its
degree.</p>
</div>
<div id="FOOT127"><p><a class="footnote_backlink" href="#DOCF127"><sup>127</sup></a>
In an implementation like <abbr>MIT</abbr>
Scheme, this produces a polynomial that is indeed a divisor of \( Q_1 \) and
\( Q_2 \), but with rational coefficients.  In many other Scheme systems, in
which division of integers can produce limited-precision decimal numbers, we
may fail to get a valid divisor.</p>
</div>
<div id="FOOT128"><p><a class="footnote_backlink" href="#DOCF128"><sup>128</sup></a>
One
extremely efficient and elegant method for computing polynomial <abbr>GCD</abbr>s
was discovered by Richard <a href="References.xhtml#Zippel-_00281979_0029">Zippel (1979)</a>.  The method is a probabilistic
algorithm, as is the fast test for primality that we discussed in <a href="Chapter-1.xhtml#Chapter-1">Chapter 1</a>.  Zippel’s book (<a href="References.xhtml#Zippel-1993">Zippel 1993</a>) describes this method, together with other ways to
compute polynomial <abbr>GCD</abbr>s.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="Chapter-3.xhtml#Chapter-3" accesskey="n" rel="next">Chapter 3</a>, Previous: <a href="2_002e5_002e2.xhtml#g_t2_002e5_002e2" accesskey="p" rel="prev">2.5.2</a>, Up: <a href="2_002e5.xhtml#g_t2_002e5" accesskey="u" rel="prev">2.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
