<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 3.3.5</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 3.3.5"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 3.3.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="3_002e3.xhtml#g_t3_002e3" rel="prev" title="3.3"/>
<link href="3_002e4.xhtml#g_t3_002e4" rel="next" title="3.4"/>
<link href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" rel="prev" title="3.3.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e3_002e5"></a>
<nav class="header">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">3.4</a>, Previous: <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" accesskey="p" rel="prev">3.3.4</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Propagation-of-Constraints"></a>
<h4 class="subsection"><span class="secnum">3.3.5</span><span class="sectitle">Propagation of Constraints</span></h4>

<p>Computer programs are traditionally organized as one-directional computations,
which perform operations on prespecified arguments to produce desired outputs.
On the other hand, we often model systems in terms of relations among
quantities.  For example, a mathematical model of a mechanical structure might
include the information that the deflection \( d \) of a metal rod is related to
the force \( F \) on the rod, the length \( L \) of the rod, the cross-sectional
area \( A \), and the elastic modulus \( E \) via the equation
\[ % :61:
  {dAE} \,=\, {FL.}  \]
Such an equation is not one-directional.  Given any four of the quantities, we
can use it to compute the fifth.  Yet translating the equation into a
traditional computer language would force us to choose one of the quantities to
be computed in terms of the other four.  Thus, a procedure for computing the
area \( A \) could not be used to compute the deflection \( d \), even though the
computations of \( A \) and \( d \) arise from the same
equation.<a class="footnote_link" id="DOCF159" href="#FOOT159"><sup>159</sup></a>
</p>
<p>In this section, we sketch the design of a language that enables us to work in
terms of relations themselves.  The primitive elements of the language are
<a id="index-primitive-constraints"></a>
<em>primitive constraints</em>, which state that certain relations hold
between quantities.  For example, <code>(adder a b c)</code> specifies that the
quantities \( a \), \( b \), and \( c \) must be related by the equation 
\( {a + b = c} \), <code>(multiplier x y z)</code> expresses the constraint 
\( {xy = z} \), and <code>(constant 3.14 x)</code> says that the value of \( x \) must be 3.14.
</p>
<p>Our language provides a means of combining primitive constraints in order to
express more complex relations.  We combine constraints by constructing
<a id="index-constraint-networks"></a>
<em>constraint networks</em>, in which constraints are joined by
<a id="index-connectors"></a>
<em>connectors</em>.  A connector is an object that “holds” a value that may
participate in one or more constraints.  For example, we know that the
relationship between Fahrenheit and Celsius temperatures is
\[ % :62:
  {9C} \,=\, {5(F - 32).}  \]
Such a constraint can be thought of as a network consisting of primitive adder,
multiplier, and constant constraints (<a href="#Figure-3_002e28">Figure 3.28</a>).  In the figure, we
see on the left a multiplier box with three terminals, labeled \( m \)1, \( m \)2,
and \( p \).  These connect the multiplier to the rest of the network as follows:
The \( m \)1 terminal is linked to a connector \( C \), which will hold the Celsius
temperature.  The \( m \)2 terminal is linked to a connector \( w \), which is also
linked to a constant box that holds 9.  The \( p \) terminal, which the
multiplier box constrains to be the product of \( m \)1 and \( m \)2, is linked to
the \( p \) terminal of another multiplier box, whose \( m \)2 is connected to a
constant 5 and whose \( m \)1 is connected to one of the terms in a sum.
</p>
<figure class="float">
<a id="Figure-3_002e28"></a>
<object style="width: 58.11ex; height: 18.30ex;" data="fig/chap3/Fig3.28.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 3.28:</strong> The relation \( {9C = 5(F - 32)} \) expressed as a constraint network.</p>
</figcaption>
</figure>

<p>Computation by such a network proceeds as follows: When a connector is given a
value (by the user or by a constraint box to which it is linked), it awakens
all of its associated constraints (except for the constraint that just awakened
it) to inform them that it has a value.  Each awakened constraint box then
polls its connectors to see if there is enough information to determine a value
for a connector.  If so, the box sets that connector, which then awakens all of
its associated constraints, and so on.  For instance, in conversion between
Celsius and Fahrenheit, \( w \), \( x \), and \( y \) are immediately set by the
constant boxes to 9, 5, and 32, respectively.  The connectors awaken the
multipliers and the adder, which determine that there is not enough information
to proceed.  If the user (or some other part of the network) sets \( C \) to a
value (say 25), the leftmost multiplier will be awakened, and it will set \( u \)
to \( {25 \cdot 9 = 225} \).  Then \( u \) awakens the second multiplier, which sets \( v \) to
45, and \( v \) awakens the adder, which sets \( f \) to 77.
</p>
<a id="Using-the-constraint-system"></a>
<h5 class="subsubheading">Using the constraint system</h5>

<p>To use the constraint system to carry out the temperature computation outlined
above, we first create two connectors, <code>C</code> and <code>F</code>, by calling the
constructor <code>make-connector</code>, and link <code>C</code> and <code>F</code> in an
appropriate network:
</p>
<div class="lisp">
<pre class="lisp">(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
<i>ok</i>
</pre></div>

<p>The procedure that creates the network is defined as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
</pre></div>

<p>This procedure creates the internal connectors <code>u</code>, <code>v</code>, <code>w</code>,
<code>x</code>, and <code>y</code>, and links them as shown in <a href="#Figure-3_002e28">Figure 3.28</a> using the
primitive constraint constructors <code>adder</code>, <code>multiplier</code>, and
<code>constant</code>.  Just as with the digital-circuit simulator of 
<a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>, expressing these combinations of primitive elements in terms of
procedures automatically provides our language with a means of abstraction for
compound objects.
</p>
<p>To watch the network in action, we can place probes on the connectors <code>C</code>
and <code>F</code>, using a <code>probe</code> procedure similar to the one we used to
monitor wires in <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>.  Placing a probe on a connector will
cause a message to be printed whenever the connector is given a value:
</p>
<div class="lisp">
<pre class="lisp">(probe &quot;Celsius temp&quot; C)
(probe &quot;Fahrenheit temp&quot; F)
</pre></div>

<p>Next we set the value of <code>C</code> to 25.  (The third argument to
<code>set-value!</code> tells <code>C</code> that this directive comes from the
<code>user</code>.)
</p>
<div class="lisp">
<pre class="lisp">(set-value! C 25 'user)
<i>Probe: Celsius temp = 25</i>
<i>Probe: Fahrenheit temp = 77</i>
<i>done</i>
</pre></div>

<p>The probe on <code>C</code> awakens and reports the value.  <code>C</code> also propagates
its value through the network as described above.  This sets <code>F</code> to 77,
which is reported by the probe on <code>F</code>.
</p>
<p>Now we can try to set <code>F</code> to a new value, say 212:
</p>
<div class="lisp">
<pre class="lisp">(set-value! F 212 'user)
<i>Error! Contradiction (77 212)</i>
</pre></div>

<p>The connector complains that it has sensed a contradiction: Its value is 77,
and someone is trying to set it to 212.  If we really want to reuse the network
with new values, we can tell <code>C</code> to forget its old value:
</p>
<div class="lisp">
<pre class="lisp">(forget-value! C 'user)
<i>Probe: Celsius temp = ?</i>
<i>Probe: Fahrenheit temp = ?</i>
<i>done</i>
</pre></div>

<p><code>C</code> finds that the <code>user</code>, who set its value originally, is now
retracting that value, so <code>C</code> agrees to lose its value, as shown by the
probe, and informs the rest of the network of this fact.  This information
eventually propagates to <code>F</code>, which now finds that it has no reason for
continuing to believe that its own value is 77.  Thus, <code>F</code> also gives up
its value, as shown by the probe.
</p>
<p>Now that <code>F</code> has no value, we are free to set it to 212:
</p>
<div class="lisp">
<pre class="lisp">(set-value! F 212 'user)
<i>Probe: Fahrenheit temp = 212</i>
<i>Probe: Celsius temp = 100</i>
<i>done</i>
</pre></div>

<p>This new value, when propagated through the network, forces <code>C</code> to have a
value of 100, and this is registered by the probe on <code>C</code>.  Notice that the
very same network is being used to compute <code>C</code> given <code>F</code> and to
compute <code>F</code> given <code>C</code>.  This nondirectionality of computation is the
distinguishing feature of constraint-based systems.
</p>
<a id="Implementing-the-constraint-system"></a>
<h5 class="subsubheading">Implementing the constraint system</h5>

<p>The constraint system is implemented via procedural objects with local state,
in a manner very similar to the digital-circuit simulator of 
<a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>.  Although the primitive objects of the constraint system are
somewhat more complex, the overall system is simpler, since there is no concern
about agendas and logic delays.
</p>
<p>The basic operations on connectors are the following:
</p>
<ul>
<li> <code>(has-value? ⟨<var>connector</var>⟩)</code> tells whether the connector has a value.

</li><li> <code>(get-value ⟨<var>connector</var>⟩)</code> returns the connector’s current value.

</li><li> <code>(set-value! ⟨<var>connector</var>⟩ ⟨<var>new-value</var>⟩ ⟨<var>informant</var>⟩)</code>
indicates that the informant is requesting the connector to set its value to
the new value.

</li><li> <code>(forget-value! ⟨<var>connector</var>⟩ ⟨<var>retractor</var>⟩)</code> tells the connector
that the retractor is requesting it to forget its value.

</li><li> <code>(connect ⟨<var>connector</var>⟩ ⟨<var>new-constraint</var>⟩)</code> tells the connector
to participate in the new constraint.

</li></ul>

<p>The connectors communicate with the constraints by means of the procedures
<code>inform-about-value</code>, which tells the given constraint that the connector
has a value, and <code>inform-about-no-value</code>, which tells the constraint that
the connector has lost its value.
</p>
<p><code>Adder</code> constructs an adder constraint among summand connectors <code>a1</code>
and <code>a2</code> and a <code>sum</code> connector.  An adder is implemented as a
procedure with local state (the procedure <code>me</code> below):
</p>
<div class="lisp">
<pre class="lisp">(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) 
                (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) 
                          (get-value a2))
                       me))
          ((and (has-value? a1) 
                (has-value? sum))
           (set-value! a2
                       (- (get-value sum) 
                          (get-value a1))
                       me))
          ((and (has-value? a2) 
                (has-value? sum))
           (set-value! a1
                       (- (get-value sum) 
                          (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error &quot;Unknown request: 
                        ADDER&quot; request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
</pre></div>

<p><code>Adder</code> connects the new adder to the designated connectors and returns it
as its value.  The procedure <code>me</code>, which represents the adder, acts as a
dispatch to the local procedures.  The following “syntax interfaces” (see
<a href="3_002e3_002e4.xhtml#Footnote-155">Footnote 155</a> in <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4">3.3.4</a>) are used in conjunction with
the dispatch:
</p>
<div class="lisp">
<pre class="lisp">(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
</pre></div>

<p>The adder’s local procedure <code>process-new-value</code> is called when the adder
is informed that one of its connectors has a value. The adder first checks to
see if both <code>a1</code> and <code>a2</code> have values. If so, it tells <code>sum</code> to
set its value to the sum of the two addends.  The <code>informant</code> argument to
<code>set-value!</code> is <code>me</code>, which is the adder object itself.  If <code>a1</code>
and <code>a2</code> do not both have values, then the adder checks to see if perhaps
<code>a1</code> and <code>sum</code> have values.  If so, it sets <code>a2</code> to the
difference of these two.  Finally, if <code>a2</code> and <code>sum</code> have values,
this gives the adder enough information to set <code>a1</code>.  If the adder is told
that one of its connectors has lost a value, it requests that all of its
connectors now lose their values.  (Only those values that were set by this
adder are actually lost.)  Then it runs <code>process-new-value</code>.  The reason
for this last step is that one or more connectors may still have a value (that
is, a connector may have had a value that was not originally set by the adder),
and these values may need to be propagated back through the adder.
</p>
<p>A multiplier is very similar to an adder. It will set its <code>product</code> to 0
if either of the factors is 0, even if the other factor is not known.
</p>
<div class="lisp">
<pre class="lisp">(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) 
                    (= (get-value m1) 0))
               (and (has-value? m2) 
                    (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) 
                (has-value? m2))
           (set-value! product
                       (* (get-value m1) 
                          (get-value m2))
                       me))
          ((and (has-value? product) 
                (has-value? m1))
           (set-value! m2
                       (/ (get-value product) 
                          (get-value m1))
                       me))
          ((and (has-value? product) 
                (has-value? m2))
           (set-value! m1
                       (/ (get-value product) 
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error &quot;Unknown request: 
                   MULTIPLIER&quot; 
                  request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
</pre></div>

<p>A <code>constant</code> constructor simply sets the value of the designated
connector.  Any <code>I-have-a-value</code> or <code>I-lost-my-value</code> message sent to
the constant box will produce an error.
</p>
<div class="lisp">
<pre class="lisp">(define (constant value connector)
  (define (me request)
    (error &quot;Unknown request: CONSTANT&quot; 
           request))
  (connect connector me)
  (set-value! connector value me)
  me)
</pre></div>

<p>Finally, a probe prints a message about the setting or unsetting of
the designated connector:
</p>
<div class="lisp">
<pre class="lisp">(define (probe name connector)
  (define (print-probe value)
    (newline) (display &quot;Probe: &quot;)
    (display name) (display &quot; = &quot;)
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe &quot;?&quot;))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error &quot;Unknown request: 
                        PROBE&quot; request))))
  (connect connector me)
  me)
</pre></div>

<a id="Representing-connectors"></a>
<h5 class="subsubheading">Representing connectors</h5>

<p>A connector is represented as a procedural object with local state variables
<code>value</code>, the current value of the connector; <code>informant</code>, the object
that set the connector’s value; and <code>constraints</code>, a list of the
constraints in which the connector participates.
</p>
<div class="lisp">
<pre class="lisp">(define (make-connector)
  (let ((value false) 
        (informant false) 
        (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except 
              setter
              inform-about-value
              constraints))
            ((not (= value newval))
             (error &quot;Contradiction&quot; 
                    (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except 
                  retractor
                  inform-about-no-value
                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint 
                     constraints))
          (set! constraints
                (cons new-constraint 
                      constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) 
             set-my-value)
            ((eq? request 'forget) 
             forget-my-value)
            ((eq? request 'connect) connect)
            (else (error &quot;Unknown operation: 
                          CONNECTOR&quot;
                         request))))
    me))
</pre></div>

<p>The connector’s local procedure <code>set-my-value</code> is called when there is a
request to set the connector’s value.  If the connector does not currently have
a value, it will set its value and remember as <code>informant</code> the constraint
that requested the value to be set.<a class="footnote_link" id="DOCF160" href="#FOOT160"><sup>160</sup></a>  Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set.  This is
accomplished using the following iterator, which applies a designated procedure
to all items in a list except a given one:
</p>
<div class="lisp">
<pre class="lisp">(define (for-each-except exception 
                         procedure 
                         list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) 
           (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
</pre></div>

<p>If a connector is asked to forget its value, it runs the local procedure
<code>forget-my-value</code>, which first checks to make sure that the request is
coming from the same object that set the value originally.  If so, the
connector informs its associated constraints about the loss of the value.
</p>
<p>The local procedure <code>connect</code> adds the designated new constraint to the
list of constraints if it is not already in that list.  Then, if the connector
has a value, it informs the new constraint of this fact.
</p>
<p>The connector’s procedure <code>me</code> serves as a dispatch to the other internal
procedures and also represents the connector as an object.  The following
procedures provide a syntax interface for the dispatch:
</p>
<div class="lisp">
<pre class="lisp">(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector 
                    new-value 
                    informant)
  ((connector 'set-value!) 
   new-value 
   informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-3_002e33"></a>Exercise 3.33:</strong> Using primitive multiplier,
adder, and constant constraints, define a procedure <code>averager</code> that takes
three connectors <code>a</code>, <code>b</code>, and <code>c</code> as inputs and establishes the
constraint that the value of <code>c</code> is the average of the values of <code>a</code>
and <code>b</code>.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e34"></a>Exercise 3.34:</strong> Louis Reasoner wants to build a
squarer, a constraint device with two terminals such that the value of
connector <code>b</code> on the second terminal will always be the square of the
value <code>a</code> on the first terminal.  He proposes the following simple device
made from a multiplier:
</p>
<div class="lisp">
<pre class="lisp">(define (squarer a b) (multiplier a a b))
</pre></div>

<p>There is a serious flaw in this idea.  Explain.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e35"></a>Exercise 3.35:</strong> Ben Bitdiddle tells Louis that
one way to avoid the trouble in <a href="#Exercise-3_002e34">Exercise 3.34</a> is to define a squarer as a
new primitive constraint.  Fill in the missing portions in Ben’s outline for a
procedure to implement such a constraint:
</p>
<div class="lisp">
<pre class="lisp">(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (&lt; (get-value b) 0)
            (error &quot;square less than 0: 
                    SQUARER&quot; 
                   (get-value b))
            ⟨<var>alternative1</var>⟩)
        ⟨<var>alternative2</var>⟩))
  (define (process-forget-value) ⟨<var>body1</var>⟩)
  (define (me request) ⟨<var>body2</var>⟩)
  ⟨<var>rest of definition</var>⟩
  me)
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e36"></a>Exercise 3.36:</strong> Suppose we evaluate the following
sequence of expressions in the global environment:
</p>
<div class="lisp">
<pre class="lisp">(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
</pre></div>

<p>At some time during evaluation of the <code>set-value!</code>, the following
expression from the connector’s local procedure is evaluated:
</p>
<div class="lisp">
<pre class="lisp">(for-each-except 
  setter inform-about-value constraints)
</pre></div>

<p>Draw an environment diagram showing the environment in which the above
expression is evaluated.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e37"></a>Exercise 3.37:</strong> The
<code>celsius-fahrenheit-converter</code> procedure is cumbersome when compared with
a more expression-oriented style of definition, such as
</p>
<div class="lisp">
<pre class="lisp">(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))

(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
</pre></div>

<p>Here <code>c+</code>, <code>c*</code>, etc. are the “constraint” versions of the
arithmetic operations.  For example, <code>c+</code> takes two connectors as
arguments and returns a connector that is related to these by an adder
constraint:
</p>
<div class="lisp">
<pre class="lisp">(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
</pre></div>

<p>Define analogous procedures <code>c-</code>, <code>c*</code>, <code>c/</code>, and <code>cv</code>
(constant value) that enable us to define compound constraints as in the
converter example above.<a class="footnote_link" id="DOCF161" href="#FOOT161"><sup>161</sup></a>
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT159"><p><a class="footnote_backlink" href="#DOCF159"><sup>159</sup></a>
Constraint propagation first appeared in the incredibly
forward-looking <abbr>SKETCHPAD</abbr> system of Ivan <a href="References.xhtml#Sutherland-_00281963_0029">Sutherland (1963)</a>.  A
beautiful constraint-propagation system based on the Smalltalk language was
developed by Alan <a href="References.xhtml#Borning-_00281977_0029">Borning (1977)</a> at Xerox Palo Alto Research Center.  Sussman,
Stallman, and Steele applied constraint propagation to electrical circuit
analysis (<a href="References.xhtml#Sussman-and-Stallman-1975">Sussman and Stallman 1975</a>; <a href="References.xhtml#Sussman-and-Steele-1980">Sussman and Steele 1980</a>). TK!Solver
(<a href="References.xhtml#Konopasek-and-Jayaraman-1984">Konopasek and Jayaraman 1984</a>) is an extensive modeling environment based on
constraints.</p>
</div>
<div id="FOOT160"><p><a class="footnote_backlink" href="#DOCF160"><sup>160</sup></a>
The <code>setter</code> might not be a
constraint.  In our temperature example, we used <code>user</code> as the
<code>setter</code>.</p>
</div>
<div id="FOOT161"><p><a class="footnote_backlink" href="#DOCF161"><sup>161</sup></a>
The expression-oriented format is convenient
because it avoids the need to name the intermediate expressions in a
computation.  Our original formulation of the constraint language is cumbersome
in the same way that many languages are cumbersome when dealing with operations
on compound data.  For example, if we wanted to compute the product 
\( {(a + b) \cdot (c + d)} \), where the variables represent vectors, we could work
in “imperative style,” using procedures that set the values of designated
vector arguments but do not themselves return vectors as values:
</p>
<div class="lisp">
<pre class="lisp">(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
</pre></div>

<p>Alternatively, we could deal with expressions, using procedures that return
vectors as values, and thus avoid explicitly mentioning <code>temp1</code> and
<code>temp2</code>:
</p>
<div class="lisp">
<pre class="lisp">(define answer 
  (v-prod (v-sum a b) (v-sum c d)))
</pre></div>

<p>Since Lisp allows us to return compound objects as values of procedures, we can
transform our imperative-style constraint language into an expression-oriented
style as shown in this exercise.  In languages that are impoverished in
handling compound objects, such as Algol, Basic, and Pascal (unless one
explicitly uses Pascal pointer variables), one is usually stuck with the
imperative style when manipulating compound objects.  Given the advantage of
the expression-oriented format, one might ask if there is any reason to have
implemented the system in imperative style, as we did in this section.  One
reason is that the non-expression-oriented constraint language provides a
handle on constraint objects (e.g., the value of the <code>adder</code> procedure) as
well as on connector objects.  This is useful if we wish to extend the system
with new operations that communicate with constraints directly rather than only
indirectly via operations on connectors.  Although it is easy to implement the
expression-oriented style in terms of the imperative implementation, it is very
difficult to do the converse.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="3_002e4.xhtml#g_t3_002e4" accesskey="n" rel="next">3.4</a>, Previous: <a href="3_002e3_002e4.xhtml#g_t3_002e3_002e4" accesskey="p" rel="prev">3.3.4</a>, Up: <a href="3_002e3.xhtml#g_t3_002e3" accesskey="u" rel="prev">3.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
