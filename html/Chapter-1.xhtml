<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Chapter 1</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Chapter 1"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Chapter 1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="index.xhtml#Top" rel="prev" title="Top"/>
<link href="1_002e1.xhtml#g_t1_002e1" rel="next" title="1.1"/>
<link href="Acknowledgments.xhtml#Acknowledgments" rel="prev" title="Acknowledgments"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="Chapter-1"></a>
<nav class="header">
<p>
Next: <a href="1_002e1.xhtml#g_t1_002e1" accesskey="n" rel="next">1.1</a>, Previous: <a href="Acknowledgments.xhtml#Acknowledgments" accesskey="p" rel="prev">Acknowledgments</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Xay-dung-Truu-tuong-voi-Thu-tuc-_0028Building-Abstractions-with-Procedures_0029"></a>
<h2 class="chapter"><span class="chapnum">1</span> Xây dựng Trừu tượng với Thủ tục (Building Abstractions with Procedures)</h2>

<blockquote>
<p>Hoạt động của trí não, nơi tiêu tốn năng lượng trên những ý tưởng đơn giản,
chủ yếu gồm ba thứ: 1.&#160;Kết&#160;hợp<!-- /@w --> nhiều ý tưởng đơn giản thành một ý tưởng tổng hợp, mọi
ý tưởng phức tạp được tạo ra nhờ đây. 2.&#160;Cái&#160;thứ&#160;hai<!-- /@w -->  là việc mang hai ý tưởng, dù đơn
giản hay phức tạp, cùng nhau, và đặt chúng bên cạnh nhau, sao cho ta có thể nhìn
cả hai cùng đồng thời, bằng cách này ta được ý tưởng về mối quan hệ giữa chúng với nhau. 3.&#160;Cái&#160;thứ&#160;ba<!-- /@w -->  
là tách ý tưởng khỏi các ý tưởng đi cùng nó trong thực tế tồn tại: điều này
được gọi là sự trừu tượng hóa, và đây là cách các ý tưởng tổng quát được tạo ra.
</p>
<p>—John Locke, <cite>Một Bài Luận Về Hoạt Động Hiểu Biết Của Con Người</cite> (1690)
</p></blockquote>


<p>Chúng ta nghiên cứu ý tưởng về <a id="index-qua-trinh-tinh-toan"></a>
<em>quá trình tính toán</em>.
Quá trình tính toán là những sinh vật trừu tượng sống trong máy tính. Khi 
chúng phát triển, những quá trình này thao tác trên một vật thể trừu tượng được
gọi là <a id="index-du-lieu"></a>
<em>dữ liệu</em>. Quá trình phát triển của một quá trình được chỉ dẫn trực
tiếp bởi một mẫu của những luật được gọi là một <a id="index-chuong-trinh"></a>
<em>chương trình</em>. Người ta
tạo ra chương trình để điều khiển những quá trình. Kết quả là, 
</p>
<p>As they
evolve, processes manipulate other abstract things called <a id="index-data"></a>
<em>data</em>.  The
evolution of a process is directed by a pattern of rules called a
<a id="index-program"></a>
<em>program</em>.  People create programs to direct processes.  In effect, we
dùng bùa phép để điều khiển những linh hồn trong máy tính.
</p>
<p>Một quá trình tính toán thật ra rất giống với ý tưởng của thầy phù thủy về 
linh hồn. Nó không thể thấy hay chạm tới. Nó không được tạo thành bởi vậy chất.
Tuy nhiên, nó rất thật. Nó có thể thực hiện những công việc trí tuệ. Nó có thể
trả lời các câu hỏi. Nó có thể tác động tới thế giới bằng cách rút tiền tại một
ngân hàng hay là điều khiển cách tay rô-bôt trong nhà máy. Những chương trình mà 
chúng ta dùng để điều khiển các quá trình giống với những bùa phép của thầy
phù thủy. Chúng được cẩn thận soạn ra từ những biểu thức biểu tượng của 
những ngôn <a id="index-lap-trinh"></a>
<em>lập trình</em> bí truyền mô tả công việc mà chúng ta muốn
các quá trình thực hiện.
</p>
<p>Một quá trình tính toán, trong một máy tính đang hoạt động, thực thi những chương 
trình một cách tỉ mỉ và chính xác. Do vậy, cũng giống như một thầy phù thủy học việc, 
các lập trình viên mới phải học để hiểu và dự đoán được tác dụng của bùa chú. Chỉ với
một lỗi nhỏ (thường được gọi là <a id="index-bo"></a>
<em>bọ</em> hay <a id="index-truc-trac"></a>
<em>trục trặc</em>) trong chương trình
có thể dẫn đến hậu quả phức tạp khó lường.
</p>
<p>May mắn, học lập trình được xem là ít nguy hiểm hơn so với học phép thuật, bởi vì nhưng linh hồn mà chúng ta giao thiệp thường được để những chỗ an toàn. Tuy nhiên, lập trình trong thực tế cuộc sống, yêu cầu sự cẩn trọng, chuyên môn, và trí thông minh. Một lỗi nhỏ trong một chương trình thiết kế (CAD), ví dụ, có thể dẫn đến va chạm máy bay hay vỡ đập hay sự tự hư hỏng của một robot công nghiệp.
</p>
<p>Những kỹ sư phần mềm chuyên nghiệp có năng lực tổ chức các chương trình sao cho chúng
có thể được đảm bảo rằng kết quả là các quá trình sẽ thực hiện những tác vụ 
được dự đinh. Họ có thể trực quan hóa hành vi của hệ thống. Họ biết được làm sao
để cấu trúc những chương trình sao cho những vấn đề không lường trước được sẽ 
không dẫn đến thảm họa, và khi các vấn đề nảy sinh, họ có thể <a id="index-debug"></a>
<em>debug</em> (tìm lỗi)
chương trình của mình. Một hệ thống tính toán được thiết kế tốt, giống
như một chiếc ôtô hay một nhà máy hạt nhân được thiết kế tốt, sẽ được thiết kế
theo mô-dun, nhờ vậy các bộ phận có thể được tạo ra, thay thế hay tìm lỗi một cách
độc lập.
</p>
<a id="Programming-in-Lisp"></a>
<h5 class="subsubheading">Programming in Lisp</h5>

<p>We need an appropriate language for describing processes, and we will use for
this purpose the programming language Lisp.  Just as our everyday thoughts are
usually expressed in our natural language (such as English, French, or
Japanese), and descriptions of quantitative phenomena are expressed with
mathematical notations, our procedural thoughts will be expressed in Lisp.
Lisp was invented in the late 1950s as a formalism for reasoning about the use
of certain kinds of logical expressions, called <a id="index-recursion-equations"></a>
<em>recursion equations</em>,
as a model for computation.  The language was conceived by John McCarthy and is
based on his paper “Recursive Functions of Symbolic Expressions and Their
Computation by Machine” (<a href="References.xhtml#McCarthy-1960">McCarthy 1960</a>).
</p>
<p>Despite its inception as a mathematical formalism, Lisp is a practical
programming language.  A Lisp <a id="index-interpreter"></a>
<em>interpreter</em> is a machine that carries
out processes described in the Lisp language.  The first Lisp interpreter was
implemented by McCarthy with the help of colleagues and students in the
Artificial Intelligence Group of the <abbr>MIT</abbr> Research Laboratory of
Electronics and in the <abbr>MIT</abbr> Computation Center.<a class="footnote_link" id="DOCF1" href="#FOOT1"><sup>1</sup></a>  Lisp, whose name is an acronym for
LISt Processing, was designed to provide symbol-manipulating capabilities for
attacking programming problems such as the symbolic differentiation and
integration of algebraic expressions.  It included for this purpose new data
objects known as atoms and lists, which most strikingly set it apart from all
other languages of the period.
</p>
<p>Lisp was not the product of a concerted design effort.  Instead, it evolved
informally in an experimental manner in response to users’ needs and to
pragmatic implementation considerations.  Lisp’s informal evolution has
continued through the years, and the community of Lisp users has traditionally
resisted attempts to promulgate any “official” definition of the language.
This evolution, together with the flexibility and elegance of the initial
conception, has enabled Lisp, which is the second oldest language in widespread
use today (only Fortran is older), to continually adapt to encompass the most
modern ideas about program design.  Thus, Lisp is by now a family of dialects,
which, while sharing most of the original features, may differ from one another
in significant ways.  The dialect of Lisp used in this book is called
Scheme.<a class="footnote_link" id="DOCF2" href="#FOOT2"><sup>2</sup></a>
</p>
<p>Because of its experimental character and its emphasis on symbol manipulation,
Lisp was at first very inefficient for numerical computations, at least in
comparison with Fortran.  Over the years, however, Lisp compilers have been
developed that translate programs into machine code that can perform numerical
computations reasonably efficiently.  And for special applications, Lisp has
been used with great effectiveness.<a class="footnote_link" id="DOCF3" href="#FOOT3"><sup>3</sup></a>  
Although Lisp has not yet overcome its old reputation as
hopelessly inefficient, Lisp is now used in many applications where efficiency
is not the central concern.  For example, Lisp has become a language of choice
for operating-system shell languages and for extension languages for editors
and computer-aided design systems.
</p>
<p>If Lisp is not a mainstream language, why are we using it as the framework for
our discussion of programming?  Because the language possesses unique features
that make it an excellent medium for studying important programming constructs
and data structures and for relating them to the linguistic features that
support them.  The most significant of these features is the fact that Lisp
descriptions of processes, called <a id="index-procedures"></a>
<em>procedures</em>, can themselves be
represented and manipulated as Lisp data.  The importance of this is that there
are powerful program-design techniques that rely on the ability to blur the
traditional distinction between “passive” data and “active” processes.  As
we shall discover, Lisp’s flexibility in handling procedures as data makes it
one of the most convenient languages in existence for exploring these
techniques.  The ability to represent procedures as data also makes Lisp an
excellent language for writing programs that must manipulate other programs as
data, such as the interpreters and compilers that support computer languages.
Above and beyond these considerations, programming in Lisp is great fun.
</p>
<table class="menu" style="border-collapse: collapse; border-spacing: 0">
<tr><td style="text-align: left; vertical-align: top"><a href="1_002e1.xhtml#g_t1_002e1" accesskey="1">1.1</a>:</td><td>&#160;&#160;</td><td style="text-align: left; vertical-align: top">The Elements of Programming
</td></tr>
<tr><td style="text-align: left; vertical-align: top"><a href="1_002e2.xhtml#g_t1_002e2" accesskey="2">1.2</a>:</td><td>&#160;&#160;</td><td style="text-align: left; vertical-align: top">Procedures and the Processes They Generate
</td></tr>
<tr><td style="text-align: left; vertical-align: top"><a href="1_002e3.xhtml#g_t1_002e3" accesskey="3">1.3</a>:</td><td>&#160;&#160;</td><td style="text-align: left; vertical-align: top">Formulating Abstractions with Higher-Order Procedures
</td></tr>
</table>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT1"><p><a class="footnote_backlink" href="#DOCF1"><sup>1</sup></a>
The
<cite>Lisp 1 Programmer’s Manual</cite> appeared in 1960 and the <cite>Lisp 1.5
Programmer’s Manual</cite> (<a href="References.xhtml#McCarthy-et-al_002e-1965">McCarthy et al. 1965</a>) was published in 1962.  The early history
of Lisp is described in <a href="References.xhtml#McCarthy-1978">McCarthy 1978</a>.</p>
</div>
<div id="FOOT2"><p><a class="footnote_backlink" href="#DOCF2"><sup>2</sup></a>
The two dialects in which most major Lisp programs of the
1970s were written are MacLisp (<a href="References.xhtml#Moon-1978">Moon 1978</a>; <a href="References.xhtml#Pitman-1983">Pitman 1983</a>), developed at the
<abbr>MIT</abbr> Project <abbr>MAC</abbr>, and Interlisp (<a href="References.xhtml#Teitelman-1974">Teitelman 1974</a>), developed
at Bolt Beranek and Newman Inc. and the Xerox Palo Alto Research Center.
Portable Standard Lisp (<a href="References.xhtml#Hearn-1969">Hearn 1969</a>; <a href="References.xhtml#Griss-1981">Griss 1981</a>) was a Lisp dialect designed to
be easily portable between different machines.  MacLisp spawned a number of
subdialects, such as Franz Lisp, which was developed at the University of
California at Berkeley, and Zetalisp (<a href="References.xhtml#Moon-and-Weinreb-1981">Moon and Weinreb 1981</a>), which was based on a
special-purpose processor designed at the <abbr>MIT</abbr> Artificial Intelligence
Laboratory to run Lisp very efficiently.  The Lisp dialect used in this book,
called Scheme (<a href="References.xhtml#Steele-and-Sussman-1975">Steele and Sussman 1975</a>), was invented in 1975 by Guy Lewis Steele Jr. and
Gerald Jay Sussman of the <abbr>MIT</abbr> Artificial Intelligence Laboratory and
later reimplemented for instructional use at <abbr>MIT</abbr>.  Scheme became an
<abbr>IEEE</abbr> standard in 1990 (<a href="References.xhtml#IEEE-1990">IEEE 1990</a>).  The Common Lisp dialect
(<a href="References.xhtml#Steele-1982">Steele 1982</a>, <a href="References.xhtml#Steele-1990">Steele 1990</a>) was developed by the Lisp community to combine
features from the earlier Lisp dialects to make an industrial standard for
Lisp.  Common Lisp became an <abbr>ANSI</abbr> standard in 1994 (<a href="References.xhtml#ANSI-1994">ANSI 1994</a>).</p>
</div>
<div id="FOOT3"><p><a class="footnote_backlink" href="#DOCF3"><sup>3</sup></a>
One such special application was a
breakthrough computation of scientific importance—an integration of the
motion of the Solar System that extended previous results by nearly two orders
of magnitude, and demonstrated that the dynamics of the Solar System is
chaotic.  This computation was made possible by new integration algorithms, a
special-purpose compiler, and a special-purpose computer all implemented with
the aid of software tools written in Lisp (<a href="References.xhtml#Abelson-et-al_002e-1992">Abelson et al. 1992</a>; <a href="References.xhtml#Sussman-and-Wisdom-1992">Sussman and Wisdom 1992</a>).</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="1_002e1.xhtml#g_t1_002e1" accesskey="n" rel="next">1.1</a>, Previous: <a href="Acknowledgments.xhtml#Acknowledgments" accesskey="p" rel="prev">Acknowledgments</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
