<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.4</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.4"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5"/>
<link href="5_002e5_002e5.xhtml#g_t5_002e5_002e5" rel="next" title="5.5.5"/>
<link href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" rel="prev" title="5.5.3"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e4"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e5.xhtml#g_t5_002e5_002e5" accesskey="n" rel="next">5.5.5</a>, Previous: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="p" rel="prev">5.5.3</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Combining-Instruction-Sequences"></a>
<h4 class="subsection"><span class="secnum">5.5.4</span><span class="sectitle">Combining Instruction Sequences</span></h4>

<p>This section describes the details on how instruction sequences are represented
and combined.  Recall from <a href="5_002e5_002e1.xhtml#g_t5_002e5_002e1">5.5.1</a> that an instruction sequence is
represented as a list of the registers needed, the registers modified, and the
actual instructions.  We will also consider a label (symbol) to be a degenerate
case of an instruction sequence, which doesn’t need or modify any registers.
So to determine the registers needed and modified by instruction sequences we
use the selectors
</p>
<div class="lisp">
<pre class="lisp">(define (registers-needed s)
  (if (symbol? s) '() (car s)))
(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
</pre></div>

<p>and to determine whether a given
sequence needs or modifies a given register we use the predicates
</p>
<div class="lisp">
<pre class="lisp">(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
</pre></div>

<p>In terms of these predicates and selectors, we can implement the various
instruction sequence combiners used throughout the compiler.
</p>
<p>The basic combiner is <code>append-instruction-sequences</code>.  This takes as
arguments an arbitrary number of instruction sequences that are to be executed
sequentially and returns an instruction sequence whose statements are the
statements of all the sequences appended together.  The subtle point is to
determine the registers that are needed and modified by the resulting sequence.
It modifies those registers that are modified by any of the sequences; it needs
those registers that must be initialized before the first sequence can be run
(the registers needed by the first sequence), together with those registers
needed by any of the other sequences that are not initialized (modified) by
sequences preceding it.
</p>
<p>The sequences are appended two at a time by <code>append-2-sequences</code>.  This
takes two instruction sequences <code>seq1</code> and <code>seq2</code> and returns the
instruction sequence whose statements are the statements of <code>seq1</code>
followed by the statements of <code>seq2</code>, whose modified registers are those
registers that are modified by either <code>seq1</code> or <code>seq2</code>, and whose
needed registers are the registers needed by <code>seq1</code> together with those
registers needed by <code>seq2</code> that are not modified by <code>seq1</code>.  (In
terms of set operations, the new set of needed registers is the union of the
set of registers needed by <code>seq1</code> with the set difference of the registers
needed by <code>seq2</code> and the registers modified by <code>seq1</code>.)  Thus,
<code>append-instruction-sequences</code> is implemented as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union 
      (registers-needed seq1)
      (list-difference 
       (registers-needed seq2)
       (registers-modified seq1)))
     (list-union
      (registers-modified seq1)
      (registers-modified seq2))
     (append (statements seq1)
             (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences 
         (car seqs)
         (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
</pre></div>

<p>This procedure uses some simple operations for manipulating sets represented as
lists, similar to the (unordered) set representation described in 
<a href="2_002e3_002e3.xhtml#g_t2_002e3_002e3">2.3.3</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2)
         (list-union (cdr s1) s2))
        (else
         (cons (car s1)
               (list-union (cdr s1) s2)))))

(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2)
         (list-difference (cdr s1) s2))
        (else 
         (cons (car s1)
               (list-difference (cdr s1)
                                s2)))))
</pre></div>

<p><code>Preserving</code>, the second major instruction sequence combiner, takes a list
of registers <code>regs</code> and two instruction sequences <code>seq1</code> and
<code>seq2</code> that are to be executed sequentially.  It returns an instruction
sequence whose statements are the statements of <code>seq1</code> followed by the
statements of <code>seq2</code>, with appropriate <code>save</code> and <code>restore</code>
instructions around <code>seq1</code> to protect the registers in <code>regs</code> that
are modified by <code>seq1</code> but needed by <code>seq2</code>.  To accomplish this,
<code>preserving</code> first creates a sequence that has the required <code>save</code>s
followed by the statements of <code>seq1</code> followed by the required
<code>restore</code>s.  This sequence needs the registers being saved and restored in
addition to the registers needed by <code>seq1</code>, and modifies the registers
modified by <code>seq1</code> except for the ones being saved and restored.  This
augmented sequence and <code>seq2</code> are then appended in the usual way.  The
following procedure implements this strategy recursively, walking down the list
of registers to be preserved:<a class="footnote_link" id="DOCF327" href="#FOOT327"><sup>327</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and 
             (needs-register? seq2 first-reg)
             (modifies-register? seq1 
                                 first-reg))
            (preserving 
             (cdr regs)
             (make-instruction-sequence
              (list-union 
               (list first-reg)
               (registers-needed seq1))
              (list-difference
               (registers-modified seq1)
               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving 
             (cdr regs)
             seq1
             seq2)))))
</pre></div>

<p>Another sequence combiner, <code>tack-on-instruction-sequence</code>, is used by
<code>compile-lambda</code> to append a procedure body to another sequence.  Because
the procedure body is not “in line” to be executed as part of the combined
sequence, its register use has no impact on the register use of the sequence in
which it is embedded.  We thus ignore the procedure body’s sets of needed and
modified registers when we tack it onto the other sequence.
</p>
<div class="lisp">
<pre class="lisp">(define (tack-on-instruction-sequence 
         seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq)
           (statements body-seq))))
</pre></div>

<p><code>Compile-if</code> and <code>compile-procedure-call</code> use a special combiner
called <code>parallel-instruction-sequences</code> to append the two alternative
branches that follow a test.  The two branches will never be executed
sequentially; for any particular evaluation of the test, one branch or the
other will be entered.  Because of this, the registers needed by the second
branch are still needed by the combined sequence, even if these are modified by
the first branch.
</p>
<div class="lisp">
<pre class="lisp">(define (parallel-instruction-sequences 
         seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1)
           (statements seq2))))
</pre></div>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT327"><p><a class="footnote_backlink" href="#DOCF327"><sup>327</sup></a>
Note that <code>preserving</code> calls
<code>append</code> with three arguments.  Though the definition of <code>append</code>
shown in this book accepts only two arguments, Scheme standardly provides an
<code>append</code> procedure that takes an arbitrary number of arguments.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="5_002e5_002e5.xhtml#g_t5_002e5_002e5" accesskey="n" rel="next">5.5.5</a>, Previous: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="p" rel="prev">5.5.3</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
