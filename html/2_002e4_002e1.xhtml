<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.4.1</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.4.1"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.4.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="2_002e4.xhtml#g_t2_002e4" rel="prev" title="2.4"/>
<link href="2_002e4_002e2.xhtml#g_t2_002e4_002e2" rel="next" title="2.4.2"/>
<link href="2_002e4.xhtml#g_t2_002e4" rel="prev" title="2.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t2_002e4_002e1"></a>
<nav class="header">
<p>
Next: <a href="2_002e4_002e2.xhtml#g_t2_002e4_002e2" accesskey="n" rel="next">2.4.2</a>, Previous: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="p" rel="prev">2.4</a>, Up: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="u" rel="prev">2.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Representations-for-Complex-Numbers"></a>
<h4 class="subsection"><span class="secnum">2.4.1</span><span class="sectitle">Representations for Complex Numbers</span></h4>

<p>We will develop a system that performs arithmetic operations on complex numbers
as a simple but unrealistic example of a program that uses generic operations.
We begin by discussing two plausible representations for complex numbers as
ordered pairs: rectangular form (real part and imaginary part) and polar form
(magnitude and angle).<a class="footnote_link" id="DOCF109" href="#FOOT109"><sup>109</sup></a>  
Section <a href="2_002e4_002e2.xhtml#g_t2_002e4_002e2">2.4.2</a> will show how both representations can be made to coexist in a
single system through the use of type tags and generic operations.
</p>
<p>Like rational numbers, complex numbers are naturally represented as ordered
pairs.  The set of complex numbers can be thought of as a two-dimensional space
with two orthogonal axes, the “real” axis and the “imaginary” axis. (See
<a href="#Figure-2_002e20">Figure 2.20</a>.)  From this point of view, the complex number 
\( {z = x + iy} \) (where \( {i^{\kern0.1em 2} = \text{−1}} \)) can be thought of as the point in the plane
whose real coordinate is \( x \) and whose imaginary coordinate is \( y \).
Addition of complex numbers reduces in this representation to addition of
coordinates:
\[ % :46:
\begin{eqnarray}
\text{Real-part} (z_1 + z_2) 	    &amp;=&amp; \text{Real-part} (z_1) + \\
                                    &amp; &amp; \text{Real-part} (z_2),  \\
\text{Imaginary-part} (z_1 + z_2)   &amp;=&amp; \text{Imaginary-part} (z_1) + \\
                                    &amp; &amp; \text{Imaginary-part} (z_2).
\end{eqnarray}
\]
</p>
<figure class="float">
<a id="Figure-2_002e20"></a>
<object style="width: 51.98ex; height: 30.74ex;" data="fig/chap2/Fig2.20.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.20:</strong> Complex numbers as points in the plane.</p>
</figcaption>
</figure>

<p>When multiplying complex numbers, it is more natural to think in terms of
representing a complex number in polar form, as a magnitude and an angle (\( r \)
and \( A \) in <a href="#Figure-2_002e20">Figure 2.20</a>).  The product of two complex numbers is the
vector obtained by stretching one complex number by the length of the other and
then rotating it through the angle of the other:
\[ % :47:
\begin{eqnarray}
  \text{Magnitude} (z_1 \cdot z_2)  &amp;=&amp; 
    \text{Magnitude} (z_1) \cdot \text{Magnitude} (z_2), \\
  \text{Angle} (z_1 \cdot z_2)      &amp;=&amp; 
    \text{Angle} (z_1) + \text{Angle} (z_2).
\end{eqnarray}
\]
</p>
<p>Thus, there are two different representations for complex numbers, which are
appropriate for different operations.  Yet, from the viewpoint of someone
writing a program that uses complex numbers, the principle of data abstraction
suggests that all the operations for manipulating complex numbers should be
available regardless of which representation is used by the computer.  For
example, it is often useful to be able to find the magnitude of a complex
number that is specified by rectangular coordinates.  Similarly, it is often
useful to be able to determine the real part of a complex number that is
specified by polar coordinates.
</p>
<p>To design such a system, we can follow the same data-abstraction strategy we
followed in designing the rational-number package in <a href="2_002e1_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>.
Assume that the operations on complex numbers are implemented in terms of four
selectors: <code>real-part</code>, <code>imag-part</code>, <code>magnitude</code>, and
<code>angle</code>.  Also assume that we have two procedures for constructing complex
numbers: <code>make-from-real-imag</code> returns a complex number with specified
real and imaginary parts, and <code>make-from-mag-ang</code> returns a complex number
with specified magnitude and angle.  These procedures have the property that,
for any complex number <code>z</code>, both
</p>
<div class="lisp">
<pre class="lisp">(make-from-real-imag (real-part z) 
                     (imag-part z))
</pre></div>

<p>and
</p>
<div class="lisp">
<pre class="lisp">(make-from-mag-ang (magnitude z) 
                   (angle z))
</pre></div>

<p>produce complex numbers that are equal to <code>z</code>.
</p>
<p>Using these constructors and selectors, we can implement arithmetic on complex
numbers using the “abstract data” specified by the constructors and
selectors, just as we did for rational numbers in <a href="2_002e1_002e1.xhtml#g_t2_002e1_002e1">2.1.1</a>.  As
shown in the formulas above, we can add and subtract complex numbers in terms
of real and imaginary parts while multiplying and dividing complex numbers in
terms of magnitudes and angles:
</p>
<div class="lisp">
<pre class="lisp">(define (add-complex z1 z2)
  (make-from-real-imag 
   (+ (real-part z1) (real-part z2))
   (+ (imag-part z1) (imag-part z2))))

(define (sub-complex z1 z2)
  (make-from-real-imag 
   (- (real-part z1) (real-part z2))
   (- (imag-part z1) (imag-part z2))))

(define (mul-complex z1 z2)
  (make-from-mag-ang 
   (* (magnitude z1) (magnitude z2))
   (+ (angle z1) (angle z2))))

(define (div-complex z1 z2)
  (make-from-mag-ang 
   (/ (magnitude z1) (magnitude z2))
   (- (angle z1) (angle z2))))
</pre></div>

<p>To complete the complex-number package, we must choose a representation and we
must implement the constructors and selectors in terms of primitive numbers and
primitive list structure.  There are two obvious ways to do this: We can
represent a complex number in “rectangular form” as a pair (real part,
imaginary part) or in “polar form” as a pair (magnitude, angle).  Which shall
we choose?
</p>
<p>In order to make the different choices concrete, imagine that there are two
programmers, Ben Bitdiddle and Alyssa P. Hacker, who are independently
designing representations for the complex-number system.  Ben chooses to
represent complex numbers in rectangular form.  With this choice, selecting the
real and imaginary parts of a complex number is straightforward, as is
constructing a complex number with given real and imaginary parts.  To find the
magnitude and the angle, or to construct a complex number with a given
magnitude and angle, he uses the trigonometric relations
</p>
\[ % :48:
\begin{eqnarray}
  x &amp;=&amp; r \cos A, \\
  y &amp;=&amp; r \sin A, \\
  r &amp;=&amp; \sqrt{x^2 + y^2,} \\
  A &amp;=&amp; \arctan(y, x),
\end{eqnarray}
\]

<p>which relate the real and imaginary parts \( {(x, y)} \) to the magnitude and
the angle \( {(r, A)} \).<a class="footnote_link" id="DOCF110" href="#FOOT110"><sup>110</sup></a>  Ben’s
representation is therefore given by the following selectors and constructors:
</p>
<div class="lisp">
<pre class="lisp">(define (real-part z) (car z))
(define (imag-part z) (cdr z))

(define (magnitude z)
  (sqrt (+ (square (real-part z)) 
           (square (imag-part z)))))

(define (angle z)
  (atan (imag-part z) (real-part z)))

(define (make-from-real-imag x y) 
  (cons x y))

(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
</pre></div>

<p>Alyssa, in contrast, chooses to represent complex numbers in polar form.  For
her, selecting the magnitude and angle is straightforward, but she has to use
the trigonometric relations to obtain the real and imaginary parts.  Alyssa’s
representation is:
</p>
<div class="lisp">
<pre class="lisp">(define (real-part z)
  (* (magnitude z) (cos (angle z))))

(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

(define (magnitude z) (car z))
(define (angle z) (cdr z))

(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))

(define (make-from-mag-ang r a) 
  (cons r a))
</pre></div>

<p>The discipline of data abstraction ensures that the same implementation of
<code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code>, and
<code>div-complex</code> will work with either Ben’s representation or Alyssa’s
representation.
</p>
<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT109"><p><a class="footnote_backlink" href="#DOCF109"><sup>109</sup></a>
In actual computational systems, rectangular
form is preferable to polar form most of the time because of roundoff errors in
conversion between rectangular and polar form.  This is why the complex-number
example is unrealistic.  Nevertheless, it provides a clear illustration of the
design of a system using generic operations and a good introduction to the more
substantial systems to be developed later in this chapter.</p>
</div>
<div id="FOOT110"><p><a class="footnote_backlink" href="#DOCF110"><sup>110</sup></a>
The arctangent function referred to here,
computed by Scheme’s <code>atan</code> procedure, is defined so as to take two
arguments \( y \) and \( x \) and to return the angle whose tangent is \( {y / x} \).
The signs of the arguments determine the quadrant of the angle.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="2_002e4_002e2.xhtml#g_t2_002e4_002e2" accesskey="n" rel="next">2.4.2</a>, Previous: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="p" rel="prev">2.4</a>, Up: <a href="2_002e4.xhtml#g_t2_002e4" accesskey="u" rel="prev">2.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
