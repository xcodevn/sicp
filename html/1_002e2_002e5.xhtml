<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 1.2.5</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 1.2.5"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 1.2.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="1_002e2.xhtml#g_t1_002e2" rel="prev" title="1.2"/>
<link href="1_002e2_002e6.xhtml#g_t1_002e2_002e6" rel="next" title="1.2.6"/>
<link href="1_002e2_002e4.xhtml#g_t1_002e2_002e4" rel="prev" title="1.2.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t1_002e2_002e5"></a>
<nav class="header">
<p>
Next: <a href="1_002e2_002e6.xhtml#g_t1_002e2_002e6" accesskey="n" rel="next">1.2.6</a>, Previous: <a href="1_002e2_002e4.xhtml#g_t1_002e2_002e4" accesskey="p" rel="prev">1.2.4</a>, Up: <a href="1_002e2.xhtml#g_t1_002e2" accesskey="u" rel="prev">1.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Greatest-Common-Divisors"></a>
<h4 class="subsection"><span class="secnum">1.2.5</span><span class="sectitle">Greatest Common Divisors</span></h4>

<p>The greatest common divisor (<abbr>GCD</abbr>) of two integers \( a \) and \( b \) is
defined to be the largest integer that divides both \( a \) and \( b \) with no
remainder.  For example, the <abbr>GCD</abbr> of 16 and 28 is 4.  In <a href="Chapter-2.xhtml#Chapter-2">Chapter 2</a>, when we investigate how to implement rational-number arithmetic, we will
need to be able to compute <abbr>GCD</abbr>s in order to reduce rational numbers
to lowest terms.  (To reduce a rational number to lowest terms, we must divide
both the numerator and the denominator by their <abbr>GCD</abbr>.  For example,
16/28 reduces to 4/7.)  One way to find the <abbr>GCD</abbr> of two integers is to
factor them and search for common factors, but there is a famous algorithm that
is much more efficient.
</p>
<p>The idea of the algorithm is based on the observation that, if \( r \) is the
remainder when \( a \) is divided by \( b \), then the common divisors of \( a \) and
\( b \) are precisely the same as the common divisors of \( b \) and \( r \).  Thus,
we can use the equation
</p>
<div class="example">
<pre class="example">GCD(a,b) = GCD(b,r)
</pre></div>

<p>to successively reduce the problem of computing a <abbr>GCD</abbr> to the problem
of computing the <abbr>GCD</abbr> of smaller and smaller pairs of integers.  For
example,
</p>
<div class="example">
<pre class="example">GCD(206,40) = GCD(40,6)
            = GCD(6,4)
            = GCD(4,2)
            = GCD(2,0) = 2
</pre></div>

<p>reduces <abbr>GCD</abbr>(206, 40) to <abbr>GCD</abbr>(2, 0), which is 2.  It is
possible to show that starting with any two positive integers and performing
repeated reductions will always eventually produce a pair where the second
number is 0.  Then the <abbr>GCD</abbr> is the other number in the pair.  This
method for computing the <abbr>GCD</abbr> is known as 
<a id="index-Euclid_0027s-Algorithm"></a>
<em>Euclid’s Algorithm</em>.<a class="footnote_link" id="DOCF42" href="#FOOT42"><sup>42</sup></a>
</p>
<p>It is easy to express Euclid’s Algorithm as a procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</pre></div>

<p>This generates an iterative process, whose number of steps grows as the
logarithm of the numbers involved.
</p>
<p>The fact that the number of steps required by Euclid’s Algorithm has
logarithmic growth bears an interesting relation to the Fibonacci numbers:
</p>
<blockquote>
<p><strong>Lamé’s Theorem:</strong> If Euclid’s Algorithm requires \( k \) steps to
compute the <abbr>GCD</abbr> of some pair, then the smaller number in the pair
must be greater than or equal to the \( k^{\text{th}} \) Fibonacci number.<a class="footnote_link" id="DOCF43" href="#FOOT43"><sup>43</sup></a>
</p></blockquote>

<p>We can use this theorem to get an order-of-growth estimate for Euclid’s
Algorithm.  Let \( n \) be the smaller of the two inputs to the procedure.  If
the process takes \( k \) steps, then we must have 
\( n \ge {\text{Fib}(k)} \approx {\varphi^k / \sqrt{5}} \).  Therefore the number of steps \( k \)
grows as the logarithm (to the base \( \varphi \)) of \( n \).  Hence, the order of
growth is \( {\Theta(\log n)} \).
</p>
<blockquote>
<p><strong><a id="Exercise-1_002e20"></a>Exercise 1.20:</strong> The process that a procedure
generates is of course dependent on the rules used by the interpreter.  As an
example, consider the iterative <code>gcd</code> procedure given above.  Suppose we
were to interpret this procedure using normal-order evaluation, as discussed in
<a href="1_002e1_002e5.xhtml#g_t1_002e1_002e5">1.1.5</a>.  (The normal-order-evaluation rule for <code>if</code> is
described in <a href="1_002e1_002e6.xhtml#Exercise-1_002e5">Exercise 1.5</a>.)  Using the substitution method (for normal
order), illustrate the process generated in evaluating <code>(gcd 206 40)</code> and
indicate the <code>remainder</code> operations that are actually performed.  How many
<code>remainder</code> operations are actually performed in the normal-order
evaluation of <code>(gcd 206 40)</code>?  In the applicative-order evaluation?
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT42"><p><a class="footnote_backlink" href="#DOCF42"><sup>42</sup></a>
Euclid’s Algorithm is so called because 
it appears in Euclid’s <cite>Elements</cite> (Book 7, ca. 300 <abbr>B.C.</abbr>).  
According to <a href="References.xhtml#Knuth-_00281973_0029">Knuth (1973)</a>, it can be considered the oldest known nontrivial 
algorithm.  The ancient Egyptian method of multiplication (<a href="1_002e2_002e4.xhtml#Exercise-1_002e18">Exercise 1.18</a>) is 
surely older, but, as Knuth explains, Euclid’s algorithm is the oldest known to 
have been presented as a general algorithm, rather than as a set of illustrative
examples.</p>
</div>
<div id="FOOT43"><p><a class="footnote_backlink" href="#DOCF43"><sup>43</sup></a>
This
theorem was proved in 1845 by Gabriel Lamé, a French mathematician and
engineer known chiefly for his contributions to mathematical physics.  To prove
the theorem, we consider pairs \( {(a_k, b_k)} \), where \( {a_k \ge b_k} \), 
for which Euclid’s Algorithm terminates in \( k \) steps.  The proof
is based on the claim that, if \( {(a_{k+1}, b_{k+1})} \to {(a_k, b_k)} \to {(a_{k-1}, b_{k-1})} \) 
are three successive pairs 
in the reduction process, then we must have \( b_{k+1} \ge b_k + b_{k-1} \).  
To verify the claim, consider that a reduction step is defined by applying the 
transformation \( {a_{k-1} = b_k} \), \( {b_{k-1} =} \) remainder of \( a_k \) 
divided by \( b_k \).  The second equation means that \( a_k = {qb_k} + {b_{k-1}} \) 
for some positive integer \( q \).  And since \( q \) must be at least 1 we have 
\( a_k = {qb_k} + b_{k-1} \ge b_k + b_{k-1} \).  But in the previous reduction 
step we have \( b_{k+1} = a_k \).  Therefore, \( b_{k+1} = a_k \ge b_k + b_{k-1} \).
This verifies the claim.  Now we can prove the theorem by induction on \( k \), 
the number of steps that the algorithm requires to terminate.  The result is true for 
\( {k = 1} \), since this merely requires that \( b \) be at least as large as \( {\text{Fib}(1) = 1} \).  
Now, assume that the result is true for all integers less than or equal
to \( k \) and establish the result for \( {k + 1} \).  
Let \( {(a_{k+1}, b_{k+1})} \to {(a_k, b_k)} \to {(a_{k-1}, b_{k-1})} \) 
be successive pairs in the reduction 
process.  By our induction hypotheses, we have \( b_{k-1} \ge {\text{Fib}(k - 1)} \) 
and \( b_k \ge {\text{Fib}(k)} \).  Thus, applying the claim we just proved together with 
the definition of the Fibonacci numbers gives 
\( b_{k+1} \ge b_k + b_{k-1} \ge {\text{Fib}(k)} + {\text{Fib}(k-1)} = {\text{Fib}(k+1)} \), 
which completes the proof of Lamé’s Theorem.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="1_002e2_002e6.xhtml#g_t1_002e2_002e6" accesskey="n" rel="next">1.2.6</a>, Previous: <a href="1_002e2_002e4.xhtml#g_t1_002e2_002e4" accesskey="p" rel="prev">1.2.4</a>, Up: <a href="1_002e2.xhtml#g_t1_002e2" accesskey="u" rel="prev">1.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
