<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 1.3.1</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 1.3.1"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 1.3.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="1_002e3.xhtml#g_t1_002e3" rel="prev" title="1.3"/>
<link href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" rel="next" title="1.3.2"/>
<link href="1_002e3.xhtml#g_t1_002e3" rel="prev" title="1.3"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t1_002e3_002e1"></a>
<nav class="header">
<p>
Next: <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" accesskey="n" rel="next">1.3.2</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="p" rel="prev">1.3</a>, Up: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="u" rel="prev">1.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Procedures-as-Arguments"></a>
<h4 class="subsection"><span class="secnum">1.3.1</span><span class="sectitle">Procedures as Arguments</span></h4>

<p>Consider the following three procedures.  The first computes the sum of the
integers from <code>a</code> through <code>b</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (sum-integers a b)
  (if (&gt; a b) 
      0 
      (+ a (sum-integers (+ a 1) b))))
</pre></div>

<p>The second computes the sum of the cubes of the integers in the given range:
</p>
<div class="lisp">
<pre class="lisp">(define (sum-cubes a b)
  (if (&gt; a b) 
      0 
      (+ (cube a) 
         (sum-cubes (+ a 1) b))))
</pre></div>

<p>The third computes the sum of a sequence of terms in the series

\[ % :17:
  
\frac{1}{1\cdot 3} +  \frac{1}{5\cdot 7} + \frac{1}{9\cdot 11} + {\dots,}
\]

which converges to \( {\pi / 8} \) (very slowly):<a class="footnote_link" id="DOCF49" href="#FOOT49"><sup>49</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (pi-sum a b)
  (if (&gt; a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) 
         (pi-sum (+ a 4) b))))
</pre></div>

<p>These three procedures clearly share a common underlying pattern.  They are for
the most part identical, differing only in the name of the procedure, the
function of <code>a</code> used to compute the term to be added, and the function
that provides the next value of <code>a</code>.  We could generate each of the
procedures by filling in slots in the same template:
</p>
<div class="lisp">
<pre class="lisp">(define (⟨<var>name</var>⟩ a b)
  (if (&gt; a b)
      0
      (+ (⟨<var>term</var>⟩ a) 
         (⟨<var>name</var>⟩ (⟨<var>next</var>⟩ a) b))))
</pre></div>

<p>The presence of such a common pattern is strong evidence that there is a useful
abstraction waiting to be brought to the surface.  Indeed, mathematicians long
ago identified the abstraction of <a id="index-summation-of-a-series"></a>
<em>summation of a series</em> and invented
“sigma notation,” for example

\[ % :18:
 
{\sum_{n = a}^b f(n)} \,=\, {f(a)} + \dots + {f(b),}
\]

to express this concept.  The power of sigma notation is that it allows
mathematicians to deal with the concept of summation itself rather than only
with particular sums—for example, to formulate general results about sums
that are independent of the particular series being summed.
</p>
<p>Similarly, as program designers, we would like our language to be powerful
enough so that we can write a procedure that expresses the concept of summation
itself rather than only procedures that compute particular sums.  We can do so
readily in our procedural language by taking the common template shown above
and transforming the “slots” into formal parameters:
</p>
<div class="lisp">
<pre class="lisp">(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
</pre></div>

<p>Notice that <code>sum</code> takes as its arguments the lower and upper bounds
<code>a</code> and <code>b</code> together with the procedures <code>term</code> and <code>next</code>.
We can use <code>sum</code> just as we would any procedure.  For example, we can use
it (along with a procedure <code>inc</code> that increments its argument by 1) to
define <code>sum-cubes</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))
</pre></div>

<p>Using this, we can compute the sum of the cubes of the integers from 1 to 10:
</p>
<div class="lisp">
<pre class="lisp">(sum-cubes 1 10)
<i>3025</i>
</pre></div>

<p>With the aid of an identity procedure to compute the term, we can define
<code>sum-integers</code> in terms of <code>sum</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
</pre></div>

<p>Then we can add up the integers from 1 to 10:
</p>
<div class="lisp">
<pre class="lisp">(sum-integers 1 10)
<i>55</i>
</pre></div>

<p>We can also define <code>pi-sum</code> in the same way:<a class="footnote_link" id="DOCF50" href="#FOOT50"><sup>50</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
</pre></div>

<p>Using these procedures, we can compute an approximation to \( \pi \):
</p>
<div class="lisp">
<pre class="lisp">(* 8 (pi-sum 1 1000))
<i>3.139592655589783</i>
</pre></div>

<p>Once we have <code>sum</code>, we can use it as a building block in formulating
further concepts.  For instance, the definite integral of a function \( f \)
between the limits \( a \) and \( b \) can be approximated numerically using the
formula

\[ % :19:
 
{\int_a^b \kern-0.3em f}
  \;=\; {\left[\;f\left(a + \frac{d x}{2}\right)\right.}
  \,+\, {f\left(a + dx + \frac{dx}{2}\right)}
  \,+\, {\left. f\left(a + 2dx + \frac{dx}{2}\right)
  \,+\, \dots \;\right] dx}
\]

for small values of \( {dx} \).  We can express this directly as a procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) 
     dx))

(integral cube 0 1 0.01)
<i>.24998750000000042</i>

(integral cube 0 1 0.001)
<i>.249999875000001</i>
</pre></div>

<p>(The exact value of the integral of <code>cube</code> between 0 and 1 is 1/4.)
</p>
<blockquote>
<p><strong><a id="Exercise-1_002e29"></a>Exercise 1.29:</strong> Simpson’s Rule is a more accurate
method of numerical integration than the method illustrated above.  Using
Simpson’s Rule, the integral of a function \( f \) between \( a \) and \( b \) is
approximated as

\[ % :20:
  
\frac{h}{3}(y_0 + {4y_1} + {2y_2} + {4y_3} + {2y_4} + \dots + {2y_{n-2}} + {4y_{n-1} + y_n),}
\]

where \( {h = (b - a)/n} \), for some even integer \( n \), and
\( y_k = {f(a + kh)} \).  (Increasing \( n \) increases the
accuracy of the approximation.)  Define a procedure that takes as arguments
\( f \), \( a \), \( b \), and \( n \) and returns the value of the integral, computed
using Simpson’s Rule.  Use your procedure to integrate <code>cube</code> between 0
and 1 (with \( {n = 100} \) and \( {n = 1000} \)), and compare the results to those of
the <code>integral</code> procedure shown above.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e30"></a>Exercise 1.30:</strong> The <code>sum</code> procedure above
generates a linear recursion.  The procedure can be rewritten so that the sum
is performed iteratively.  Show how to do this by filling in the missing
expressions in the following definition:
</p>
<div class="lisp">
<pre class="lisp">(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e31"></a>Exercise 1.31:</strong> 
</p>
<ol>
<li> The <code>sum</code> procedure is only the simplest of a vast number of similar
abstractions that can be captured as higher-order procedures.<a class="footnote_link" id="DOCF51" href="#FOOT51"><sup>51</sup></a>  Write an analogous
procedure called <code>product</code> that returns the product of the values of a
function at points over a given range.  Show how to define <code>factorial</code> in
terms of <code>product</code>.  Also use <code>product</code> to compute approximations to
\( \pi \) using the formula<a class="footnote_link" id="DOCF52" href="#FOOT52"><sup>52</sup></a>

\[ % :21:
  
\frac{\pi}{4} \,=\, {\frac{2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\cdot\cdots}
                     {3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\cdot\cdots}.}
\]

</li><li> If your <code>product</code> procedure generates a recursive process, write one that
generates an iterative process.  If it generates an iterative process, write
one that generates a recursive process.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e32"></a>Exercise 1.32:</strong> 
</p>
<ol>
<li> Show that <code>sum</code> and <code>product</code> (<a href="#Exercise-1_002e31">Exercise 1.31</a>) are both special
cases of a still more general notion called <code>accumulate</code> that combines a
collection of terms, using some general accumulation function:

<div class="lisp">
<pre class="lisp">(accumulate 
 combiner null-value term a next b)
</pre></div>

<p><code>Accumulate</code> takes as arguments the same term and range specifications as
<code>sum</code> and <code>product</code>, together with a <code>combiner</code> procedure (of
two arguments) that specifies how the current term is to be combined with the
accumulation of the preceding terms and a <code>null-value</code> that specifies what
base value to use when the terms run out.  Write <code>accumulate</code> and show how
<code>sum</code> and <code>product</code> can both be defined as simple calls to
<code>accumulate</code>.
</p>
</li><li> If your <code>accumulate</code> procedure generates a recursive process, write one
that generates an iterative process.  If it generates an iterative process,
write one that generates a recursive process.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-1_002e33"></a>Exercise 1.33:</strong> You can obtain an even more
general version of <code>accumulate</code> (<a href="#Exercise-1_002e32">Exercise 1.32</a>) by introducing the
notion of a <a id="index-filter"></a>
<em>filter</em> on the terms to be combined.  That is, combine
only those terms derived from values in the range that satisfy a specified
condition.  The resulting <code>filtered-accumulate</code> abstraction takes the same
arguments as accumulate, together with an additional predicate of one argument
that specifies the filter.  Write <code>filtered-accumulate</code> as a procedure.
Show how to express the following using <code>filtered-accumulate</code>:
</p>
<ol>
<li> the sum of the squares of the prime numbers in the interval \( a \) to \( b \)
(assuming that you have a <code>prime?</code> predicate already written)

</li><li> the product of all the positive integers less than \( n \) that are relatively
prime to \( n \) (i.e., all positive integers \( {i &lt; n} \) such that
\( {\text{GCD}(i, n) = 1} \)).

</li></ol>
</blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT49"><p><a class="footnote_backlink" href="#DOCF49"><sup>49</sup></a>
This series, usually
written in the equivalent form 
\( {\pi\over4} = {1 - {1\over3} + {1\over5}} - {{1\over7} + \dots} \), 
is due to Leibniz.  We’ll see how to use this as the basis for some
fancy numerical tricks in <a href="3_002e5_002e3.xhtml#g_t3_002e5_002e3">3.5.3</a>.</p>
</div>
<div id="FOOT50"><p><a class="footnote_backlink" href="#DOCF50"><sup>50</sup></a>
Notice that we have
used block structure (<a href="1_002e1_002e8.xhtml#g_t1_002e1_002e8">1.1.8</a>) to embed the definitions of
<code>pi-next</code> and <code>pi-term</code> within <code>pi-sum</code>, since these procedures
are unlikely to be useful for any other purpose.  We will see how to get rid of
them altogether in <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2">1.3.2</a>.</p>
</div>
<div id="FOOT51"><p><a class="footnote_backlink" href="#DOCF51"><sup>51</sup></a>
The
intent of <a href="#Exercise-1_002e31">Exercise 1.31</a> through <a href="#Exercise-1_002e33">Exercise 1.33</a> is to demonstrate the
expressive power that is attained by using an appropriate abstraction to
consolidate many seemingly disparate operations.  However, though accumulation
and filtering are elegant ideas, our hands are somewhat tied in using them at
this point since we do not yet have data structures to provide suitable means
of combination for these abstractions.  We will return to these ideas in
<a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a> when we show how to use <a id="index-sequences"></a>
<em>sequences</em> as interfaces
for combining filters and accumulators to build even more powerful
abstractions.  We will see there how these methods really come into their own
as a powerful and elegant approach to designing programs.</p>
</div>
<div id="FOOT52"><p><a class="footnote_backlink" href="#DOCF52"><sup>52</sup></a>
This formula was discovered by the
seventeenth-century English mathematician John Wallis.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="1_002e3_002e2.xhtml#g_t1_002e3_002e2" accesskey="n" rel="next">1.3.2</a>, Previous: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="p" rel="prev">1.3</a>, Up: <a href="1_002e3.xhtml#g_t1_002e3" accesskey="u" rel="prev">1.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
