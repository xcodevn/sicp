<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.2.3</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.2.3"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.2.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="2_002e2.xhtml#g_t2_002e2" rel="prev" title="2.2"/>
<link href="2_002e2_002e4.xhtml#g_t2_002e2_002e4" rel="next" title="2.2.4"/>
<link href="2_002e2_002e2.xhtml#g_t2_002e2_002e2" rel="prev" title="2.2.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t2_002e2_002e3"></a>
<nav class="header">
<p>
Next: <a href="2_002e2_002e4.xhtml#g_t2_002e2_002e4" accesskey="n" rel="next">2.2.4</a>, Previous: <a href="2_002e2_002e2.xhtml#g_t2_002e2_002e2" accesskey="p" rel="prev">2.2.2</a>, Up: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="u" rel="prev">2.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Sequences-as-Conventional-Interfaces"></a>
<h4 class="subsection"><span class="secnum">2.2.3</span><span class="sectitle">Sequences as Conventional Interfaces</span></h4>

<p>In working with compound data, we’ve stressed how data abstraction permits us
to design programs without becoming enmeshed in the details of data
representations, and how abstraction preserves for us the flexibility to
experiment with alternative representations.  In this section, we introduce
another powerful design principle for working with data structures—the use of
<a id="index-conventional-interfaces-1"></a>
<em>conventional interfaces</em>.
</p>
<p>In <a href="1_002e3.xhtml#g_t1_002e3">1.3</a> we saw how program abstractions, implemented as
higher-order procedures, can capture common patterns in programs that deal with
numerical data.  Our ability to formulate analogous operations for working with
compound data depends crucially on the style in which we manipulate our data
structures.  Consider, for example, the following procedure, analogous to the
<code>count-leaves</code> procedure of <a href="2_002e2_002e2.xhtml#g_t2_002e2_002e2">2.2.2</a>, which takes a tree as
argument and computes the sum of the squares of the leaves that are odd:
</p>
<div class="lisp">
<pre class="lisp">(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares 
                  (car tree))
                 (sum-odd-squares 
                  (cdr tree))))))
</pre></div>

<p>On the surface, this procedure is very different from the following one, which
constructs a list of all the even Fibonacci numbers \( {\text{Fib}(k)} \), where
\( k \) is less than or equal to a given integer \( n \):
</p>
<div class="lisp">
<pre class="lisp">(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
</pre></div>

<p>Despite the fact that these two procedures are structurally very different, a
more abstract description of the two computations reveals a great deal of
similarity.  The first program
</p>
<ul>
<li> enumerates the leaves of a tree;

</li><li> filters them, selecting the odd ones;

</li><li> squares each of the selected ones; and

</li><li> accumulates the results using <code>+</code>, starting with 0.

</li></ul>

<p>The second program
</p>
<ul>
<li> enumerates the integers from 0 to \( n \);

</li><li> computes the Fibonacci number for each integer;

</li><li> filters them, selecting the even ones; and

</li><li> accumulates the results using <code>cons</code>,  starting with the
empty list.

</li></ul>

<p>A signal-processing engineer would find it natural to conceptualize these
processes in terms of signals flowing through a cascade of stages, each of
which implements part of the program plan, as shown in <a href="#Figure-2_002e7">Figure 2.7</a>.  In
<code>sum-odd-squares</code>, we begin with an <a id="index-enumerator"></a>
<em>enumerator</em>, which generates
a “signal” consisting of the leaves of a given tree.  This signal is passed
through a <a id="index-filter-1"></a>
<em>filter</em>, which eliminates all but the odd elements.  The
resulting signal is in turn passed through a <a id="index-map"></a>
<em>map</em>, which is a
“transducer” that applies the <code>square</code> procedure to each element.  The
output of the map is then fed to an <a id="index-accumulator"></a>
<em>accumulator</em>, which combines the
elements using <code>+</code>, starting from an initial 0.  The plan for
<code>even-fibs</code> is analogous.
</p>
<figure class="float">
<a id="Figure-2_002e7"></a>
<object style="width: 57.93ex; height: 16.23ex;" data="fig/chap2/Fig2.7e.std.svg" type="image/svg+xml">SVG</object> 

<figcaption class="float-caption">
<p><strong>Figure 2.7:</strong> The signal-flow plans for the procedures <code>sum-odd-squares</code> (top) and <code>even-fibs</code> (bottom) reveal the commonality between the two programs.</p>
</figcaption>
</figure>

<p>Unfortunately, the two procedure definitions above fail to exhibit this
signal-flow structure.  For instance, if we examine the <code>sum-odd-squares</code>
procedure, we find that the enumeration is implemented partly by the
<code>null?</code> and <code>pair?</code> tests and partly by the tree-recursive structure
of the procedure.  Similarly, the accumulation is found partly in the tests and
partly in the addition used in the recursion.  In general, there are no
distinct parts of either procedure that correspond to the elements in the
signal-flow description.  Our two procedures decompose the computations in a
different way, spreading the enumeration over the program and mingling it with
the map, the filter, and the accumulation.  If we could organize our programs
to make the signal-flow structure manifest in the procedures we write, this
would increase the conceptual clarity of the resulting code.
</p>
<a id="Sequence-Operations"></a>
<h5 class="subsubheading">Sequence Operations</h5>

<p>The key to organizing programs so as to more clearly reflect the signal-flow
structure is to concentrate on the “signals” that flow from one stage in the
process to the next.  If we represent these signals as lists, then we can use
list operations to implement the processing at each of the stages.  For
instance, we can implement the mapping stages of the signal-flow diagrams using
the <code>map</code> procedure from <a href="2_002e2_002e1.xhtml#g_t2_002e2_002e1">2.2.1</a>:
</p>
<div class="lisp">
<pre class="lisp">(map square (list 1 2 3 4 5))
<i>(1 4 9 16 25)</i>
</pre></div>

<p>Filtering a sequence to select only those elements that satisfy a given
predicate is accomplished by
</p>
<div class="lisp">
<pre class="lisp">(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))
</pre></div>

<p>For example,
</p>
<div class="lisp">
<pre class="lisp">(filter odd? (list 1 2 3 4 5))
<i>(1 3 5)</i>
</pre></div>

<p>Accumulations can be implemented by
</p>
<div class="lisp">
<pre class="lisp">(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op 
                      initial 
                      (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))
<i>15</i>
(accumulate * 1 (list 1 2 3 4 5))
<i>120</i>
(accumulate cons nil (list 1 2 3 4 5))
<i>(1 2 3 4 5)</i>
</pre></div>

<p>All that remains to implement signal-flow diagrams is to enumerate the sequence
of elements to be processed.  For <code>even-fibs</code>, we need to generate the
sequence of integers in a given range, which we can do as follows:
</p>
<div class="lisp">
<pre class="lisp">(define (enumerate-interval low high)
  (if (&gt; low high)
      nil
      (cons low 
            (enumerate-interval 
             (+ low 1) 
             high))))

(enumerate-interval 2 7)
<i>(2 3 4 5 6 7)</i>
</pre></div>

<p>To enumerate the leaves of a tree, we can use<a class="footnote_link" id="DOCF80" href="#FOOT80"><sup>80</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append 
               (enumerate-tree (car tree))
               (enumerate-tree (cdr tree))))))

(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
<i>(1 2 3 4 5)</i>
</pre></div>

<p>Now we can reformulate <code>sum-odd-squares</code> and <code>even-fibs</code> as in the
signal-flow diagrams.  For <code>sum-odd-squares</code>, we enumerate the sequence of
leaves of the tree, filter this to keep only the odd numbers in the sequence,
square each element, and sum the results:
</p>
<div class="lisp">
<pre class="lisp">(define (sum-odd-squares tree)
  (accumulate 
   +
   0
   (map square
        (filter odd?
                (enumerate-tree tree)))))
</pre></div>

<p>For <code>even-fibs</code>, we enumerate the integers from 0 to \( n \), generate the
Fibonacci number for each of these integers, filter the resulting sequence to
keep only the even elements, and accumulate the results into a list:
</p>
<div class="lisp">
<pre class="lisp">(define (even-fibs n)
  (accumulate 
   cons
   nil
   (filter even?
           (map fib
                (enumerate-interval 0 n)))))
</pre></div>

<p>The value of expressing programs as sequence operations is that this helps us
make program designs that are modular, that is, designs that are constructed by
combining relatively independent pieces.  We can encourage modular design by
providing a library of standard components together with a conventional
interface for connecting the components in flexible ways.
</p>
<p>Modular construction is a powerful strategy for controlling complexity in
engineering design.  In real signal-processing applications, for example,
designers regularly build systems by cascading elements selected from
standardized families of filters and transducers.  Similarly, sequence
operations provide a library of standard program elements that we can mix and
match.  For instance, we can reuse pieces from the <code>sum-odd-squares</code> and
<code>even-fibs</code> procedures in a program that constructs a list of the squares
of the first \( {n + 1} \) Fibonacci numbers:
</p>
<div class="lisp">
<pre class="lisp">(define (list-fib-squares n)
  (accumulate 
   cons
   nil
   (map square
        (map fib
             (enumerate-interval 0 n)))))

(list-fib-squares 10)
<i>(0 1 1 4 9 25 64 169 441 1156 3025)</i>
</pre></div>

<p>We can rearrange the pieces and use them in computing the product of the squares of the odd
integers in a sequence:
</p>
<div class="lisp">
<pre class="lisp">(define 
  (product-of-squares-of-odd-elements
   sequence)
  (accumulate 
   *
   1
   (map square (filter odd? sequence))))

(product-of-squares-of-odd-elements 
 (list 1 2 3 4 5))
<i>225</i>
</pre></div>

<p>We can also formulate conventional data-processing applications in terms of
sequence operations.  Suppose we have a sequence of personnel records and we
want to find the salary of the highest-paid programmer.  Assume that we have a
selector <code>salary</code> that returns the salary of a record, and a predicate
<code>programmer?</code> that tests if a record is for a programmer.  Then we can
write
</p>
<div class="lisp">
<pre class="lisp">(define 
  (salary-of-highest-paid-programmer
   records)
  (accumulate 
   max
   0
   (map salary
        (filter programmer? records))))
</pre></div>

<p>These examples give just a hint of the vast range of operations that can be
expressed as sequence operations.<a class="footnote_link" id="DOCF81" href="#FOOT81"><sup>81</sup></a>
</p>
<p>Sequences, implemented here as lists, serve as a conventional interface that
permits us to combine processing modules.  Additionally, when we uniformly
represent structures as sequences, we have localized the data-structure
dependencies in our programs to a small number of sequence operations.  By
changing these, we can experiment with alternative representations of
sequences, while leaving the overall design of our programs intact.  We will
exploit this capability in <a href="3_002e5.xhtml#g_t3_002e5">3.5</a>, when we generalize the
sequence-processing paradigm to admit infinite sequences.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e33"></a>Exercise 2.33:</strong> Fill in the missing expressions
to complete the following definitions of some basic list-manipulation
operations as accumulations:
</p>
<div class="lisp">
<pre class="lisp">(define (map p sequence)
  (accumulate (lambda (x y) ⟨??⟩) 
              nil sequence))

(define (append seq1 seq2)
  (accumulate cons ⟨??⟩ ⟨??⟩))

(define (length sequence)
  (accumulate ⟨??⟩ 0 sequence))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e34"></a>Exercise 2.34:</strong> Evaluating a polynomial in \( x \)
at a given value of \( x \) can be formulated as an accumulation.  We evaluate
the polynomial
\[ % :35:
  {a_n x^n} + {a_{n-1} x^{n-1}} + \dots + {a_1 x} + a_0  \]
using a well-known algorithm called <a id="index-Horner_0027s-rule"></a>
<em>Horner’s rule</em>, which structures
the computation as
\[ % :36:
  {(\dots (a_n x} + {a_{n-1}) x} + \dots + {a_1) x} + {a_0.}  \]
In other words, we start with \( a_n \), multiply by \( x \), add
\( a_{n-1} \), multiply by \( x \), and so on, until we reach
\( a_0 \).<a class="footnote_link" id="DOCF82" href="#FOOT82"><sup>82</sup></a>
</p>
<p>Fill in the following template to produce a procedure that evaluates a
polynomial using Horner’s rule.  Assume that the coefficients of the polynomial
are arranged in a sequence, from \( a_0 \) through \( a_n \).
</p>
<div class="lisp">
<pre class="lisp">(define 
  (horner-eval x coefficient-sequence)
  (accumulate 
   (lambda (this-coeff higher-terms)
     ⟨??⟩)
   0
   coefficient-sequence))
</pre></div>

<p>For example, to compute \( {1 + 3x} + {5x^3 + x^5} \) at \( {x = 2} \) you
would evaluate
</p>
<div class="lisp">
<pre class="lisp">(horner-eval 2 (list 1 3 0 5 0 1))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e35"></a>Exercise 2.35:</strong> Redefine <code>count-leaves</code> from
<a href="2_002e2_002e2.xhtml#g_t2_002e2_002e2">2.2.2</a> as an accumulation:
</p>
<div class="lisp">
<pre class="lisp">(define (count-leaves t)
  (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e36"></a>Exercise 2.36:</strong> The procedure <code>accumulate-n</code>
is similar to <code>accumulate</code> except that it takes as its third argument a
sequence of sequences, which are all assumed to have the same number of
elements.  It applies the designated accumulation procedure to combine all the
first elements of the sequences, all the second elements of the sequences, and
so on, and returns a sequence of the results.  For instance, if <code>s</code> is a
sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11
12)),</code> then the value of <code>(accumulate-n + 0 s)</code> should be the sequence
<code>(22 26 30)</code>.  Fill in the missing expressions in the following definition
of <code>accumulate-n</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init ⟨??⟩)
            (accumulate-n op init ⟨??⟩))))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e37"></a>Exercise 2.37:</strong>
Suppose we represent vectors <b>v</b>&#160;=&#160;\( (v_i) \)<!-- /@w --> as sequences of numbers, and
matrices <b>m</b>&#160;=&#160;\( (m_{ij}) \)<!-- /@w --> as sequences of vectors (the rows of the
matrix).  For example, the matrix
\[ % :37:
  
\left(\matrix{	1 &amp; 2 &amp; 3 &amp; 4 \cr
		4 &amp; 5 &amp; 6 &amp; 6 \cr
		6 &amp; 7 &amp; 8 &amp; 9 \cr }\right)  \]
is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>.  With
this representation, we can use sequence operations to concisely express the
basic matrix and vector operations.  These operations (which are described in
any book on matrix algebra) are the following:
\[ % :38:
  
\eqalign{ 
	{\tt (dot-product\kern1ex v\kern1ex w)} 		&amp;\; {\rm returns\;the\;sum\;} 
		\Sigma_i v_i w_i; \cr
	{\tt (matrix-*-vector\kern1ex m\kern1ex v)} 	&amp;\; {\rm returns\;the\;vector\;} {\bf t}, \cr
		&amp;\; {\rm where\;} t_i = \Sigma_j m_{ij} v_j; \cr
	{\tt (matrix-*-matrix\kern1ex m\kern1ex n)} 	&amp;\; {\rm returns\;the\;matrix\;} {\bf p}, \cr
		&amp;\; {\rm where\;} p_{ij} = \Sigma_k m_{ik} n_{kj}; \cr
	{\tt (transpose\kern1ex m)} 			&amp;\; {\rm returns\;the\;matrix\;} {\bf n}, \cr 
		&amp;\; {\rm where\;} n_{ij} = m_{ji}. \cr
}  \]
We can define the dot product as<a class="footnote_link" id="DOCF83" href="#FOOT83"><sup>83</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</pre></div>

<p>Fill in the missing expressions in the following procedures for computing the
other matrix operations.  (The procedure <code>accumulate-n</code> is defined in
<a href="#Exercise-2_002e36">Exercise 2.36</a>.)
</p>
<div class="lisp">
<pre class="lisp">(define (matrix-*-vector m v)
  (map ⟨??⟩ m))

(define (transpose mat)
  (accumulate-n ⟨??⟩ ⟨??⟩ mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ⟨??⟩ m)))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e38"></a>Exercise 2.38:</strong> The <code>accumulate</code> procedure
is also known as <code>fold-right</code>, because it combines the first element of
the sequence with the result of combining all the elements to the right.  There
is also a <code>fold-left</code>, which is similar to <code>fold-right</code>, except that
it combines elements working in the opposite direction:
</p>
<div class="lisp">
<pre class="lisp">(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre></div>

<p>What are the values of
</p>
<div class="lisp">
<pre class="lisp">(fold-right / 1 (list 1 2 3))
(fold-left  / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left  list nil (list 1 2 3))
</pre></div>

<p>Give a property that <code>op</code> should satisfy to guarantee that
<code>fold-right</code> and <code>fold-left</code> will produce the same values for any
sequence.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e39"></a>Exercise 2.39:</strong> Complete the following
definitions of <code>reverse</code> (<a href="2_002e2_002e1.xhtml#Exercise-2_002e18">Exercise 2.18</a>) in terms of
<code>fold-right</code> and <code>fold-left</code> from <a href="#Exercise-2_002e38">Exercise 2.38</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (reverse sequence)
  (fold-right 
   (lambda (x y) ⟨??⟩) nil sequence))

(define (reverse sequence)
  (fold-left 
   (lambda (x y) ⟨??⟩) nil sequence))
</pre></div>
</blockquote>

<a id="Nested-Mappings"></a>
<h5 class="subsubheading">Nested Mappings</h5>

<p>We can extend the sequence paradigm to include many computations that are
commonly expressed using nested loops.<a class="footnote_link" id="DOCF84" href="#FOOT84"><sup>84</sup></a> Consider this problem: Given a positive integer \( n \), find all
ordered pairs of distinct positive integers \( i \) and \( j \), where 
\( {1 \le j} &lt; {i \le n} \), such that \( {i + j} \) is prime.  For example, if \( n \) is 6,
then the pairs are the following:
\[ % :39:
 
\begin{array}{c|ccccccc}
i 	&amp; 2 &amp; 3 &amp; 4 &amp; 4 &amp; 5 &amp; 6 &amp; 6 \\
j 	&amp; 1 &amp; 2 &amp; 1 &amp; 3 &amp; 2 &amp; 1 &amp; 5 \\
\hline
i + j	&amp; 3 &amp; 5 &amp; 5 &amp; 7 &amp; 7 &amp; 7 &amp; 11 
\end{array}
\]
A natural way to organize this computation is to generate the sequence of all
ordered pairs of positive integers less than or equal to \( n \), filter to
select those pairs whose sum is prime, and then, for each pair \( {(i, j)} \)
that passes through the filter, produce the triple \( {(i, j, i + j)} \).
</p>
<p>Here is a way to generate the sequence of pairs: For each integer \( {i \le n} \), 
enumerate the integers \( {j &lt; i} \), and for each such \( i \) and \( j \)
generate the pair \( {(i, j)} \).  In terms of sequence operations, we map along
the sequence <code>(enumerate-interval 1 n)</code>.  For each \( i \) in this sequence,
we map along the sequence <code>(enumerate-interval 1 (- i 1))</code>.  For each
\( j \) in this latter sequence, we generate the pair <code>(list i j)</code>.  This
gives us a sequence of pairs for each \( i \).  Combining all the sequences for
all the \( i \) (by accumulating with <code>append</code>) produces the required
sequence of pairs:<a class="footnote_link" id="DOCF85" href="#FOOT85"><sup>85</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(accumulate 
 append
 nil
 (map (lambda (i)
        (map (lambda (j) 
               (list i j))
             (enumerate-interval 1 (- i 1))))
      (enumerate-interval 1 n)))
</pre></div>

<p>The combination of mapping and accumulating with <code>append</code> is so common in
this sort of program that we will isolate it as a separate procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
</pre></div>

<p>Now filter this sequence of pairs to find those whose sum is prime. The filter
predicate is called for each element of the sequence; its argument is a pair
and it must extract the integers from the pair.  Thus, the predicate to apply
to each element in the sequence is
</p>
<div class="lisp">
<pre class="lisp">(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
</pre></div>

<p>Finally, generate the sequence of results by mapping over the filtered pairs
using the following procedure, which constructs a triple consisting of the two
elements of the pair along with their sum:
</p>
<div class="lisp">
<pre class="lisp">(define (make-pair-sum pair)
  (list (car pair) 
        (cadr pair) 
        (+ (car pair) (cadr pair))))
</pre></div>

<p>Combining all these steps yields the complete procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter 
        prime-sum?
        (flatmap
         (lambda (i)
           (map (lambda (j) 
                  (list i j))
                (enumerate-interval 
                 1 
                 (- i 1))))
         (enumerate-interval 1 n)))))
</pre></div>

<p>Nested mappings are also useful for sequences other than those that enumerate
intervals.  Suppose we wish to generate all the permutations of a set \( {S;} \)
that is, all the ways of ordering the items in the set.  For instance, the
permutations of \( {\{1, 2, 3\}} \) are \( {\{1, 2, 3\}} \), \( {\{1, 3, 2\}} \), \( {\{2, 1, 3\}} \), \( {\{2, 3, 1\}} \),
\( {\{3, 1, 2\}} \), and \( {\{3, 2, 1\}} \).  Here is a plan for generating the permutations of
\( S \): For each item \( x \) in \( S \), recursively generate the sequence of
permutations of \( {S - x} \),<a class="footnote_link" id="DOCF86" href="#FOOT86"><sup>86</sup></a> and adjoin \( x \) to the front of each one.
This yields, for each \( x \) in \( S \), the sequence of permutations of \( S \)
that begin with \( x \).  Combining these sequences for all \( x \) gives all the
permutations of \( S \):<a class="footnote_link" id="DOCF87" href="#FOOT87"><sup>87</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (permutations s)
  (if (null? s)   <span class="roman">; empty set?</span>
      (list nil)  <span class="roman">; sequence containing empty set</span>
      (flatmap (lambda (x)
                 (map (lambda (p) 
                        (cons x p))
                      (permutations 
                       (remove x s))))
               s)))
</pre></div>

<p>Notice how this strategy reduces the problem of generating permutations of
\( S \) to the problem of generating the permutations of sets with fewer elements
than \( S \).  In the terminal case, we work our way down to the empty list,
which represents a set of no elements.  For this, we generate <code>(list
nil)</code>, which is a sequence with one item, namely the set with no elements.  The
<code>remove</code> procedure used in <code>permutations</code> returns all the items in a
given sequence except for a given item.  This can be expressed as a simple
filter:
</p>
<div class="lisp">
<pre class="lisp">(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-2_002e40"></a>Exercise 2.40:</strong> Define a procedure
<code>unique-pairs</code> that, given an integer \( n \), generates the sequence of
pairs \( {(i, j)} \) with \( {1 \le j} &lt; {i \le n} \).  Use <code>unique-pairs</code>
to simplify the definition of <code>prime-sum-pairs</code> given above.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e41"></a>Exercise 2.41:</strong> Write a procedure to find all
ordered triples of distinct positive integers \( i \), \( j \), and \( k \) less than
or equal to a given integer \( n \) that sum to a given integer \( s \).
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e42"></a>Exercise 2.42:</strong> The “eight-queens puzzle” asks
how to place eight queens on a chessboard so that no queen is in check from any
other (i.e., no two queens are in the same row, column, or diagonal).  One
possible solution is shown in <a href="#Figure-2_002e8">Figure 2.8</a>.  One way to solve the puzzle is
to work across the board, placing a queen in each column.  Once we have placed
\( {k - 1} \) queens, we must place the \( k^{\text{th}} \) queen in a position where it does
not check any of the queens already on the board.  We can formulate this
approach recursively: Assume that we have already generated the sequence of all
possible ways to place \( {k - 1} \) queens in the first \( {k - 1} \) columns of the
board.  For each of these ways, generate an extended set of positions by
placing a queen in each row of the \( k^{\text{th}} \) column.  Now filter these, keeping
only the positions for which the queen in the \( k^{\text{th}} \) column is safe with
respect to the other queens.  This produces the sequence of all ways to place
\( k \) queens in the first \( k \) columns.  By continuing this process, we will
produce not only one solution, but all solutions to the puzzle.
</p>
<figure class="float">
<a id="Figure-2_002e8"></a>
<object style="width: 33.41ex; height: 33.41ex;" data="fig/chap2/Fig2.8c.std.svg" type="image/svg+xml">SVG</object>

<figcaption class="float-caption">
<p><strong>Figure 2.8:</strong> A solution to the eight-queens puzzle.</p>
</figcaption>
</figure>
</blockquote>

<p>We implement this solution as a procedure <code>queens</code>, which returns a
sequence of all solutions to the problem of placing \( n \) queens on an
\( {n \times n} \) chessboard.  <code>Queens</code> has an internal procedure
<code>queen-cols</code> that returns the sequence of all ways to place queens in the
first \( k \) columns of the board.
</p>
<div class="lisp">
<pre class="lisp">(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) 
           (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position 
                    new-row 
                    k 
                    rest-of-queens))
                 (enumerate-interval 
                  1 
                  board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</pre></div>

<p>In this procedure <code>rest-of-queens</code> is a way to place \( {k - 1} \) queens in
the first \( {k - 1} \) columns, and <code>new-row</code> is a proposed row in which to
place the queen for the \( k^{\text{th}} \) column.  Complete the program by implementing
the representation for sets of board positions, including the procedure
<code>adjoin-position</code>, which adjoins a new row-column position to a set of
positions, and <code>empty-board</code>, which represents an empty set of positions.
You must also write the procedure <code>safe?</code>, which determines for a set of
positions, whether the queen in the \( k^{\text{th}} \) column is safe with respect to the
others.  (Note that we need only check whether the new queen is safe—the
other queens are already guaranteed safe with respect to each other.)
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e43"></a>Exercise 2.43:</strong> Louis Reasoner is having a
terrible time doing <a href="#Exercise-2_002e42">Exercise 2.42</a>.  His <code>queens</code> procedure seems to
work, but it runs extremely slowly.  (Louis never does manage to wait long
enough for it to solve even the \( {6\times6} \) case.)  When Louis asks Eva Lu Ator for
help, she points out that he has interchanged the order of the nested mappings
in the <code>flatmap</code>, writing it as
</p>
<div class="lisp">
<pre class="lisp">(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position 
           new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</pre></div>

<p>Explain why this interchange makes the program run slowly.  Estimate how long
it will take Louis’s program to solve the eight-queens puzzle, assuming that
the program in <a href="#Exercise-2_002e42">Exercise 2.42</a> solves the puzzle in time \( T \).
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT80"><p><a class="footnote_backlink" href="#DOCF80"><sup>80</sup></a>
This is, in fact,
precisely the <code>fringe</code> procedure from <a href="2_002e2_002e2.xhtml#Exercise-2_002e28">Exercise 2.28</a>.  Here we’ve
renamed it to emphasize that it is part of a family of general
sequence-manipulation procedures.</p>
</div>
<div id="FOOT81"><p><a class="footnote_backlink" href="#DOCF81"><sup>81</sup></a>
Richard <a href="References.xhtml#Waters-_00281979_0029">Waters (1979)</a> developed a
program that automatically analyzes traditional Fortran programs, viewing them
in terms of maps, filters, and accumulations.  He found that fully 90 percent
of the code in the Fortran Scientific Subroutine Package fits neatly into this
paradigm.  One of the reasons for the success of Lisp as a programming language
is that lists provide a standard medium for expressing ordered collections so
that they can be manipulated using higher-order operations.  The programming
language APL owes much of its power and appeal to a similar choice. In APL all
data are represented as arrays, and there is a universal and convenient set of
generic operators for all sorts of array operations.</p>
</div>
<div id="FOOT82"><p><a class="footnote_backlink" href="#DOCF82"><sup>82</sup></a>
According to <a href="References.xhtml#Knuth-1981">Knuth 1981</a>, this rule was formulated by
W. G. Horner early in the nineteenth century, but the method was actually used
by Newton over a hundred years earlier.  Horner’s rule evaluates the polynomial
using fewer additions and multiplications than does the straightforward method
of first computing \( {a_n x^n} \), then adding
\( {a_{n-1}x^{n-1}} \), and so on.  In fact, it is possible to prove
that any algorithm for evaluating arbitrary polynomials must use at least as
many additions and multiplications as does Horner’s rule, and thus Horner’s
rule is an optimal algorithm for polynomial evaluation.  This was proved (for
the number of additions) by A. M. Ostrowski in a 1954 paper that essentially
founded the modern study of optimal algorithms.  The analogous statement for
multiplications was proved by V. Y. Pan in 1966.  The book by <a href="References.xhtml#Borodin-and-Munro-_00281975_0029">Borodin and Munro (1975)</a> 
provides an overview of these and other results about optimal
algorithms.</p>
</div>
<div id="FOOT83"><p><a class="footnote_backlink" href="#DOCF83"><sup>83</sup></a>
This definition uses the extended
version of <code>map</code> described in <a href="2_002e2_002e1.xhtml#Footnote-78">Footnote 78</a>.</p>
</div>
<div id="FOOT84"><p><a class="footnote_backlink" href="#DOCF84"><sup>84</sup></a>
This approach to nested
mappings was shown to us by David Turner, whose languages KRC and Miranda
provide elegant formalisms for dealing with these constructs.  The examples in
this section (see also <a href="#Exercise-2_002e42">Exercise 2.42</a>) are adapted from <a href="References.xhtml#Turner-1981">Turner 1981</a>.  In
<a href="3_002e5_002e3.xhtml#g_t3_002e5_002e3">3.5.3</a>, we’ll see how this approach generalizes to infinite
sequences.</p>
</div>
<div id="FOOT85"><p><a class="footnote_backlink" href="#DOCF85"><sup>85</sup></a>
We’re representing a pair here as a list of two
elements rather than as a Lisp pair.  Thus, the “pair” \( {(i, j)} \) is
represented as <code>(list i j)</code>, not <code>(cons i j)</code>.</p>
</div>
<div id="FOOT86"><p><a class="footnote_backlink" href="#DOCF86"><sup>86</sup></a>
The set \( {S - x} \) is the set of all
elements of \( S \), excluding \( x \).</p>
</div>
<div id="FOOT87"><p><a class="footnote_backlink" href="#DOCF87"><sup>87</sup></a>
Semicolons in Scheme code are used to introduce
<a id="index-comments"></a>
<em>comments</em>.  Everything from the semicolon to the end of the line is
ignored by the interpreter.  In this book we don’t use many comments; we try to
make our programs self-documenting by using descriptive names.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="2_002e2_002e4.xhtml#g_t2_002e2_002e4" accesskey="n" rel="next">2.2.4</a>, Previous: <a href="2_002e2_002e2.xhtml#g_t2_002e2_002e2" accesskey="p" rel="prev">2.2.2</a>, Up: <a href="2_002e2.xhtml#g_t2_002e2" accesskey="u" rel="prev">2.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
