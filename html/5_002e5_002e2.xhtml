<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.2</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.2"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5"/>
<link href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" rel="next" title="5.5.3"/>
<link href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" rel="prev" title="5.5.1"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e2"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="n" rel="next">5.5.3</a>, Previous: <a href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" accesskey="p" rel="prev">5.5.1</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Compiling-Expressions"></a>
<h4 class="subsection"><span class="secnum">5.5.2</span><span class="sectitle">Compiling Expressions</span></h4>

<p>In this section and the next we implement the code generators to which the
<code>compile</code> procedure dispatches.
</p>
<a id="Compiling-linkage-code"></a>
<h5 class="subsubheading">Compiling linkage code</h5>

<p>In general, the output of each code generator will end with
instructions—generated by the procedure <code>compile-linkage</code>—that
implement the required linkage.  If the linkage is <code>return</code> then we must
generate the instruction <code>(goto (reg continue))</code>.  This needs the
<code>continue</code> register and does not modify any registers.  If the linkage is
<code>next</code>, then we needn’t include any additional instructions.  Otherwise,
the linkage is a label, and we generate a <code>goto</code> to that label, an
instruction that does not need or modify any registers.<a class="footnote_link" id="DOCF321" href="#FOOT321"><sup>321</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence 
          '(continue)
          '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
</pre></div>

<p>The linkage code is appended to an instruction sequence by <code>preserving</code>
the <code>continue</code> register, since a <code>return</code> linkage will require the
<code>continue</code> register: If the given instruction sequence modifies
<code>continue</code> and the linkage code needs it, <code>continue</code> will be saved
and restored.
</p>
<div class="lisp">
<pre class="lisp">(define (end-with-linkage 
         linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
</pre></div>

<a id="Compiling-simple-expressions"></a>
<h5 class="subsubheading">Compiling simple expressions</h5>

<p>The code generators for self-evaluating expressions, quotations, and variables
construct instruction sequences that assign the required value to the target
register and then proceed as specified by the linkage descriptor.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-self-evaluating 
         exp target linkage)
  (end-with-linkage
   linkage (make-instruction-sequence 
            '()
            (list target)
            `((assign ,target (const ,exp))))))

(define (compile-quoted exp target linkage)
  (end-with-linkage
   linkage
   (make-instruction-sequence
    '()
    (list target)
    `((assign 
       ,target
       (const ,(text-of-quotation exp)))))))

(define (compile-variable
         exp target linkage)
  (end-with-linkage 
   linkage
   (make-instruction-sequence 
    '(env)
    (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
</pre></div>

<p>All these assignment instructions modify the target register, and the one that
looks up a variable needs the <code>env</code> register.
</p>
<p>Assignments and definitions are handled much as they are in the interpreter.
We recursively generate code that computes the value to be assigned to the
variable, and append to it a two-instruction sequence that actually sets or
defines the variable and assigns the value of the whole expression (the symbol
<code>ok</code>) to the target register.  The recursive compilation has target
<code>val</code> and linkage <code>next</code> so that the code will put its result into
<code>val</code> and continue with the code that is appended after it.  The appending
is done preserving <code>env</code>, since the environment is needed for setting or
defining the variable and the code for the variable value could be the
compilation of a complex expression that might modify the registers in
arbitrary ways.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-assignment 
         exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 
                  'val
                  'next)))
    (end-with-linkage 
     linkage
     (preserving 
      '(env)
      get-value-code
      (make-instruction-sequence
       '(env val)
       (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))

(define (compile-definition 
         exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp)
                  'val
                  'next)))
    (end-with-linkage
     linkage
     (preserving 
      '(env)
      get-value-code
      (make-instruction-sequence
       '(env val)
       (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
</pre></div>

<p>The appended two-instruction sequence requires <code>env</code> and <code>val</code> and
modifies the target.  Note that although we preserve <code>env</code> for this
sequence, we do not preserve <code>val</code>, because the <code>get-value-code</code> is
designed to explicitly place its result in <code>val</code> for use by this sequence.
(In fact, if we did preserve <code>val</code>, we would have a bug, because this
would cause the previous contents of <code>val</code> to be restored right after the
<code>get-value-code</code> is run.)
</p>
<a id="Compiling-conditional-expressions"></a>
<h5 class="subsubheading">Compiling conditional expressions</h5>

<p>The code for an <code>if</code> expression compiled with a given target and linkage
has the form
</p>
<div class="lisp">
<pre class="lisp">⟨<em>compilation of predicate, 
 target <code>val</code>, linkage <code>next</code></em>⟩
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 ⟨<em>compilation of consequent with given 
  target and given linkage or <code>after-if</code></em>⟩
false-branch
 ⟨<em>compilation of alternative 
  with given target and linkage</em>⟩
after-if
</pre></div>

<p>To generate this code, we compile the predicate, consequent, and alternative,
and combine the resulting code with instructions to test the predicate result
and with newly generated labels to mark the true and false branches and the end
of the conditional.<a class="footnote_link" id="DOCF322" href="#FOOT322"><sup>322</sup></a> In this arrangement of code, we must branch around the true branch if the
test is false.  The only slight complication is in how the linkage for the true
branch should be handled.  If the linkage for the conditional is <code>return</code>
or a label, then the true and false branches will both use this same linkage.
If the linkage is <code>next</code>, the true branch ends with a jump around the code
for the false branch to the label at the end of the conditional.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) 
               after-if
               linkage)))
      (let ((p-code 
             (compile (if-predicate exp)
                      'val
                      'next))
            (c-code
             (compile (if-consequent exp) 
                      target 
                      consequent-linkage))
            (a-code
             (compile (if-alternative exp)
                      target
                      linkage)))
        (preserving 
         '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence 
           '(val) 
           '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences 
            t-branch c-code)
           (append-instruction-sequences
            f-branch a-code))
          after-if))))))
</pre></div>

<p><code>Env</code> is preserved around the predicate code because it could be needed by
the true and false branches, and <code>continue</code> is preserved because it could
be needed by the linkage code in those branches.  The code for the true and
false branches (which are not executed sequentially) is appended using a
special combiner <code>parallel-instruction-sequences</code> described in 
<a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4">5.5.4</a>.
</p>
<p>Note that <code>cond</code> is a derived expression, so all that the compiler needs
to do handle it is to apply the <code>cond-&gt;if</code> transformer (from 
<a href="4_002e1_002e2.xhtml#g_t4_002e1_002e2">4.1.2</a>) and compile the resulting <code>if</code> expression.
</p>
<a id="Compiling-sequences"></a>
<h5 class="subsubheading">Compiling sequences</h5>

<p>The compilation of sequences (from procedure bodies or explicit <code>begin</code>
expressions) parallels their evaluation.  Each expression of the sequence is
compiled—the last expression with the linkage specified for the sequence, and
the other expressions with linkage <code>next</code> (to execute the rest of the
sequence).  The instruction sequences for the individual expressions are
appended to form a single instruction sequence, such that <code>env</code> (needed
for the rest of the sequence) and <code>continue</code> (possibly needed for the
linkage at the end of the sequence) are preserved.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq)
                         target
                         linkage))))
</pre></div>

<a id="Compiling-lambda-expressions"></a>
<h5 class="subsubheading">Compiling <code>lambda</code> expressions</h5>

<p><code>Lambda</code> expressions construct procedures.  The object code for a
<code>lambda</code> expression must have the form
</p>
<div class="lisp">
<pre class="lisp">⟨<em>construct procedure object 
 and assign it to target register</em>⟩
⟨<var>linkage</var>⟩
</pre></div>

<p>When we compile the <code>lambda</code> expression, we also generate the code for the
procedure body.  Although the body won’t be executed at the time of procedure
construction, it is convenient to insert it into the object code right after
the code for the <code>lambda</code>.  If the linkage for the <code>lambda</code>
expression is a label or <code>return</code>, this is fine.  But if the linkage is
<code>next</code>, we will need to skip around the code for the procedure body by
using a linkage that jumps to a label that is inserted after the body.  The
object code thus has the form
</p>
<div class="lisp">
<pre class="lisp">⟨<em>construct procedure object 
 and assign it to target register</em>⟩
 ⟨<em>code for given linkage</em>⟩ <em>or</em> 
  <code>(goto (label after-lambda))</code>
 ⟨<em>compilation of procedure body</em>⟩
after-lambda
</pre></div>

<p><code>Compile-lambda</code> generates the code for constructing the procedure object
followed by the code for the procedure body.  The procedure object will be
constructed at run time by combining the current environment (the environment
at the point of definition) with the entry point to the compiled procedure body
(a newly generated label).<a class="footnote_link" id="DOCF323" href="#FOOT323"><sup>323</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (compile-lambda exp target linkage)
  (let ((proc-entry 
         (make-label 'entry))
        (after-lambda 
         (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next)
               after-lambda
               linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage 
         lambda-linkage
         (make-instruction-sequence 
          '(env)
          (list target)
          `((assign 
             ,target
             (op make-compiled-procedure)
             (label ,proc-entry)
             (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
</pre></div>

<p><code>Compile-lambda</code> uses the special combiner
<code>tack-on-instruction-sequence</code> rather than
<code>append-instruction-sequences</code> (<a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4">5.5.4</a>) to append the procedure body to the
<code>lambda</code> expression code, because the body is not part of the sequence of
instructions that will be executed when the combined sequence is entered;
rather, it is in the sequence only because that was a convenient place to put
it.
</p>
<p><code>Compile-lambda-body</code> constructs the code for the body of the procedure.
This code begins with a label for the entry point.  Next come instructions that
will cause the run-time evaluation environment to switch to the correct
environment for evaluating the procedure body—namely, the definition
environment of the procedure, extended to include the bindings of the formal
parameters to the arguments with which the procedure is called.  After this
comes the code for the sequence of expressions that makes up the procedure
body.  The sequence is compiled with linkage <code>return</code> and target
<code>val</code> so that it will end by returning from the procedure with the
procedure result in <code>val</code>.
</p>
<div class="lisp">
<pre class="lisp">(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence 
      '(env proc argl)
      '(env)
      `(,proc-entry
        (assign env 
                (op compiled-procedure-env)
                (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp)
                       'val
                       'return))))
</pre></div>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT321"><p><a class="footnote_backlink" href="#DOCF321"><sup>321</sup></a>
This procedure
uses a feature of Lisp called <a id="index-backquote"></a>
<em>backquote</em> (or <a id="index-quasiquote"></a>
<em>quasiquote</em>)
that is handy for constructing lists.  Preceding a list with a backquote symbol
is much like quoting it, except that anything in the list that is flagged with
a comma is evaluated.
</p>
<p>For example, if the value of <code>linkage</code> is the symbol <code>branch25</code>,
then the expression 
</p>
<div class="lisp">
<pre class="lisp">`((goto (label ,linkage)))
</pre></div>

<p>evaluates to the list 
</p>	
<div class="lisp">
<pre class="lisp">((goto (label branch25))) 
</pre></div>

<p>Similarly, if the value of <code>x</code> is the list <code>(a b c)</code>, then 
</p>
<div class="lisp">
<pre class="lisp">`(1 2 ,(car x)) 
</pre></div>

<p>evaluates to the list 
</p>
<div class="lisp">
<pre class="lisp">(1 2 a)
</pre></div>
</div>
<div id="FOOT322"><p><a class="footnote_backlink" href="#DOCF322"><sup>322</sup></a>
We can’t just use the labels <code>true-branch</code>,
<code>false-branch</code>, and <code>after-if</code> as shown above, because there might be
more than one <code>if</code> in the program.  The compiler uses the procedure
<code>make-label</code> to generate labels.  <code>Make-label</code> takes a symbol as
argument and returns a new symbol that begins with the given symbol.  For
example, successive calls to <code>(make-label 'a)</code> would return <code>a1</code>,
<code>a2</code>, and so on.  <code>Make-label</code> can be implemented similarly to the
generation of unique variable names in the query language, as follows:
</p>
<div class="lisp">
<pre class="lisp">(define label-counter 0)

(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)

(define (make-label name)
  (string-&gt;symbol
   (string-append 
    (symbol-&gt;string name)
    (number-&gt;string (new-label-number)))))
</pre></div>
</div>
<div id="FOOT323"><p><a class="footnote_backlink" href="#DOCF323"><sup>323</sup></a>
<a id="Footnote-323"></a>We need
machine operations to implement a data structure for representing compiled
procedures, analogous to the structure for compound procedures described in
<a href="4_002e1_002e3.xhtml#g_t4_002e1_002e3">4.1.3</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))
(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))
(define (compiled-procedure-entry c-proc) 
  (cadr c-proc))
(define (compiled-procedure-env c-proc)
  (caddr c-proc))
</pre></div>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="5_002e5_002e3.xhtml#g_t5_002e5_002e3" accesskey="n" rel="next">5.5.3</a>, Previous: <a href="5_002e5_002e1.xhtml#g_t5_002e5_002e1" accesskey="p" rel="prev">5.5.1</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
