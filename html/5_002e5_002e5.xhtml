<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.5</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.5"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.5.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e5.xhtml#g_t5_002e5" rel="prev" title="5.5"/>
<link href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" rel="next" title="5.5.6"/>
<link href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" rel="prev" title="5.5.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e5_002e5"></a>
<nav class="header">
<p>
Next: <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" accesskey="n" rel="next">5.5.6</a>, Previous: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="p" rel="prev">5.5.4</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="An-Example-of-Compiled-Code"></a>
<h4 class="subsection"><span class="secnum">5.5.5</span><span class="sectitle">An Example of Compiled Code</span></h4>

<p>Now that we have seen all the elements of the compiler, let us examine an
example of compiled code to see how things fit together.  We will compile the
definition of a recursive <code>factorial</code> procedure by calling <code>compile</code>:
</p>
<div class="lisp">
<pre class="lisp">(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
</pre></div>

<p>We have specified that the value of the <code>define</code> expression should be
placed in the <code>val</code> register.  We don’t care what the compiled code does
after executing the <code>define</code>, so our choice of <code>next</code> as the linkage
descriptor is arbitrary.
</p>
<p><code>Compile</code> determines that the expression is a definition, so it calls
<code>compile-definition</code> to compile code to compute the value to be assigned
(targeted to <code>val</code>), followed by code to install the definition, followed
by code to put the value of the <code>define</code> (which is the symbol <code>ok</code>)
into the target register, followed finally by the linkage code.  <code>Env</code> is
preserved around the computation of the value, because it is needed in order to
install the definition.  Because the linkage is <code>next</code>, there is no
linkage code in this case.  The skeleton of the compiled code is thus
</p>
<div class="lisp">
<pre class="lisp">⟨<em>save <code>env</code> if modified by code to compute value</em>⟩
  ⟨<em>compilation of definition value, 
   target <code>val</code>, linkage <code>next</code></em>⟩
  ⟨<em>restore <code>env</code> if saved above</em>⟩
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</pre></div>

<p>The expression that is to be compiled to produce the value for the variable
<code>factorial</code> is a <code>lambda</code> expression whose value is the procedure
that computes factorials.  <code>Compile</code> handles this by calling
<code>compile-lambda</code>, which compiles the procedure body, labels it as a new
entry point, and generates the instruction that will combine the procedure body
at the new entry point with the run-time environment and assign the result to
<code>val</code>.  The sequence then skips around the compiled procedure code, which
is inserted at this point.  The procedure code itself begins by extending the
procedure’s definition environment by a frame that binds the formal parameter
<code>n</code> to the procedure argument.  Then comes the actual procedure body.
Since this code for the value of the variable doesn’t modify the <code>env</code>
register, the optional <code>save</code> and <code>restore</code> shown above aren’t
generated.  (The procedure code at <code>entry2</code> isn’t executed at this point,
so its use of <code>env</code> is irrelevant.)  Therefore, the skeleton for the
compiled code becomes
</p>
<div class="lisp">
<pre class="lisp">  (assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env)
              (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  ⟨<em>compilation of procedure body</em>⟩
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val) (reg env))
  (assign val (const ok))
</pre></div>

<p>A procedure body is always compiled (by <code>compile-lambda-body</code>) as a
sequence with target <code>val</code> and linkage <code>return</code>.  The sequence in
this case consists of a single <code>if</code> expression:
</p>
<div class="lisp">
<pre class="lisp">(if (= n 1)
    1
    (* (factorial (- n 1)) n))
</pre></div>

<p><code>Compile-if</code> generates code that first computes the predicate (targeted to
<code>val</code>), then checks the result and branches around the true branch if the
predicate is false.  <code>Env</code> and <code>continue</code> are preserved around the
predicate code, since they may be needed for the rest of the <code>if</code>
expression.  Since the <code>if</code> expression is the final expression (and only
expression) in the sequence making up the procedure body, its target is
<code>val</code> and its linkage is <code>return</code>, so the true and false branches are
both compiled with target <code>val</code> and linkage <code>return</code>.  (That is, the
value of the conditional, which is the value computed by either of its
branches, is the value of the procedure.)
</p>
<div class="lisp">
<pre class="lisp">⟨<em>save <code>continue</code>, <code>env</code> if modified by 
 predicate and needed by branches</em>⟩
  ⟨<em>compilation of predicate, 
   target <code>val</code>, linkage <code>next</code></em>⟩
  ⟨<em>restore <code>continue</code>, <code>env</code> if saved above</em>⟩
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  ⟨<em>compilation of true branch, 
   target <code>val</code>, linkage <code>return</code></em>⟩
false-branch4
  ⟨<em>compilation of false branch, 
   target <code>val</code>, linkage <code>return</code></em>⟩
after-if3
</pre></div>

<p>The predicate <code>(= n 1)</code> is a procedure call.  This looks up the operator
(the symbol <code>=</code>) and places this value in <code>proc</code>.  It then assembles
the arguments <code>1</code> and the value of <code>n</code> into <code>argl</code>.  Then it
tests whether <code>proc</code> contains a primitive or a compound procedure, and
dispatches to a primitive branch or a compound branch accordingly.  Both
branches resume at the <code>after-call</code> label.  The requirements to preserve
registers around the evaluation of the operator and operands don’t result in
any saving of registers, because in this case those evaluations don’t modify
the registers in question.
</p>
<div class="lisp">
<pre class="lisp">  (assign proc (op lookup-variable-value)
               (const =) 
               (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value)
              (const n)
              (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry)
              (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
after-call15
</pre></div>

<p>The true branch, which is the constant 1, compiles (with target <code>val</code> and
linkage <code>return</code>) to
</p>
<div class="lisp">
<pre class="lisp">(assign val (const 1))
(goto (reg continue))
</pre></div>

<p>The code for the false branch is another procedure call, where the procedure
is the value of the symbol <code>*</code>, and the arguments are <code>n</code> and the
result of another procedure call (a call to <code>factorial</code>).  Each of these
calls sets up <code>proc</code> and <code>argl</code> and its own primitive and compound
branches.  <a href="#Figure-5_002e17">Figure 5.17</a> shows the complete compilation of the definition
of the <code>factorial</code> procedure.  Notice that the possible <code>save</code> and
<code>restore</code> of <code>continue</code> and <code>env</code> around the predicate, shown
above, are in fact generated, because these registers are modified by the
procedure call in the predicate and needed for the procedure call and the
<code>return</code> linkage in the branches.
</p>
<blockquote>
<p><strong><a id="Figure-5_002e17"></a>Figure 5.17:</strong> \( \downarrow \) Compilation of the definition of the <code>factorial</code> procedure.
</p>
<div class="lisp">
<pre class="lisp"><span class="roman">;; construct the procedure and skip over code</span>
<span class="roman">;; for the procedure body</span>
  (assign val
          (op make-compiled-procedure) 
          (label entry2) 
          (reg env))
  (goto (label after-lambda1))
entry2     <span class="roman">; calls to <code>factorial</code> will enter here</span>
  (assign env 
          (op compiled-procedure-env)
          (reg proc))
  (assign env
          (op extend-environment) 
          (const (n)) 
          (reg argl) 
          (reg env))
<span class="roman">;; begin actual procedure body</span>
  (save continue)
  (save env)
<span class="roman">;; compute <code>(= n 1)</code></span>
  (assign proc 
          (op lookup-variable-value) 
          (const =) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call15   <span class="roman">; <code>val</code> now contains result of <code>(= n 1)</code></span>
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  <span class="roman">; return 1</span>
  (assign val (const 1))
  (goto (reg continue))

false-branch4
<span class="roman">;; compute and return <code>(* (factorial (- n 1)) n)</code></span>
  (assign proc 
          (op lookup-variable-value) 
          (const *) 
          (reg env))
  (save continue)
  (save proc)   <span class="roman">; save <code>*</code></span> procedure
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op list) (reg val))
  (save argl)   <span class="roman">; save partial argument list for <code>*</code></span>
<span class="roman">;; compute <code>(factorial (- n 1))</code>,</span> 
<span class="roman">;; which is the other argument for <code>*</code></span>
  (assign proc
          (op lookup-variable-value) 
          (const factorial) 
          (reg env))
  (save proc)  <span class="roman">; save <code>factorial</code> procedure</span>
<span class="roman">;; compute <code>(- n 1)</code>, which is the argument for <code>factorial</code></span>
  (assign proc 
          (op lookup-variable-value)
          (const -) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))

after-call6   <span class="roman">; <code>val</code> now contains result of <code>(- n 1)</code></span>
  (assign argl (op list) (reg val))
  (restore proc) <span class="roman">; restore <code>factorial</code></span>
<span class="roman">;; apply <code>factorial</code></span>
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call9      <span class="roman">; <code>val</code> now contains result</span> 
                 <span class="roman">; of <code>(factorial (- n 1))</code></span>
  (restore argl) <span class="roman">; restore partial argument list for <code>*</code></span>
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) <span class="roman">; restore <code>*</code></span>
  (restore continue)
<span class="roman">;; apply <code>*</code> and return its value</span>
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
<span class="roman">;; note that a compound procedure here</span>
<span class="roman">;; is called tail-recursively</span>
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
<span class="roman">;; assign the procedure to the variable <code>factorial</code></span>
  (perform (op define-variable!) 
           (const factorial) 
           (reg val) 
           (reg env))
  (assign val (const ok))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e33"></a>Exercise 5.33:</strong> Consider the following definition
of a factorial procedure, which is slightly different from the one given above:
</p>
<div class="lisp">
<pre class="lisp">(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
</pre></div>

<p>Compile this procedure and compare the resulting code with that produced for
<code>factorial</code>.  Explain any differences you find.  Does either program
execute more efficiently than the other?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e34"></a>Exercise 5.34:</strong> Compile the iterative factorial
procedure
</p>
<div class="lisp">
<pre class="lisp">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</pre></div>

<p>Annotate the resulting code, showing the essential difference between the code
for iterative and recursive versions of <code>factorial</code> that makes one process
build up stack space and the other run in constant stack space.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e35"></a>Exercise 5.35:</strong> What expression was compiled to
produce the code shown in <a href="#Figure-5_002e18">Figure 5.18</a>?
</p></blockquote>

<blockquote>
<p><strong><a id="Figure-5_002e18"></a>Figure 5.18:</strong> \( \downarrow \) An example of compiler output.  See
<a href="#Exercise-5_002e35">Exercise 5.35</a>.
</p>
<div class="lisp">
<pre class="lisp">(assign val (op make-compiled-procedure) 
            (label entry16) 
            (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env)
              (reg proc))
  (assign env (op extend-environment) 
              (const (x)) 
              (reg argl) 
              (reg env))
  (assign proc (op lookup-variable-value) 
               (const +) 
               (reg env))
  (save continue) (save proc) (save env)
  (assign proc (op lookup-variable-value) 
               (const g) 
               (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) 
               (const +) 
               (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value)
              (const x) 
              (reg env))
  (assign argl (op cons)
               (reg val)
               (reg argl))
  (test (op primitive-procedure?)
        (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val
          (op apply-primitive-procedure)
          (reg proc) 
          (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?)
        (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val
          (op compiled-procedure-entry)
          (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val
          (op lookup-variable-value) 
          (const x) 
          (reg env))
  (assign argl
          (op cons)
          (reg val)
          (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?)
        (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry)
              (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val 
          (op apply-primitive-procedure)
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) 
           (const f) 
           (reg val) 
           (reg env))
  (assign val (const ok))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e36"></a>Exercise 5.36:</strong> What order of evaluation does our
compiler produce for operands of a combination?  Is it left-to-right,
right-to-left, or some other order?  Where in the compiler is this order
determined?  Modify the compiler so that it produces some other order of
evaluation.  (See the discussion of order of evaluation for the
explicit-control evaluator in <a href="5_002e4_002e1.xhtml#g_t5_002e4_002e1">5.4.1</a>.)  How does changing the
order of operand evaluation affect the efficiency of the code that constructs
the argument list?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e37"></a>Exercise 5.37:</strong> One way to understand the
compiler’s <code>preserving</code> mechanism for optimizing stack usage is to see
what extra operations would be generated if we did not use this idea.  Modify
<code>preserving</code> so that it always generates the <code>save</code> and
<code>restore</code> operations.  Compile some simple expressions and identify the
unnecessary stack operations that are generated.  Compare the code to that
generated with the <code>preserving</code> mechanism intact.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-5_002e38"></a>Exercise 5.38:</strong> Our compiler is clever about
avoiding unnecessary stack operations, but it is not clever at all when it
comes to compiling calls to the primitive procedures of the language in terms
of the primitive operations supplied by the machine.  For example, consider how
much code is compiled to compute <code>(+ a 1)</code>: The code sets up an argument
list in <code>argl</code>, puts the primitive addition procedure (which it finds by
looking up the symbol <code>+</code> in the environment) into <code>proc</code>, and tests
whether the procedure is primitive or compound.  The compiler always generates
code to perform the test, as well as code for primitive and compound branches
(only one of which will be executed).  We have not shown the part of the
controller that implements primitives, but we presume that these instructions
make use of primitive arithmetic operations in the machine’s data paths.
Consider how much less code would be generated if the compiler could
<a id="index-open_002dcode"></a>
<em>open-code</em> primitives—that is, if it could generate code to directly
use these primitive machine operations.  The expression <code>(+ a 1)</code> might be
compiled into something as simple as<a class="footnote_link" id="DOCF328" href="#FOOT328"><sup>328</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(assign val (op lookup-variable-value) 
            (const a) 
            (reg env))
(assign val (op +)
            (reg val)
            (const 1))
</pre></div>

<p>In this exercise we will extend our compiler to support open coding of selected
primitives.  Special-purpose code will be generated for calls to these
primitive procedures instead of the general procedure-application code.  In
order to support this, we will augment our machine with special argument
registers <code>arg1</code> and <code>arg2</code>.  The primitive arithmetic operations of
the machine will take their inputs from <code>arg1</code> and <code>arg2</code>. The
results may be put into <code>val</code>, <code>arg1</code>, or <code>arg2</code>.
</p>
<p>The compiler must be able to recognize the application of an open-coded
primitive in the source program.  We will augment the dispatch in the
<code>compile</code> procedure to recognize the names of these primitives in addition
to the reserved words (the special forms) it currently
recognizes.<a class="footnote_link" id="DOCF329" href="#FOOT329"><sup>329</sup></a> For each special
form our compiler has a code generator.  In this exercise we will construct a
family of code generators for the open-coded primitives.
</p>
<ol>
<li> The open-coded primitives, unlike the special forms, all need their operands
evaluated.  Write a code generator <code>spread-arguments</code> for use by all the
open-coding code generators.  <code>Spread-arguments</code> should take an operand
list and compile the given operands targeted to successive argument registers.
Note that an operand may contain a call to an open-coded primitive, so argument
registers will have to be preserved during operand evaluation.

</li><li> For each of the primitive procedures <code>=</code>, <code>*</code>, <code>-</code>, and
<code>+</code>, write a code generator that takes a combination with that operator,
together with a target and a linkage descriptor, and produces code to spread
the arguments into the registers and then perform the operation targeted to the
given target with the given linkage.  You need only handle expressions with two
operands.  Make <code>compile</code> dispatch to these code generators.

</li><li> Try your new compiler on the <code>factorial</code> example.  Compare the resulting
code with the result produced without open coding.

</li><li> Extend your code generators for <code>+</code> and <code>*</code> so that they can handle
expressions with arbitrary numbers of operands.  An expression with more than
two operands will have to be compiled into a sequence of operations, each with
only two inputs.

</li></ol>
</blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT328"><p><a class="footnote_backlink" href="#DOCF328"><sup>328</sup></a>
We have used the same symbol
<code>+</code> here to denote both the source-language procedure and the machine
operation.  In general there will not be a one-to-one correspondence between
primitives of the source language and primitives of the machine.</p>
</div>
<div id="FOOT329"><p><a class="footnote_backlink" href="#DOCF329"><sup>329</sup></a>
Making the primitives into reserved words is in general a
bad idea, since a user cannot then rebind these names to different procedures.
Moreover, if we add reserved words to a compiler that is in use, existing
programs that define procedures with these names will stop working.  See
<a href="5_002e5_002e6.xhtml#Exercise-5_002e44">Exercise 5.44</a> for ideas on how to avoid this problem.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6" accesskey="n" rel="next">5.5.6</a>, Previous: <a href="5_002e5_002e4.xhtml#g_t5_002e5_002e4" accesskey="p" rel="prev">5.5.4</a>, Up: <a href="5_002e5.xhtml#g_t5_002e5" accesskey="u" rel="prev">5.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
