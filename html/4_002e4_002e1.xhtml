<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.1</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.1"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.4.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e4.xhtml#g_t4_002e4" rel="prev" title="4.4"/>
<link href="4_002e4_002e2.xhtml#g_t4_002e4_002e2" rel="next" title="4.4.2"/>
<link href="4_002e4.xhtml#g_t4_002e4" rel="prev" title="4.4"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e4_002e1"></a>
<nav class="header">
<p>
Next: <a href="4_002e4_002e2.xhtml#g_t4_002e4_002e2" accesskey="n" rel="next">4.4.2</a>, Previous: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="p" rel="prev">4.4</a>, Up: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="u" rel="prev">4.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Deductive-Information-Retrieval"></a>
<h4 class="subsection"><span class="secnum">4.4.1</span><span class="sectitle">Deductive Information Retrieval</span></h4>

<p>Logic programming excels in providing interfaces to data bases for information
retrieval.  The query language we shall implement in this chapter is designed
to be used in this way.
</p>
<p>In order to illustrate what the query system does, we will show how it can be
used to manage the data base of personnel records for Microshaft, a thriving
high-technology company in the Boston area.  The language provides
pattern-directed access to personnel information and can also take advantage of
general rules in order to make logical deductions.
</p>
<a id="A-sample-data-base"></a>
<h5 class="subsubheading">A sample data base</h5>

<p>The personnel data base for Microshaft contains <a id="index-assertions"></a>
<em>assertions</em> about
company personnel.  Here is the information about Ben Bitdiddle, the resident
computer wizard:
</p>
<div class="lisp">
<pre class="lisp">(address (Bitdiddle Ben) 
         (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
</pre></div>

<p>Each assertion is a list (in this case a triple) whose elements can themselves
be lists.
</p>
<p>As resident wizard, Ben is in charge of the company’s computer division, and he
supervises two programmers and one technician.  Here is the information about
them:
</p>
<div class="lisp">
<pre class="lisp">(address (Hacker Alyssa P) 
         (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

(address (Fect Cy D) 
         (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))

(address (Tweakit Lem E) 
         (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
</pre></div>

<p>There is also a programmer trainee, who is supervised by Alyssa:
</p>
<div class="lisp">
<pre class="lisp">(address (Reasoner Louis) 
         (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) 
     (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) 
            (Hacker Alyssa P))
</pre></div>

<p>All of these people are in the computer division, as indicated by the word
<code>computer</code> as the first item in their job descriptions.
</p>
<p>Ben is a high-level employee.  His supervisor is the company’s big wheel
himself:
</p>
<div class="lisp">
<pre class="lisp">(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) 
         (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) 
     (administration big wheel))
(salary (Warbucks Oliver) 150000)
</pre></div>

<p>Besides the computer division supervised by Ben, the company has an accounting
division, consisting of a chief accountant and his assistant:
</p>
<div class="lisp">
<pre class="lisp">(address (Scrooge Eben) 
         (Weston (Shady Lane) 10))
(job (Scrooge Eben) 
     (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))

(address (Cratchet Robert) 
         (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
</pre></div>

<p>There is also a secretary for the big wheel:
</p>
<div class="lisp">
<pre class="lisp">(address (Aull DeWitt) 
         (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
</pre></div>

<p>The data base also contains assertions about which kinds of jobs can be done by
people holding other kinds of jobs.  For instance, a computer wizard can do the
jobs of both a computer programmer and a computer technician:
</p>
<div class="lisp">
<pre class="lisp">(can-do-job (computer wizard) 
            (computer programmer))

(can-do-job (computer wizard) 
            (computer technician))
</pre></div>

<p>A computer programmer could fill in for a trainee:
</p>
<div class="lisp">
<pre class="lisp">(can-do-job (computer programmer)
            (computer programmer trainee))
</pre></div>

<p>Also, as is well known,
</p>
<div class="lisp">
<pre class="lisp">(can-do-job (administration secretary)
            (administration big wheel))
</pre></div>

<a id="Simple-queries"></a>
<h5 class="subsubheading">Simple queries</h5>

<p>The query language allows users to retrieve information from the data base by
posing queries in response to the system’s prompt.  For example, to find all
computer programmers one can say
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Query input:</i>
(job ?x (computer programmer))
</pre></div>

<p>The system will respond with the following items:
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Query results:</i>
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
</pre></div>

<p>The input query specifies that we are looking for entries in the data base that
match a certain <a id="index-pattern"></a>
<em>pattern</em>.  In this example, the pattern specifies
entries consisting of three items, of which the first is the literal symbol
<code>job</code>, the second can be anything, and the third is the literal list
<code>(computer programmer)</code>.  The “anything” that can be the second item in
the matching list is specified by a <a id="index-pattern-variable"></a>
<em>pattern variable</em>, <code>?x</code>.  The
general form of a pattern variable is a symbol, taken to be the name of the
variable, preceded by a question mark.  We will see below why it is useful to
specify names for pattern variables rather than just putting <code>?</code> into
patterns to represent “anything.”  The system responds to a simple query by
showing all entries in the data base that match the specified pattern.
</p>
<p>A pattern can have more than one variable.  For example, the query
</p>
<div class="lisp">
<pre class="lisp">(address ?x ?y)
</pre></div>

<p>will list all the employees’ addresses.
</p>
<p>A pattern can have no variables, in which case the query simply determines
whether that pattern is an entry in the data base.  If so, there will be one
match; if not, there will be no matches.
</p>
<p>The same pattern variable can appear more than once in a query, specifying that
the same “anything” must appear in each position.  This is why variables have
names.  For example,
</p>
<div class="lisp">
<pre class="lisp">(supervisor ?x ?x)
</pre></div>

<p>finds all people who supervise themselves (though there are no such assertions
in our sample data base).
</p>
<p>The query
</p>
<div class="lisp">
<pre class="lisp">(job ?x (computer ?type))
</pre></div>

<p>matches all job entries whose third item is a two-element list whose first item
is <code>computer</code>:
</p>
<div class="lisp">
<pre class="lisp">(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
</pre></div>

<p>This same pattern does <em>not</em> match
</p>
<div class="lisp">
<pre class="lisp">(job (Reasoner Louis) 
     (computer programmer trainee))
</pre></div>

<p>because the third item in the entry is a list of three elements, and the
pattern’s third item specifies that there should be two elements.  If we wanted
to change the pattern so that the third item could be any list beginning with
<code>computer</code>, we could specify<a class="footnote_link" id="DOCF266" href="#FOOT266"><sup>266</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(job ?x (computer . ?type))
</pre></div>

<p>For example,
</p>
<div class="lisp">
<pre class="lisp">(computer . ?type)
</pre></div>

<p>matches the data
</p>
<div class="lisp">
<pre class="lisp">(computer programmer trainee)
</pre></div>

<p>with <code>?type</code> as the list <code>(programmer trainee)</code>.  It also
matches the data
</p>
<div class="lisp">
<pre class="lisp">(computer programmer)
</pre></div>

<p>with <code>?type</code> as the list <code>(programmer)</code>, and matches the data
</p>
<div class="lisp">
<pre class="lisp">(computer)
</pre></div>

<p>with <code>?type</code> as the empty list <code>()</code>.
</p>
<p>We can describe the query language’s processing of simple queries as follows:
</p>
<ul>
<li> The system finds all assignments to variables in the query pattern that
<a id="index-satisfy"></a>
<em>satisfy</em> the pattern—that is, all sets of values for the variables
such that if the pattern variables are <a id="index-instantiated-with"></a>
<em>instantiated with</em> (replaced
by) the values, the result is in the data base.

</li><li> The system responds to the query by listing all instantiations of the query
pattern with the variable assignments that satisfy it.

</li></ul>

<p>Note that if the pattern has no variables, the query reduces to a determination
of whether that pattern is in the data base.  If so, the empty assignment,
which assigns no values to variables, satisfies that pattern for that data
base.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e55"></a>Exercise 4.55:</strong> Give simple queries that retrieve
the following information from the data base:
</p>
<ol>
<li> all people supervised by Ben Bitdiddle;

</li><li> the names and jobs of all people in the accounting division;

</li><li> the names and addresses of all people who live in Slumerville.

</li></ol>
</blockquote>

<a id="Compound-queries"></a>
<h5 class="subsubheading">Compound queries</h5>

<p>Simple queries form the primitive operations of the query language.  In order
to form compound operations, the query language provides means of combination.
One thing that makes the query language a logic programming language is that
the means of combination mirror the means of combination used in forming
logical expressions: <code>and</code>, <code>or</code>, and <code>not</code>.  (Here <code>and</code>,
<code>or</code>, and <code>not</code> are not the Lisp primitives, but rather operations
built into the query language.)
</p>
<p>We can use <code>and</code> as follows to find the addresses of all the computer
programmers:
</p>
<div class="lisp">
<pre class="lisp">(and (job ?person (computer programmer))
     (address ?person ?where))
</pre></div>

<p>The resulting output is
</p>
<div class="lisp">
<pre class="lisp">(and (job (Hacker Alyssa P) 
          (computer programmer))
     (address (Hacker Alyssa P) 
              (Cambridge (Mass Ave) 78)))

(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) 
              (Cambridge (Ames Street) 3)))
</pre></div>

<p>In general,
</p>
<div class="lisp">
<pre class="lisp">(and ⟨<var>query₁</var>⟩ ⟨<var>query₂</var>⟩ <span class="roman">…</span> ⟨<var>queryₙ</var>⟩)
</pre></div>

<p>is satisfied by all sets of values for the pattern variables that
simultaneously satisfy \( {⟨\kern0.1em query_1⟩} \) <span class="roman">…</span> \( {⟨\kern0.1em query_n⟩} \).
</p>
<p>As for simple queries, the system processes a compound query by finding all
assignments to the pattern variables that satisfy the query, then displaying
instantiations of the query with those values.
</p>
<p>Another means of constructing compound queries is through <code>or</code>.  For
example,
</p>
<div class="lisp">
<pre class="lisp">(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
</pre></div>

<p>will find all employees supervised by Ben Bitdiddle or Alyssa P.  Hacker:
</p>
<div class="lisp">
<pre class="lisp">(or (supervisor (Hacker Alyssa P) 
                (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) 
                (Hacker Alyssa P)))

(or (supervisor (Fect Cy D) 
                (Bitdiddle Ben))
    (supervisor (Fect Cy D) 
                (Hacker Alyssa P)))

(or (supervisor (Tweakit Lem E) 
                (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) 
                (Hacker Alyssa P)))

(or (supervisor (Reasoner Louis) 
                (Bitdiddle Ben))
    (supervisor (Reasoner Louis) 
                (Hacker Alyssa P)))
</pre></div>

<p>In general,
</p>
<div class="lisp">
<pre class="lisp">(or ⟨<var>query₁</var>⟩ ⟨<var>query₂</var>⟩ <span class="roman">…</span> ⟨<var>queryₙ</var>⟩)
</pre></div>

<p>is satisfied by all sets of values for the pattern variables that satisfy at
least one of \( {⟨\kern0.1em query_1⟩} \) <span class="roman">…</span> \( {⟨\kern0.1em query_n⟩} \).
</p>
<p>Compound queries can also be formed with <code>not</code>. For example,
</p>
<div class="lisp">
<pre class="lisp">(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
</pre></div>

<p>finds all people supervised by Ben Bitdiddle who are not computer programmers.
In general,
</p>
<div class="lisp">
<pre class="lisp">(not ⟨<var>query₁</var>⟩)
</pre></div>

<p>is satisfied by all assignments to the pattern variables that do not satisfy
\( {⟨\kern0.1em query_1⟩} \).<a class="footnote_link" id="DOCF267" href="#FOOT267"><sup>267</sup></a>
</p>
<p>The final combining form is called <code>lisp-value</code>.  When <code>lisp-value</code>
is the first element of a pattern, it specifies that the next element is a Lisp
predicate to be applied to the rest of the (instantiated) elements as
arguments.  In general,
</p>
<div class="lisp">
<pre class="lisp">(lisp-value ⟨<var>predicate</var>⟩ ⟨<var>arg₁</var>⟩ <span class="roman">…</span> ⟨<var>argₙ</var>⟩)
</pre></div>

<p>will be satisfied by assignments to the pattern variables for which the
<code>⟨</code><var>predicate</var><code>⟩</code> applied to the instantiated \( {⟨\kern0.1em arg_1⟩} \) <span class="roman">…</span>
\( {⟨\kern0.1em arg_n⟩} \) is true.  For example, to find all people whose salary is
greater than $30,000 we could write<a class="footnote_link" id="DOCF268" href="#FOOT268"><sup>268</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(and (salary ?person ?amount)
     (lisp-value &gt; ?amount 30000))
</pre></div>

<blockquote>
<p><strong><a id="Exercise-4_002e56"></a>Exercise 4.56:</strong> Formulate compound queries that
retrieve the following information:
</p>
<ol>
<li> the names of all people who are supervised by Ben Bitdiddle, together with
their addresses;

</li><li> all people whose salary is less than Ben Bitdiddle’s, together with their
salary and Ben Bitdiddle’s salary;

</li><li> all people who are supervised by someone who is not in the computer division,
together with the supervisor’s name and job.

</li></ol>
</blockquote>

<a id="Rules"></a>
<h5 class="subsubheading">Rules</h5>

<p>In addition to primitive queries and compound queries, the query language
provides means for abstracting queries.  These are given by <a id="index-rules-1"></a>
<em>rules</em>.
The rule
</p>
<div class="lisp">
<pre class="lisp">(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 
                    (?town . ?rest-1))
           (address ?person-2 
                    (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</pre></div>

<p>specifies that two people live near each other if they live in the same town.
The final <code>not</code> clause prevents the rule from saying that all people live
near themselves.  The <code>same</code> relation is defined by a very simple
rule:<a class="footnote_link" id="DOCF269" href="#FOOT269"><sup>269</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(rule (same ?x ?x))
</pre></div>

<p>The following rule declares that a person is a “wheel” in an organization if
he supervises someone who is in turn a supervisor:
</p>
<div class="lisp">
<pre class="lisp">(rule (wheel ?person)
      (and (supervisor ?middle-manager 
                       ?person)
           (supervisor ?x ?middle-manager)))
</pre></div>

<p>The general form of a rule is
</p>
<div class="lisp">
<pre class="lisp">(rule ⟨<var>conclusion</var>⟩ ⟨<var>body</var>⟩)
</pre></div>

<p>where <code>⟨</code><var>conclusion</var><code>⟩</code> is a pattern and <code>⟨</code><var>body</var><code>⟩</code> is any
query.<a class="footnote_link" id="DOCF270" href="#FOOT270"><sup>270</sup></a> We can think of a rule as representing a large
(even infinite) set of assertions, namely all instantiations of the rule
conclusion with variable assignments that satisfy the rule body.  When we
described simple queries (patterns), we said that an assignment to variables
satisfies a pattern if the instantiated pattern is in the data base.  But the
pattern needn’t be explicitly in the data base as an assertion.  It can be an
implicit assertion implied by a rule.  For example, the query
</p>
<div class="lisp">
<pre class="lisp">(lives-near ?x (Bitdiddle Ben))
</pre></div>

<p>results in
</p>
<div class="lisp">
<pre class="lisp">(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
</pre></div>

<p>To find all computer programmers who live near Ben Bitdiddle, we can ask
</p>
<div class="lisp">
<pre class="lisp">(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
</pre></div>

<p>As in the case of compound procedures, rules can be used as parts of other
rules (as we saw with the <code>lives-near</code> rule above) or even be defined
recursively.  For instance, the rule
</p>
<div class="lisp">
<pre class="lisp">(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person 
                           ?middle-manager)
               (outranked-by ?middle-manager 
                             ?boss))))
</pre></div>

<p>says that a staff person is outranked by a boss in the organization if the boss
is the person’s supervisor or (recursively) if the person’s supervisor is
outranked by the boss.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e57"></a>Exercise 4.57:</strong> Define a rule that says that
person 1 can replace person 2 if either person 1 does the same job as person 2
or someone who does person 1’s job can also do person 2’s job, and if person 1
and person 2 are not the same person. Using your rule, give queries that find
the following:
</p>
<ol>
<li> all people who can replace Cy D. Fect;

</li><li> all people who can replace someone who is being paid more than they are,
together with the two salaries.

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e58"></a>Exercise 4.58:</strong> Define a rule that says that a
person is a “big shot” in a division if the person works in the division but
does not have a supervisor who works in the division.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e59"></a>Exercise 4.59:</strong> Ben Bitdiddle has missed one
meeting too many.  Fearing that his habit of forgetting meetings could cost him
his job, Ben decides to do something about it.  He adds all the weekly meetings
of the firm to the Microshaft data base by asserting the following:
</p>
<div class="lisp">
<pre class="lisp">(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
</pre></div>

<p>Each of the above assertions is for a meeting of an entire division.  Ben also
adds an entry for the company-wide meeting that spans all the divisions.  All
of the company’s employees attend this meeting.
</p>
<div class="lisp">
<pre class="lisp">(meeting whole-company (Wednesday 4pm))
</pre></div>

<ol>
<li> On Friday morning, Ben wants to query the data base for all the meetings that
occur that day.  What query should he use?

</li><li> Alyssa P. Hacker is unimpressed.  She thinks it would be much more useful to be
able to ask for her meetings by specifying her name.  So she designs a rule
that says that a person’s meetings include all <code>whole-company</code> meetings
plus all meetings of that person’s division.  Fill in the body of Alyssa’s
rule.

<div class="lisp">
<pre class="lisp">(rule (meeting-time ?person
                    ?day-and-time)
      ⟨<var>rule-body</var>⟩)
</pre></div>

</li><li> Alyssa arrives at work on Wednesday morning and wonders what meetings she has
to attend that day.  Having defined the above rule, what query should she make
to find this out?

</li></ol>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e60"></a>Exercise 4.60:</strong> By giving the query
</p>
<div class="lisp">
<pre class="lisp">(lives-near ?person (Hacker Alyssa P))
</pre></div>

<p>Alyssa P. Hacker is able to find people who live near her, with whom she can
ride to work.  On the other hand, when she tries to find all pairs of people
who live near each other by querying
</p>
<div class="lisp">
<pre class="lisp">(lives-near ?person-1 ?person-2)
</pre></div>

<p>she notices that each pair of people who live near each other is listed twice;
for example,
</p>
<div class="lisp">
<pre class="lisp">(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
</pre></div>

<p>Why does this happen?  Is there a way to find a list of people who live near
each other, in which each pair appears only once?  Explain.
</p></blockquote>

<a id="Logic-as-programs"></a>
<h5 class="subsubheading">Logic as programs</h5>

<p>We can regard a rule as a kind of logical implication: <em>If</em> an assignment
of values to pattern variables satisfies the body, <em>then</em> it satisfies the
conclusion.  Consequently, we can regard the query language as having the
ability to perform <a id="index-logical-deductions"></a>
<em>logical deductions</em> based upon the rules.  As an
example, consider the <code>append</code> operation described at the beginning of
<a href="4_002e4.xhtml#g_t4_002e4">4.4</a>.  As we said, <code>append</code> can be characterized by the
following two rules:
</p>
<ul>
<li> For any list <code>y</code>, the empty list and <code>y</code> <code>append</code> to form
<code>y</code>.

</li><li> For any <code>u</code>, <code>v</code>, <code>y</code>, and <code>z</code>, <code>(cons u v)</code> and
<code>y</code> <code>append</code> to form <code>(cons u z)</code> if <code>v</code> and <code>y</code>
<code>append</code> to form <code>z</code>.

</li></ul>

<p>To express this in our query language, we define two rules for a relation
</p>
<div class="lisp">
<pre class="lisp">(append-to-form x y z)
</pre></div>

<p>which we can interpret to mean “<code>x</code> and <code>y</code> <code>append</code> to form
<code>z</code>”:
</p>
<div class="lisp">
<pre class="lisp">(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
</pre></div>

<p>The first rule has no body, which means that the conclusion holds for any value
of <code>?y</code>.  Note how the second rule makes use of dotted-tail notation to
name the <code>car</code> and <code>cdr</code> of a list.
</p>
<p>Given these two rules, we can formulate queries that compute the <code>append</code>
of two lists:
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) (c d) ?z)

<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</pre></div>

<p>What is more striking, we can use the same rules to ask the question “Which
list, when <code>append</code>ed to <code>(a b)</code>, yields <code>(a b c d)</code>?”  This is
done as follows:
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Query input:</i>
(append-to-form (a b) ?y (a b c d))

<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</pre></div>

<p>We can also ask for all pairs of lists that <code>append</code> to form <code>(a b c
d)</code>:
</p>
<div class="lisp">
<pre class="lisp"><i>;;; Query input:</i>
(append-to-form ?x ?y (a b c d))

<i>;;; Query results:</i>
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
</pre></div>

<p>The query system may seem to exhibit quite a bit of intelligence in using the
rules to deduce the answers to the queries above.  Actually, as we will see in
the next section, the system is following a well-determined algorithm in
unraveling the rules.  Unfortunately, although the system works impressively in
the <code>append</code> case, the general methods may break down in more complex
cases, as we will see in <a href="4_002e4_002e3.xhtml#g_t4_002e4_002e3">4.4.3</a>.
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e61"></a>Exercise 4.61:</strong> The following rules implement a
<code>next-to</code> relation that finds adjacent elements of a list:
</p>
<div class="lisp">
<pre class="lisp">(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
</pre></div>

<p>What will the response be to the following queries?
</p>
<div class="lisp">
<pre class="lisp">(?x next-to ?y in (1 (2 3) 4))
(?x next-to 1 in (2 1 3 1))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e62"></a>Exercise 4.62:</strong> Define rules to implement the
<code>last-pair</code> operation of <a href="2_002e2_002e1.xhtml#Exercise-2_002e17">Exercise 2.17</a>, which returns a list
containing the last element of a nonempty list.  Check your rules on queries
such as <code>(last-pair (3) ?x)</code>, <code>(last-pair (1 2 3) ?x)</code> and
<code>(last-pair (2 ?x) (3))</code>.  Do your rules work correctly on queries such as
<code>(last-pair ?x (3))</code>?
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e63"></a>Exercise 4.63:</strong> The following data base (see
Genesis 4) traces the genealogy of the descendants of Ada back to Adam, by way
of Cain:
</p>
<div class="lisp">
<pre class="lisp">(son Adam Cain) (son Cain Enoch)
(son Enoch Irad) (son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada) (son Ada Jabal)
(son Ada Jubal)
</pre></div>

<p>Formulate rules such as “If \( S \) is the son of \( f \), and \( f \) is the son of
\( G \), then \( S \) is the grandson of \( G \)” and “If \( W \) is the wife of
\( M \), and \( S \) is the son of \( W \), then \( S \) is the son of \( M \)” (which
was supposedly more true in biblical times than today) that will enable the
query system to find the grandson of Cain; the sons of Lamech; the grandsons of
Methushael.  (See <a href="4_002e4_002e3.xhtml#Exercise-4_002e69">Exercise 4.69</a> for some rules to deduce more complicated
relationships.)
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT266"><p><a class="footnote_backlink" href="#DOCF266"><sup>266</sup></a>
This uses the dotted-tail notation
introduced in <a href="2_002e2_002e1.xhtml#Exercise-2_002e20">Exercise 2.20</a>.</p>
</div>
<div id="FOOT267"><p><a class="footnote_backlink" href="#DOCF267"><sup>267</sup></a>
Actually, this description of <code>not</code> is valid
only for simple cases.  The real behavior of <code>not</code> is more complex.  We
will examine <code>not</code>’s peculiarities in <a href="4_002e4_002e2.xhtml#g_t4_002e4_002e2">4.4.2</a> and
<a href="4_002e4_002e3.xhtml#g_t4_002e4_002e3">4.4.3</a>.</p>
</div>
<div id="FOOT268"><p><a class="footnote_backlink" href="#DOCF268"><sup>268</sup></a>
<code>Lisp-value</code> should be used
only to perform an operation not provided in the query language.  In
particular, it should not be used to test equality (since that is what the
matching in the query language is designed to do) or inequality (since that can
be done with the <code>same</code> rule shown below).</p>
</div>
<div id="FOOT269"><p><a class="footnote_backlink" href="#DOCF269"><sup>269</sup></a>
Notice that we do not need <code>same</code> in order to make two
things be the same: We just use the same pattern variable for each—in effect,
we have one thing instead of two things in the first place.  For example, see
<code>?town</code> in the <code>lives-near</code> rule and <code>?middle-manager</code> in the
<code>wheel</code> rule below.  <code>Same</code> is useful when we want to force two
things to be different, such as <code>?person-1</code> and <code>?person-2</code> in the
<code>lives-near</code> rule.  Although using the same pattern variable in two parts
of a query forces the same value to appear in both places, using different
pattern variables does not force different values to appear.  (The values
assigned to different pattern variables may be the same or different.)</p>
</div>
<div id="FOOT270"><p><a class="footnote_backlink" href="#DOCF270"><sup>270</sup></a>
We will also allow rules without bodies, as in <code>same</code>, and
we will interpret such a rule to mean that the rule conclusion is satisfied by
any values of the variables.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="4_002e4_002e2.xhtml#g_t4_002e4_002e2" accesskey="n" rel="next">4.4.2</a>, Previous: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="p" rel="prev">4.4</a>, Up: <a href="4_002e4.xhtml#g_t4_002e4" accesskey="u" rel="prev">4.4</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
