<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.3</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.3"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 4.1.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="4_002e1.xhtml#g_t4_002e1" rel="prev" title="4.1"/>
<link href="4_002e1_002e4.xhtml#g_t4_002e1_002e4" rel="next" title="4.1.4"/>
<link href="4_002e1_002e2.xhtml#g_t4_002e1_002e2" rel="prev" title="4.1.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t4_002e1_002e3"></a>
<nav class="header">
<p>
Next: <a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4" accesskey="n" rel="next">4.1.4</a>, Previous: <a href="4_002e1_002e2.xhtml#g_t4_002e1_002e2" accesskey="p" rel="prev">4.1.2</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Evaluator-Data-Structures"></a>
<h4 class="subsection"><span class="secnum">4.1.3</span><span class="sectitle">Evaluator Data Structures</span></h4>

<p>In addition to defining the external syntax of expressions, the evaluator
implementation must also define the data structures that the evaluator
manipulates internally, as part of the execution of a program, such as the
representation of procedures and environments and the representation of true
and false.
</p>
<a id="Testing-of-predicates"></a>
<h5 class="subsubheading">Testing of predicates</h5>

<p>For conditionals, we accept anything to be true that is not the explicit
<code>false</code> object.
</p>
<div class="lisp">
<pre class="lisp">(define (true? x)
  (not (eq? x false)))

(define (false? x)
  (eq? x false))
</pre></div>

<a id="Representing-procedures"></a>
<h5 class="subsubheading">Representing procedures</h5>

<p>To handle primitives, we assume that we have available the following
procedures:
</p>
<ul>
<li> <code>(apply-primitive-procedure ⟨<var>proc</var>⟩ ⟨<var>args</var>⟩)</code>

<p>applies the given primitive procedure to the argument values in the list
<code>⟨</code><var>args</var><code>⟩</code> and returns the result of the application.
</p>
</li><li> <code>(primitive-procedure? ⟨<var>proc</var>⟩)</code>

<p>tests whether <code>⟨</code><var>proc</var><code>⟩</code> is a primitive procedure.
</p>
</li></ul>

<p>These mechanisms for handling primitives are further described in 
<a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4">4.1.4</a>.
</p>
<p>Compound procedures are constructed from parameters, procedure bodies, and
environments using the constructor <code>make-procedure</code>:
</p>
<div class="lisp">
<pre class="lisp">(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
</pre></div>

<a id="Operations-on-Environments"></a>
<h5 class="subsubheading">Operations on Environments</h5>

<p>The evaluator needs operations for manipulating environments.  As explained in
<a href="3_002e2.xhtml#g_t3_002e2">3.2</a>, an environment is a sequence of frames, where each frame is
a table of bindings that associate variables with their corresponding values.
We use the following operations for manipulating environments:
</p>
<ul>
<li> <code>(lookup-variable-value ⟨<var>var</var>⟩ ⟨<var>env</var>⟩)</code>

<p>returns the value that is bound to the symbol <code>⟨</code><var>var</var><code>⟩</code> in the environment
<code>⟨</code><var>env</var><code>⟩</code>, or signals an error if the variable is unbound.
</p>
</li><li> <code>(extend-environment ⟨<var>variables</var>⟩ ⟨<var>values</var>⟩ ⟨<var>base-env</var>⟩)</code>

<p>returns a new environment, consisting of a new frame in which the symbols in
the list <code>⟨</code><var>variables</var><code>⟩</code> are bound to the corresponding elements in the list
<code>⟨</code><var>values</var><code>⟩</code>, where the enclosing environment is the environment
<code>⟨</code><var>base-env</var><code>⟩</code>.
</p>
</li><li> <code>(define-variable! ⟨<var>var</var>⟩ ⟨<var>value</var>⟩ ⟨<var>env</var>⟩)</code>

<p>adds to the first frame in the environment <code>⟨</code><var>env</var><code>⟩</code> a new binding that
associates the variable <code>⟨</code><var>var</var><code>⟩</code> with the value <code>⟨</code><var>value</var><code>⟩</code>.
</p>
</li><li> <code>(set-variable-value! ⟨<var>var</var>⟩ ⟨<var>value</var>⟩ ⟨<var>env</var>⟩)</code>

<p>changes the binding of the variable <code>⟨</code><var>var</var><code>⟩</code> in the environment <code>⟨</code><var>env</var><code>⟩</code>
so that the variable is now bound to the value <code>⟨</code><var>value</var><code>⟩</code>, or signals an
error if the variable is unbound.
</p>
</li></ul>

<p>To implement these operations we represent an environment as a list of frames.
The enclosing environment of an environment is the <code>cdr</code> of the list.  The
empty environment is simply the empty list.
</p>
<div class="lisp">
<pre class="lisp">(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
</pre></div>

<p>Each frame of an environment is represented as a pair of lists: a list of the
variables bound in that frame and a list of the associated
values.<a class="footnote_link" id="DOCF218" href="#FOOT218"><sup>218</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
</pre></div>

<p>To extend an environment by a new frame that associates variables with values,
we make a frame consisting of the list of variables and the list of values, and
we adjoin this to the environment.  We signal an error if the number of
variables does not match the number of values.
</p>
<div class="lisp">
<pre class="lisp">(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (&lt; (length vars) (length vals))
          (error &quot;Too many arguments supplied&quot; 
                 vars 
                 vals)
          (error &quot;Too few arguments supplied&quot; 
                 vars 
                 vals))))
</pre></div>

<p>To look up a variable in an environment, we scan the list of variables in the
first frame.  If we find the desired variable, we return the corresponding
element in the list of values.  If we do not find the variable in the current
frame, we search the enclosing environment, and so on.  If we reach the empty
environment, we signal an “unbound variable” error.
</p>
<div class="lisp">
<pre class="lisp">(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop 
              (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) 
                        (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error &quot;Unbound variable&quot; var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</pre></div>

<p>To set a variable to a new value in a specified environment, we scan for the
variable, just as in <code>lookup-variable-value</code>, and change the corresponding
value when we find it.
</p>
<div class="lisp">
<pre class="lisp">(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop 
              (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) 
                        (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error &quot;Unbound variable: SET!&quot; var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</pre></div>

<p>To define a variable, we search the first frame for a binding for the variable,
and change the binding if it exists (just as in <code>set-variable-value!</code>).
If no such binding exists, we adjoin one to the first frame.
</p>
<div class="lisp">
<pre class="lisp">(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! 
              var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) 
                        (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
</pre></div>

<p>The method described here is only one of many plausible ways to represent
environments.  Since we used data abstraction to isolate the rest of the
evaluator from the detailed choice of representation, we could change the
environment representation if we wanted to.  (See <a href="#Exercise-4_002e11">Exercise 4.11</a>.)  In a
production-quality Lisp system, the speed of the evaluator’s environment
operations—especially that of variable lookup—has a major impact on the
performance of the system.  The representation described here, although
conceptually simple, is not efficient and would not ordinarily be used in a
production system.<a class="footnote_link" id="DOCF219" href="#FOOT219"><sup>219</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-4_002e11"></a>Exercise 4.11:</strong> Instead of representing a frame
as a pair of lists, we can represent a frame as a list of bindings, where each
binding is a name-value pair.  Rewrite the environment operations to use this
alternative representation.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e12"></a>Exercise 4.12:</strong> The procedures
<code>define-variable!</code>, <code>set-variable-value!</code> and
<code>lookup-variable-value</code> can be expressed in terms of more abstract
procedures for traversing the environment structure.  Define abstractions that
capture the common patterns and redefine the three procedures in terms of these
abstractions.
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-4_002e13"></a>Exercise 4.13:</strong> Scheme allows us to create new
bindings for variables by means of <code>define</code>, but provides no way to get
rid of bindings.  Implement for the evaluator a special form
<code>make-unbound!</code> that removes the binding of a given symbol from the
environment in which the <code>make-unbound!</code> expression is evaluated.  This
problem is not completely specified.  For example, should we remove only the
binding in the first frame of the environment?  Complete the specification and
justify any choices you make.
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT218"><p><a class="footnote_backlink" href="#DOCF218"><sup>218</sup></a>
Frames are not really a data abstraction in the following
code: <code>Set-variable-value!</code> and <code>define-variable!</code> use
<code>set-car!</code>  to directly modify the values in a frame.  The purpose of the
frame procedures is to make the environment-manipulation procedures easy to
read.</p>
</div>
<div id="FOOT219"><p><a class="footnote_backlink" href="#DOCF219"><sup>219</sup></a>
The drawback of this representation (as well as the
variant in <a href="#Exercise-4_002e11">Exercise 4.11</a>) is that the evaluator may have to search
through many frames in order to find the binding for a given variable.  (Such
an approach is referred to as <a id="index-deep-binding"></a>
<em>deep binding</em>.)  One way to avoid this
inefficiency is to make use of a strategy called <a id="index-lexical-addressing"></a>
<em>lexical addressing</em>,
which will be discussed in <a href="5_002e5_002e6.xhtml#g_t5_002e5_002e6">5.5.6</a>.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="4_002e1_002e4.xhtml#g_t4_002e1_002e4" accesskey="n" rel="next">4.1.4</a>, Previous: <a href="4_002e1_002e2.xhtml#g_t4_002e1_002e2" accesskey="p" rel="prev">4.1.2</a>, Up: <a href="4_002e1.xhtml#g_t4_002e1" accesskey="u" rel="prev">4.1</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
