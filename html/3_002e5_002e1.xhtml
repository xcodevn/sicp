<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.5.1</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.5.1"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 3.5.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="3_002e5.xhtml#g_t3_002e5" rel="prev" title="3.5"/>
<link href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" rel="next" title="3.5.2"/>
<link href="3_002e5.xhtml#g_t3_002e5" rel="prev" title="3.5"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t3_002e5_002e1"></a>
<nav class="header">
<p>
Next: <a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" accesskey="n" rel="next">3.5.2</a>, Previous: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="p" rel="prev">3.5</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Streams-Are-Delayed-Lists"></a>
<h4 class="subsection"><span class="secnum">3.5.1</span><span class="sectitle">Streams Are Delayed Lists</span></h4>

<p>As we saw in <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>, sequences can serve as standard interfaces
for combining program modules.  We formulated powerful abstractions for
manipulating sequences, such as <code>map</code>, <code>filter</code>, and
<code>accumulate</code>, that capture a wide variety of operations in a manner that
is both succinct and elegant.
</p>
<p>Unfortunately, if we represent sequences as lists, this elegance is bought at
the price of severe inefficiency with respect to both the time and space
required by our computations.  When we represent manipulations on sequences as
transformations of lists, our programs must construct and copy data structures
(which may be huge) at every step of a process.
</p>
<p>To see why this is true, let us compare two programs for computing the sum of
all the prime numbers in an interval.  The first program is written in standard
iterative style:<a class="footnote_link" id="DOCF181" href="#FOOT181"><sup>181</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (sum-primes a b)
  (define (iter count accum)
    (cond ((&gt; count b) accum)
          ((prime? count) 
             (iter (+ count 1) 
                   (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
</pre></div>

<p>The second program performs the same computation using the sequence operations
of <a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (sum-primes a b)
  (accumulate 
   +
   0
   (filter prime? (enumerate-interval a b))))
</pre></div>

<p>In carrying out the computation, the first program needs to store only the sum
being accumulated.  In contrast, the filter in the second program cannot do any
testing until <code>enumerate-interval</code> has constructed a complete list of the
numbers in the interval.  The filter generates another list, which in turn is
passed to <code>accumulate</code> before being collapsed to form a sum.  Such large
intermediate storage is not needed by the first program, which we can think of
as enumerating the interval incrementally, adding each prime to the sum as it
is generated.
</p>
<p>The inefficiency in using lists becomes painfully apparent if we use the
sequence paradigm to compute the second prime in the interval from 10,000 to
1,000,000 by evaluating the expression
</p>
<div class="lisp">
<pre class="lisp">(car (cdr 
      (filter 
       prime?
       (enumerate-interval 10000 1000000))))
</pre></div>

<p>This expression does find the second prime, but the computational overhead is
outrageous.  We construct a list of almost a million integers, filter this list
by testing each element for primality, and then ignore almost all of the
result.  In a more traditional programming style, we would interleave the
enumeration and the filtering, and stop when we reached the second prime.
</p>
<p>Streams are a clever idea that allows one to use sequence manipulations without
incurring the costs of manipulating sequences as lists.  With streams we can
achieve the best of both worlds: We can formulate programs elegantly as
sequence manipulations, while attaining the efficiency of incremental
computation.  The basic idea is to arrange to construct a stream only
partially, and to pass the partial construction to the program that consumes
the stream.  If the consumer attempts to access a part of the stream that has
not yet been constructed, the stream will automatically construct just enough
more of itself to produce the required part, thus preserving the illusion that
the entire stream exists.  In other words, although we will write programs as
if we were processing complete sequences, we design our stream implementation
to automatically and transparently interleave the construction of the stream
with its use.
</p>
<p>On the surface, streams are just lists with different names for the procedures
that manipulate them.  There is a constructor, <code>cons-stream</code>, and two
selectors, <code>stream-car</code> and <code>stream-cdr</code>, which satisfy the
constraints
</p>
<div class="example">
<pre class="example">(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
</pre></div>

<p>There is a distinguishable object, <code>the-empty-stream</code>, which cannot be the
result of any <code>cons-stream</code> operation, and which can be identified with
the predicate <code>stream-null?</code>.<a class="footnote_link" id="DOCF182" href="#FOOT182"><sup>182</sup></a>  Thus we can
make and use streams, in just the same way as we can make and use lists, to
represent aggregate data arranged in a sequence.  In particular, we can build
stream analogs of the list operations from <a href="Chapter-2.xhtml#Chapter-2">Chapter 2</a>, such as
<code>list-ref</code>, <code>map</code>, and <code>for-each</code>:<a class="footnote_link" id="DOCF183" href="#FOOT183"><sup>183</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream 
       (proc (stream-car s))
       (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin 
        (proc (stream-car s))
        (stream-for-each proc 
                         (stream-cdr s)))))
</pre></div>

<p><code>Stream-for-each</code> is useful for viewing streams:
</p>
<div class="lisp">
<pre class="lisp">(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
</pre></div>

<p>To make the stream implementation automatically and transparently interleave
the construction of a stream with its use, we will arrange for the <code>cdr</code>
of a stream to be evaluated when it is accessed by the <code>stream-cdr</code>
procedure rather than when the stream is constructed by <code>cons-stream</code>.
This implementation choice is reminiscent of our discussion of rational numbers
in <a href="2_002e1_002e2.xhtml#g_t2_002e1_002e2">2.1.2</a>, where we saw that we can choose to implement rational
numbers so that the reduction of numerator and denominator to lowest terms is
performed either at construction time or at selection time.  The two
rational-number implementations produce the same data abstraction, but the
choice has an effect on efficiency.  There is a similar relationship between
streams and ordinary lists.  As a data abstraction, streams are the same as
lists.  The difference is the time at which the elements are evaluated.  With
ordinary lists, both the <code>car</code> and the <code>cdr</code> are evaluated at
construction time.  With streams, the <code>cdr</code> is evaluated at selection
time.
</p>
<p>Our implementation of streams will be based on a special form called
<code>delay</code>.  Evaluating <code>(delay ⟨<var>exp</var>⟩)</code> does not evaluate the
expression <code>⟨</code><var>exp</var><code>⟩</code>, but rather returns a so-called 
<a id="index-delayed-object"></a>
<em>delayed object</em>, which we can think of as a “promise” to evaluate 
<code>⟨</code><var>exp</var><code>⟩</code> at some
future time.  As a companion to <code>delay</code>, there is a procedure called
<code>force</code> that takes a delayed object as argument and performs the
evaluation—in effect, forcing the <code>delay</code> to fulfill its promise.  We
will see below how <code>delay</code> and <code>force</code> can be implemented, but first
let us use these to construct streams.
</p>
<p><code>Cons-stream</code> is a special form defined so that
</p>
<div class="lisp">
<pre class="lisp">(cons-stream ⟨<var>a</var>⟩ ⟨<var>b</var>⟩)
</pre></div>

<p>is equivalent to
</p>
<div class="lisp">
<pre class="lisp">(cons ⟨<var>a</var>⟩ (delay ⟨<var>b</var>⟩))
</pre></div>

<p>What this means is that we will construct streams using pairs.  However, rather
than placing the value of the rest of the stream into the <code>cdr</code> of the
pair we will put there a promise to compute the rest if it is ever requested.
<code>Stream-car</code> and <code>stream-cdr</code> can now be defined as procedures:
</p>
<div class="lisp">
<pre class="lisp">(define (stream-car stream) 
  (car stream))

(define (stream-cdr stream) 
  (force (cdr stream)))
</pre></div>

<p><code>Stream-car</code> selects the <code>car</code> of the pair; <code>stream-cdr</code> selects
the <code>cdr</code> of the pair and evaluates the delayed expression found there to
obtain the rest of the stream.<a class="footnote_link" id="DOCF184" href="#FOOT184"><sup>184</sup></a>
</p>
<a id="The-stream-implementation-in-action"></a>
<h5 class="subsubheading">The stream implementation in action</h5>

<p>To see how this implementation behaves, let us analyze the “outrageous” prime
computation we saw above, reformulated in terms of streams:
</p>
<div class="lisp">
<pre class="lisp">(stream-car 
 (stream-cdr
  (stream-filter 
   prime? (stream-enumerate-interval 
           10000 1000000))))
</pre></div>

<p>We will see that it does indeed work efficiently.
</p>
<p>We begin by calling <code>stream-enumerate-interval</code> with the arguments 10,000
and 1,000,000.  <code>Stream-enumerate-interval</code> is the stream analog of
<code>enumerate-interval</code> (<a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>):
</p>
<div class="lisp">
<pre class="lisp">(define (stream-enumerate-interval low high)
  (if (&gt; low high)
      the-empty-stream
      (cons-stream
        low
        (stream-enumerate-interval (+ low 1) 
                                   high))))
</pre></div>

<p>and thus the result returned by <code>stream-enumerate-interval</code>, formed by the
<code>cons-stream</code>, is<a class="footnote_link" id="DOCF185" href="#FOOT185"><sup>185</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(cons 10000
      (delay 
        (stream-enumerate-interval 
         10001 
         1000000)))
</pre></div>

<p>That is, <code>stream-enumerate-interval</code> returns a stream represented as a
pair whose <code>car</code> is 10,000 and whose <code>cdr</code> is a promise to enumerate
more of the interval if so requested.  This stream is now filtered for primes,
using the stream analog of the <code>filter</code> procedure (<a href="2_002e2_002e3.xhtml#g_t2_002e2_002e3">2.2.3</a>):
</p>
<div class="lisp">
<pre class="lisp">(define (stream-filter pred stream)
  (cond ((stream-null? stream) 
         the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream 
          (stream-car stream)
          (stream-filter 
           pred
           (stream-cdr stream))))
        (else (stream-filter 
               pred 
               (stream-cdr stream)))))
</pre></div>

<p><code>Stream-filter</code> tests the <code>stream-car</code> of the stream (the <code>car</code>
of the pair, which is 10,000).  Since this is not prime, <code>stream-filter</code>
examines the <code>stream-cdr</code> of its input stream.  The call to
<code>stream-cdr</code> forces evaluation of the delayed
<code>stream-enumerate-interval</code>, which now returns
</p>
<div class="lisp">
<pre class="lisp">(cons 10001
      (delay 
        (stream-enumerate-interval 
         10002 
         1000000)))
</pre></div>

<p><code>Stream-filter</code> now looks at the <code>stream-car</code> of this stream, 10,001,
sees that this is not prime either, forces another <code>stream-cdr</code>, and so
on, until <code>stream-enumerate-interval</code> yields the prime 10,007, whereupon
<code>stream-filter</code>, according to its definition, returns
</p>
<div class="lisp">
<pre class="lisp">(cons-stream 
 (stream-car stream)
 (stream-filter pred (stream-cdr stream)))
</pre></div>

<p>which in this case is
</p>
<div class="lisp">
<pre class="lisp">(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 
                  10009 1000000))))))
</pre></div>

<p>This result is now passed to <code>stream-cdr</code> in our original expression.
This forces the delayed <code>stream-filter</code>, which in turn keeps forcing the
delayed <code>stream-enumerate-interval</code> until it finds the next prime, which
is 10,009.  Finally, the result passed to <code>stream-car</code> in our original
expression is
</p>
<div class="lisp">
<pre class="lisp">(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 
                  10011 1000000))))))
</pre></div>

<p><code>Stream-car</code> returns 10,009, and the computation is complete.  Only as
many integers were tested for primality as were necessary to find the second
prime, and the interval was enumerated only as far as was necessary to feed the
prime filter.
</p>
<p>In general, we can think of delayed evaluation as “demand-driven”
programming, whereby each stage in the stream process is activated only enough
to satisfy the next stage.  What we have done is to decouple the actual order
of events in the computation from the apparent structure of our procedures.  We
write procedures as if the streams existed “all at once” when, in reality,
the computation is performed incrementally, as in traditional programming
styles.
</p>
<a id="Implementing-delay-and-force"></a>
<h5 class="subsubheading">Implementing <code>delay</code> and <code>force</code></h5>

<p>Although <code>delay</code> and <code>force</code> may seem like mysterious operations,
their implementation is really quite straightforward.  <code>Delay</code> must
package an expression so that it can be evaluated later on demand, and we can
accomplish this simply by treating the expression as the body of a procedure.
<code>Delay</code> can be a special form such that
</p>
<div class="lisp">
<pre class="lisp">(delay ⟨<var>exp</var>⟩)
</pre></div>

<p>is syntactic sugar for
</p>
<div class="lisp">
<pre class="lisp">(lambda () ⟨<var>exp</var>⟩)
</pre></div>

<p><code>Force</code> simply calls the procedure (of no arguments) produced by
<code>delay</code>, so we can implement <code>force</code> as a procedure:
</p>
<div class="lisp">
<pre class="lisp">(define (force delayed-object)
  (delayed-object))
</pre></div>

<p>This implementation suffices for <code>delay</code> and <code>force</code> to work as
advertised, but there is an important optimization that we can include.  In
many applications, we end up forcing the same delayed object many times.  This
can lead to serious inefficiency in recursive programs involving streams.  (See
<a href="3_002e5_002e2.xhtml#Exercise-3_002e57">Exercise 3.57</a>.)  The solution is to build delayed objects so that the
first time they are forced, they store the value that is computed.  Subsequent
forcings will simply return the stored value without repeating the computation.
In other words, we implement <code>delay</code> as a special-purpose memoized
procedure similar to the one described in <a href="3_002e3_002e3.xhtml#Exercise-3_002e27">Exercise 3.27</a>.  One way to
accomplish this is to use the following procedure, which takes as argument a
procedure (of no arguments) and returns a memoized version of the procedure.
The first time the memoized procedure is run, it saves the computed result.  On
subsequent evaluations, it simply returns the result.
</p>
<div class="lisp">
<pre class="lisp">(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
</pre></div>

<p><code>Delay</code> is then defined so that <code>(delay ⟨<var>exp</var>⟩)</code> is equivalent
to
</p>
<div class="lisp">
<pre class="lisp">(memo-proc (lambda () ⟨<var>exp</var>⟩))
</pre></div>

<p>and <code>force</code> is as defined previously.<a class="footnote_link" id="DOCF186" href="#FOOT186"><sup>186</sup></a>
</p>
<blockquote>
<p><strong><a id="Exercise-3_002e50"></a>Exercise 3.50:</strong> Complete the following
definition, which generalizes <code>stream-map</code> to allow procedures that take
multiple arguments, analogous to <code>map</code> in <a href="2_002e2_002e1.xhtml#g_t2_002e2_002e1">2.2.1</a>, 
<a href="2_002e2_002e1.xhtml#Footnote-78">Footnote 78</a>.
</p>
<div class="lisp">
<pre class="lisp">(define (stream-map proc . argstreams)
  (if (⟨??⟩ (car argstreams))
      the-empty-stream
      (⟨??⟩
       (apply proc (map ⟨??⟩ argstreams))
       (apply stream-map
              (cons proc 
                    (map ⟨??⟩ 
                         argstreams))))))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e51"></a>Exercise 3.51:</strong> In order to take a closer look at
delayed evaluation, we will use the following procedure, which simply returns
its argument after printing it:
</p>
<div class="lisp">
<pre class="lisp">(define (show x)
  (display-line x)
  x)
</pre></div>

<p>What does the interpreter print in response to evaluating each expression in
the following sequence?<a class="footnote_link" id="DOCF187" href="#FOOT187"><sup>187</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(define x 
  (stream-map 
   show 
   (stream-enumerate-interval 0 10)))

(stream-ref x 5)
(stream-ref x 7)
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-3_002e52"></a>Exercise 3.52:</strong> Consider the sequence of
expressions
</p>
<div class="lisp">
<pre class="lisp">(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq 
  (stream-map 
   accum 
   (stream-enumerate-interval 1 20)))

(define y (stream-filter even? seq))

(define z 
  (stream-filter 
   (lambda (x) 
     (= (remainder x 5) 0)) seq))

(stream-ref y 7)
(display-stream z)
</pre></div>

<p>What is the value of <code>sum</code> after each of the above expressions is
evaluated?  What is the printed response to evaluating the <code>stream-ref</code>
and <code>display-stream</code> expressions?  Would these responses differ if we had
implemented <code>(delay ⟨<var>exp</var>⟩)</code> simply as <code>(lambda () ⟨<var>exp</var>⟩)</code>
without using the optimization provided by <code>memo-proc</code>?  Explain.
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT181"><p><a class="footnote_backlink" href="#DOCF181"><sup>181</sup></a>
Assume that we have a predicate <code>prime?</code> (e.g.,
as in <a href="1_002e2_002e6.xhtml#g_t1_002e2_002e6">1.2.6</a>) that tests for primality.</p>
</div>
<div id="FOOT182"><p><a class="footnote_backlink" href="#DOCF182"><sup>182</sup></a>
In the <abbr>MIT</abbr>
implementation, <code>the-empty-stream</code> is the same as the empty list
<code>'()</code>, and <code>stream-null?</code> is the same as <code>null?</code>.</p>
</div>
<div id="FOOT183"><p><a class="footnote_backlink" href="#DOCF183"><sup>183</sup></a>
This should bother
you.  The fact that we are defining such similar procedures for streams and
lists indicates that we are missing some underlying abstraction.
Unfortunately, in order to exploit this abstraction, we will need to exert
finer control over the process of evaluation than we can at present.  We will
discuss this point further at the end of <a href="3_002e5_002e4.xhtml#g_t3_002e5_002e4">3.5.4</a>.  In 
<a href="4_002e2.xhtml#g_t4_002e2">4.2</a>, we’ll develop a framework that unifies lists and streams.</p>
</div>
<div id="FOOT184"><p><a class="footnote_backlink" href="#DOCF184"><sup>184</sup></a>
Although <code>stream-car</code> and
<code>stream-cdr</code> can be defined as procedures, <code>cons-stream</code> must be a
special form.  If <code>cons-stream</code> were a procedure, then, according to our
model of evaluation, evaluating <code>(cons-stream ⟨<var>a</var>⟩ ⟨<var>b</var>⟩)</code> would
automatically cause <code>⟨</code><var>b</var><code>⟩</code> to be evaluated, which is precisely what we do
not want to happen.  For the same reason, <code>delay</code> must be a special form,
though <code>force</code> can be an ordinary procedure.</p>
</div>
<div id="FOOT185"><p><a class="footnote_backlink" href="#DOCF185"><sup>185</sup></a>
The numbers shown here do not really appear in
the delayed expression.  What actually appears is the original expression, in
an environment in which the variables are bound to the appropriate numbers.
For example, <code>(+ low 1)</code> with <code>low</code> bound to 10,000 actually appears
where <code>10001</code> is shown.</p>
</div>
<div id="FOOT186"><p><a class="footnote_backlink" href="#DOCF186"><sup>186</sup></a>
There are many possible
implementations of streams other than the one described in this section.
Delayed evaluation, which is the key to making streams practical, was inherent
in Algol 60’s <a id="index-call_002dby_002dname"></a>
<em>call-by-name</em> parameter-passing method.  The use of this
mechanism to implement streams was first described by <a href="References.xhtml#Landin-_00281965_0029">Landin (1965)</a>.  Delayed
evaluation for streams was introduced into Lisp by <a href="References.xhtml#Friedman-and-Wise-_00281976_0029">Friedman and Wise (1976)</a>. In
their implementation, <code>cons</code> always delays evaluating its arguments, so
that lists automatically behave as streams.  The memoizing optimization is also
known as <a id="index-call_002dby_002dneed"></a>
<em>call-by-need</em>.  The Algol community would refer to our
original delayed objects as <a id="index-call_002dby_002dname-thunks"></a>
<em>call-by-name thunks</em> and to the optimized
versions as <a id="index-call_002dby_002dneed-thunks"></a>
<em>call-by-need thunks</em>.</p>
</div>
<div id="FOOT187"><p><a class="footnote_backlink" href="#DOCF187"><sup>187</sup></a>
Exercises such as <a href="#Exercise-3_002e51">Exercise 3.51</a> and
<a href="#Exercise-3_002e52">Exercise 3.52</a> are valuable for testing our understanding of how
<code>delay</code> works.  On the other hand, intermixing delayed evaluation with
printing—and, even worse, with assignment—is extremely confusing, and
instructors of courses on computer languages have traditionally tormented their
students with examination questions such as the ones in this section.  Needless
to say, writing programs that depend on such subtleties is odious programming
style.  Part of the power of stream processing is that it lets us ignore the
order in which events actually happen in our programs.  Unfortunately, this is
precisely what we cannot afford to do in the presence of assignment, which
forces us to be concerned with time and change.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="3_002e5_002e2.xhtml#g_t3_002e5_002e2" accesskey="n" rel="next">3.5.2</a>, Previous: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="p" rel="prev">3.5</a>, Up: <a href="3_002e5.xhtml#g_t3_002e5" accesskey="u" rel="prev">3.5</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
