<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.3.1</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.3.1"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: 2.3.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="2_002e3.xhtml#g_t2_002e3" rel="prev" title="2.3"/>
<link href="2_002e3_002e2.xhtml#g_t2_002e3_002e2" rel="next" title="2.3.2"/>
<link href="2_002e3.xhtml#g_t2_002e3" rel="prev" title="2.3"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t2_002e3_002e1"></a>
<nav class="header">
<p>
Next: <a href="2_002e3_002e2.xhtml#g_t2_002e3_002e2" accesskey="n" rel="next">2.3.2</a>, Previous: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="p" rel="prev">2.3</a>, Up: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="u" rel="prev">2.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Quotation"></a>
<h4 class="subsection"><span class="secnum">2.3.1</span><span class="sectitle">Quotation</span></h4>

<p>If we can form compound data using symbols, we can have lists such as
</p>
<div class="lisp">
<pre class="lisp">(a b c d)
(23 45 17)
((Norah 12) 
 (Molly 9) 
 (Anna 7) 
 (Lauren 6) 
 (Charlotte 4))
</pre></div>

<p>Lists containing symbols can look just like the expressions of our
language:
</p>
<div class="lisp">
<pre class="lisp">(* (+ 23 45) (+ x 9))
(define (fact n) 
  (if (= n 1) 
      1 
      (* n (fact (- n 1)))))
</pre></div>

<p>In order to manipulate symbols we need a new element in our language: the
ability to <a id="index-quote"></a>
<em>quote</em> a data object.  Suppose we want to construct the
list <code>(a b)</code>.  We can’t accomplish this with <code>(list a b)</code>, because
this expression constructs a list of the <a id="index-values"></a>
<em>values</em> of <code>a</code> and
<code>b</code> rather than the symbols themselves.  This issue is well known in the
context of natural languages, where words and sentences may be regarded either
as semantic entities or as character strings (syntactic entities).  The common
practice in natural languages is to use quotation marks to indicate that a word
or a sentence is to be treated literally as a string of characters.  For
instance, the first letter of “John” is clearly “J.”  If we tell somebody
“say your name aloud,” we expect to hear that person’s name.  However, if we
tell somebody “say ‘your name’ aloud,” we expect to hear the words “your
name.”  Note that we are forced to nest quotation marks to describe what
somebody else might say.<a class="footnote_link" id="DOCF98" href="#FOOT98"><sup>98</sup></a>
</p>
<p>We can follow this same practice to identify lists and symbols that are to be
treated as data objects rather than as expressions to be evaluated.  However,
our format for quoting differs from that of natural languages in that we place
a quotation mark (traditionally, the single quote symbol&#160;<code>'</code>)<!-- /@w --> only at the
beginning of the object to be quoted.  We can get away with this in Scheme
syntax because we rely on blanks and parentheses to delimit objects.  Thus, the
meaning of the single quote character is to quote the next object.<a class="footnote_link" id="DOCF99" href="#FOOT99"><sup>99</sup></a>
</p>
<p>Now we can distinguish between symbols and their values:
</p>
<div class="lisp">
<pre class="lisp">(define a 1)
(define b 2)

(list a b)
<i>(1 2)</i>

(list 'a 'b)
<i>(a b)</i>

(list 'a b)
<i>(a 2)</i>
</pre></div>

<p>Quotation also allows us to type in compound objects, using the conventional
printed representation for lists:<a class="footnote_link" id="DOCF100" href="#FOOT100"><sup>100</sup></a>
</p>
<div class="lisp">
<pre class="lisp">(car '(a b c))
<i>a</i>

(cdr '(a b c))
<i>(b c)</i>
</pre></div>

<p>In keeping with this, we can obtain the empty list by evaluating <code>'()</code>,
and thus dispense with the variable <code>nil</code>.
</p>
<p>One additional primitive used in manipulating symbols is <code>eq?</code>, which
takes two symbols as arguments and tests whether they are the same.<a class="footnote_link" id="DOCF101" href="#FOOT101"><sup>101</sup></a>
Using <code>eq?</code>, we can implement a useful procedure called <code>memq</code>.  This
takes two arguments, a symbol and a list.  If the symbol is not contained in
the list (i.e., is not <code>eq?</code> to any item in the list), then <code>memq</code>
returns false.  Otherwise, it returns the sublist of the list beginning with
the first occurrence of the symbol:
</p>
<div class="lisp">
<pre class="lisp">(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
</pre></div>

<p>For example, the value of
</p>
<div class="lisp">
<pre class="lisp">(memq 'apple '(pear banana prune))
</pre></div>

<p>is false, whereas the value of
</p>
<div class="lisp">
<pre class="lisp">(memq 'apple '(x (apple sauce) y apple pear))
</pre></div>

<p>is <code>(apple pear)</code>.
</p>
<blockquote>
<p><strong><a id="Exercise-2_002e53"></a>Exercise 2.53:</strong> What would the interpreter print
in response to evaluating each of the following expressions?
</p>
<div class="lisp">
<pre class="lisp">(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
</pre></div>
</blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e54"></a>Exercise 2.54:</strong> Two lists are said to be
<code>equal?</code> if they contain equal elements arranged in the same order.  For
example,
</p>
<div class="lisp">
<pre class="lisp">(equal? '(this is a list) 
        '(this is a list))
</pre></div>

<p>is true, but
</p>
<div class="lisp">
<pre class="lisp">(equal? '(this is a list) 
        '(this (is a) list))
</pre></div>

<p>is false.  To be more precise, we can define <code>equal?</code>  recursively in
terms of the basic <code>eq?</code> equality of symbols by saying that <code>a</code> and
<code>b</code> are <code>equal?</code> if they are both symbols and the symbols are
<code>eq?</code>, or if they are both lists such that <code>(car a)</code> is <code>equal?</code>
to <code>(car b)</code> and <code>(cdr a)</code> is <code>equal?</code> to <code>(cdr b)</code>.  Using
this idea, implement <code>equal?</code> as a procedure.<a class="footnote_link" id="DOCF102" href="#FOOT102"><sup>102</sup></a>
</p></blockquote>

<blockquote>
<p><strong><a id="Exercise-2_002e55"></a>Exercise 2.55:</strong> Eva Lu Ator types to the
interpreter the expression
</p>
<div class="lisp">
<pre class="lisp">(car ''abracadabra)
</pre></div>

<p>To her surprise, the interpreter prints back <code>quote</code>.  Explain.
</p></blockquote>

<div class="footnote">
<hr/>

<h4 class="footnotes-heading">Footnotes</h4>

<div id="FOOT98"><p><a class="footnote_backlink" href="#DOCF98"><sup>98</sup></a>
Allowing quotation in a language wreaks havoc
with the ability to reason about the language in simple terms, because it
destroys the notion that equals can be substituted for equals.  For example,
three is one plus two, but the word “three” is not the phrase “one plus
two.”  Quotation is powerful because it gives us a way to build expressions
that manipulate other expressions (as we will see when we write an interpreter
in <a href="Chapter-4.xhtml#Chapter-4">Chapter 4</a>). But allowing statements in a language that talk about
other statements in that language makes it very difficult to maintain any
coherent principle of what “equals can be substituted for equals” should
mean.  For example, if we know that the evening star is the morning star, then
from the statement “the evening star is Venus” we can deduce “the morning
star is Venus.”  However, given that “John knows that the evening star is
Venus” we cannot infer that “John knows that the morning star is Venus.”</p>
</div>
<div id="FOOT99"><p><a class="footnote_backlink" href="#DOCF99"><sup>99</sup></a>
The
single quote is different from the double quote we have been using to enclose
character strings to be printed.  Whereas the single quote can be used to
denote lists or symbols, the double quote is used only with character strings.
In this book, the only use for character strings is as items to be printed.</p>
</div>
<div id="FOOT100"><p><a class="footnote_backlink" href="#DOCF100"><sup>100</sup></a>
Strictly, our use of the quotation
mark violates the general rule that all compound expressions in our language
should be delimited by parentheses and look like lists.  We can recover this
consistency by introducing a special form <code>quote</code>, which serves the same
purpose as the quotation mark.  Thus, we would type <code>(quote a)</code> instead of
<code>'a</code>, and we would type <code>(quote (a b c))</code> instead of <code>'(a b c)</code>.
This is precisely how the interpreter works.  The quotation mark is just a
single-character abbreviation for wrapping the next complete expression with
<code>quote</code> to form <code>(quote ⟨<var>expression</var>⟩)</code>.  This is
important because it maintains the principle that any expression seen by the
interpreter can be manipulated as a data object.  For instance, we could
construct the expression <code>(car '(a b c))</code>, which is the same as <code>(car
(quote (a b c)))</code>, by evaluating <code>(list 'car (list 'quote '(a b c)))</code>.</p>
</div>
<div id="FOOT101"><p><a class="footnote_backlink" href="#DOCF101"><sup>101</sup></a>
We
can consider two symbols to be “the same” if they consist of the same
characters in the same order.  Such a definition skirts a deep issue that we
are not yet ready to address: the meaning of “sameness” in a programming
language.  We will return to this in <a href="Chapter-3.xhtml#Chapter-3">Chapter 3</a> (<a href="3_002e1_002e3.xhtml#g_t3_002e1_002e3">3.1.3</a>).</p>
</div>
<div id="FOOT102"><p><a class="footnote_backlink" href="#DOCF102"><sup>102</sup></a>
In practice,
programmers use <code>equal?</code> to compare lists that contain numbers as well as
symbols.  Numbers are not considered to be symbols.  The question of whether
two numerically equal numbers (as tested by <code>=</code>) are also <code>eq?</code> is
highly implementation-dependent.  A better definition of <code>equal?</code> (such as
the one that comes as a primitive in Scheme) would also stipulate that if
<code>a</code> and <code>b</code> are both numbers, then <code>a</code> and <code>b</code> are
<code>equal?</code> if they are numerically equal.</p>
</div>
</div>
<hr/>
<nav class="header">
<p>
Next: <a href="2_002e3_002e2.xhtml#g_t2_002e3_002e2" accesskey="n" rel="next">2.3.2</a>, Previous: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="p" rel="prev">2.3</a>, Up: <a href="2_002e3.xhtml#g_t2_002e3" accesskey="u" rel="prev">2.3</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
