<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Foreword</title>

<meta name="description" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Foreword"/>
<meta name="keywords" content="Cấu trúc và ý nghĩa của chương trình máy tính, 2e: Foreword"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="index.xhtml#Top" rel="prev" title="Top"/>
<link href="Preface.xhtml#Preface" rel="next" title="Preface"/>
<link href="Dedication.xhtml#Dedication" rel="prev" title="Dedication"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="Foreword"></a>
<nav class="header">
<p>
Next: <a href="Preface.xhtml#Preface" accesskey="n" rel="next">Preface</a>, Previous: <a href="Dedication.xhtml#Dedication" accesskey="p" rel="prev">Dedication</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="Loi-tua-de"></a>
<h2 class="unnumbered">Lời tựa đề</h2>

<p>Chương trình giáo dục, chương trình quân sự, chương trình kế hoạch hóa, chương trình 
ăn chay. Quân đội, học sinh và một vài cộng đồng được lập trình sẵn (Educators, 
generals, dieticians, psychologists, and parents program.  Armies,
students, and some societies are programmed.)  An assault on large problems
employs a succession of programs, most of which spring into existence en route.
These programs are rife with issues that appear to be particular to the problem
at hand.  Để coi lập trình như một hoạt động trí tuệ khi đứng riêng lẻ bạn phải 
kể tới lập trình máy tính; bạn phải đọc và viết nhiều chương trình máy tính.
Vấn đề không nằm ở việc các chương trình máy tính làm gì, phục vụ cho mục đích nào.
Điều quan trọng là nó hoạt động tốt ra sao, nó kết liên kết với các chương trình khác
để tạo ra chương trình lớn hơn ra sao. Những lập trình viên phải quan tâm đến cả sự
hoàn thiện của những phần riêng lẻ, và đồng thời sự vừa vặn của cả tổng thể. Trong
quyển sách này “chương trình” được tập trung vào sự tạo ra, sự thực thi, và nghiên
cứu những chương trình được viết bằng ngôn ngữ Lisp thực thi trên một máy tính số.
Sử dụng Lisp chúng ta không giới hạn những chương trình có thể lập trình mà chỉ giới
hạn là những ký hiệu dùng để mô tả chương trình.
</p>
<p>Khi đi vào chủ đề của quyển sách này chúng ta sẽ liên quan tới ba đối tượng: 
trí não con người, tập hợp những chương trình máy tính, và chiếc máy tính. Mọi
chương trình máy tính là một mô hình, xuất hiện trong trí não, của một quá trình
diễn ra trên thực tế hay trong trí não. Những quá trình này, xuất hiện qua trãi
nghiệm và suy nghĩ của con người, có số lượng rất lớn, nhiều chi tiết phức tạp, và
tại mọi thời điểm chỉ hiểu được một phần nào đó. Chúng được mô hình hóa, cho những thoản mãn
hiếm khi kéo dài của chúng ta, bằng các chương trình máy tính. Vậy nên mặc dù là
tập hợp của những biểu tượng được được cẩn thận sắp xếp lại với nhau, tạo thành
bức phù điêu, chúng vẫn phát triển không ngừng: chúng ta thay đổi chúng khi nhận
thức của ta về mô hình trở nên sâu hơn, rộng hơn, tổng quát hơn cho đến khi 
mô hình đạt được trạng thái siêu ổn định thì vẫn có những mô hình khác mà ta 
gặp trở ngại. Nguồn gốc của niềm vui thích khi lập trình máy tính là do sự mở
mang không ngừng của trí não, của những cơ chế biểu diễn chương trình trên máy
tính và sự bùng nỗ về nhận thức mà chúng sinh ra. Nếu nghệ thuật diễn dịch
ước mơ của chúng ta thì máy tính thực hiện chúng dưới vỏ bọc của những chương trình.
</p>
<p>Với tất cả khả năng của mình, máy tính là một đốc công khắc nghiệt. Chương trình 
của nó phải đúng, và cái chúng ta muốn nói phải được nói một cách chính xác
trong từng chi tiết.  Như mọi hoạt động mang tính biểu tượng (symbolic activity), 
 chúng ta đảm bảo tính đúng đắn của chương trình thông qua lập luận. Lisp có thể
 được gán ngữ nghĩa, và nếu một chức năng của chương trình có thể được đặc tả,
 ví như, bằng lôgic vị từ, những phương thức chứng minh của lôgic có thể được dùng
 để lập luận về tính đúng đắn. Không may là, khi chương trình trở lên lớn và
 phức tạp, luôn là vậy, thì tính đúng đắn của chính bản đặc tả lại trở nên
 đáng nghi ngờ, do vậy nên suy luận tính đúng đắn của dùng lập luận hình thức
 khó mà áp dụng cho các chương trình lớn. Do những chương trình lớn phát triển
 từ những cái nhỏ hơn, nên rất quan trọng khi ta phát triển một bộ những
 cấu trúc chương trình tiêu chuẩn mà ta chắc chắn về tính đúng đắn—ta gọi 
 nó là những thành ngữ—và học cách để kết hợp chúng thành những cấu trúc lớn
 hơn bằng việc dùng các kỹ thuật tổ chức chương trình đã được chứng minh hiệu quả.
 Những kỹ thuật này được trình bày xuyên suốt quyển sách này, và việc hiểu rõ
 chúng là rất quan trọng để có thể bước vào vương quốc lập trình. Hơn những điều
 khác, hiểu rõ và nắm vững các kỹ thuật mạnh mẽ để tổ chức chương trình sẽ giúp
 ích đáng kể trong việc tạo những chương trình lớn và quan trọng.
Ngược lại, kể từ khi việc viết chương trình lớn trở nên tốn kém, chúng ta bị
thúc đẩy để tìm ra những phương cách mới để giảm thiểu số lượng tính năng và
chi tiết được gắn vào các chương trình lớn.
</p>
<p>Không giống như các chương trình, máy tính phải tuân theo những quy luật
của vật lý. Nếu chúng muốn thực hiện nhanh chóng—một vài nano-giây trên
mỗi thay đổi trang thái—chúng phải truyền tải electrons ở khoảng cách nhỏ
(tối đa \( {1 {1\over2}} \) feet). Lượng nhiệt được sinh ra bởi số lượng
khổng lồ các linh kiện cần phải được loại bỏ. Một nghệ thuật kĩ thuật tinh tế đã
được phát triển để cần bằng giữa sự đang dạng về chức năng với mật độ của các
linh kiện điện tử. Tại bất kì sự kiện nào, phần cứng luôn luôn hoạt động tại 
tầm căn bản hơn so với cái mà chúng ta quan tâm về chương trình. Các quá trình
chuyển đổi chương trình Lisp của chúng ta thành các chương trình “máy” cũng 
là những mô hình trừu được được ta lập trình ra. Sự tạo ra và nghiên cứu những 
quá trình này cho chúng ta hiểu biết rõ hơn về cấu trúc của những chương trình
có thể kết hợp với bất kì mô hình lập trình nào. Dĩ nhiên là máy tính cũng
có thể được mô hình hóa. Hãy suy nghĩ: hành vi của các công tắc vật lý nhỏ nhất
được mô hình bởi cơ học lương tử bằng các phương trình vi phân mà các hành vi
chi tiếc được nắm bắt bởi các xấp xỉ số học dduwocwj biểu diễn trong những
chương trình máy tính được thực thi trên những máy tính tạo bởi …!
</p>
<p>Không phải là vấn đề về thuận lợi khi phân biệt ba khái niệm. Thậm chí,
như người ta nói, tất tả đều ở trong đầu, sự phân biệt này góp phần đáng kể
vào việc trao đổi biểu tượng giữa ba khái niệm bao gồm tính đa dạng, sức sống,
và tiềm năng thì vượt quá kinh nghiệm con người chỉ bằng sự lớn lên của 
chính nó. Tốt nhất, những mối quan hệ giữa các khái niệm trọng tâm là siêu ổn định.
 Máy tính không bao giờ đủ lớn và đủ nhanh. Mỗi đột phá trong công nghệ phần
cứng lại dẫn đến những mức độ lập trình lớn hơn, những nguyên tắc tổ chức mới,
và thêm vào những mô hình trừa tượng. Người đọc nên thường xuyên tự hỏi
“Hướng về cái cuối nào, hướng về cái cuối nào?”—nhưng đừng hỏi quá thường 
xuyên vì sợ rằng bạn sẽ đánh mất niềm vui lập trình.
</p>
<p>It is not merely a matter of tactical convenience to separately identify the
three foci.  Even though, as they say, it’s all in the head, this logical
separation induces an acceleration of symbolic traffic between these foci whose
richness, vitality, and potential is exceeded in human experience only by the
evolution of life itself.  At best, relationships between the foci are
metastable.  The computers are never large enough or fast enough.  Each
breakthrough in hardware technology leads to more massive programming
enterprises, new organizational principles, and an enrichment of abstract
models.  Every reader should ask himself periodically “Toward what end, toward
what end?”—but do not ask it too often lest you pass up the fun of
programming for the constipation of bittersweet philosophy.
</p>
<p>Trong số chương trình chúng ta viết, một vài (nhưng không bao giờ đủ) thực
hiện các chức năng toán học thuần túy như là sắp xếp hay tìm phần tử lớn nhất
của một chuỗi soosl, kiểm tra số nguyên tố, hay tìm căn bậc hai. Chúng ta gọi
những chương trình như vậy là thuật toán, và một cái rất quan trọng là biết
được hành vi tối ưu của chúng, ta đặc biệt quan tâm tới hai tham số của thời
gian thực thi và yêu cầu lưu trữ dữ liệu. Một người lập trình nên biết những
thuật toán tốt và những thành ngữ (idioms).  Mặc dù một vài chương trình không
thể đặc tả chính xác, thì trách nhiệm của người lập trình là xấp xĩ, và luôn 
cố gắng cải thiện hiệu năng của chúng.
</p>

<p>Lisp đã sống sót qua một phần tư thế kỉ. Trong số các ngôn ngữ đang được dùng
chỉ có Fortran là có tuổi thọ lớn hơn. Cả hai ngôn ngữ đều hỗ trợ cho nhu cầu
lập trình ở những lĩnh vực ứng dụng quan trọng, Fotran dành cho khoa học
và kĩ thuật tính toán; Lisp dành cho trí tuệ nhân tạo. Hai lĩnh vực này tiếp 
tục là những lĩnh vực quan trong, và những lập trình viên dùng hai Lisp và
Fortran có thể tiếp tục dùng chúng trong ít nhất một phần tư thế kỉ nữa.
</p>
<p>Lisp đã thay đổi. Ngôn ngữ Scheme được dùng trong sách này đã được phát triển
thì Lisp nguyên bản và khác với Lisp ở vài yếu tố quan trọng, bao gồm tầm vực
tĩnh cho việc gán biến (variable binding) và cho phép các hàm sinh ra giá trị
kết quả là một hàm khác. Trong cấu trúc ngữ nghĩa Scheme gần giống với
Algol 60. Algo 60, không bao giờ có thể được sống lại lần nữa, đã sống với gen
của Scheme và Pascal. Khó mà có thể tìm được hai ngôn ngữ mà có sự giao thiệp
giữa hai cộng đồng hoàn toàn khác nhau như hai ngôn ngữ trên. Pascal dành để
xây dựng kim tự tháp—hùng vĩ, tuyệt đẹp, cấu trúc tĩnh được những đội quân 
xây dựng bằng cách đặt những tảng đá lớn vào đúng vị trí. Lisp dùng để tạo các
sinh vật sống—hùng vĩ, tuyệt đẹp, cấu trúc động được tạo bởi việc sắp xếp
đội hình cho vô số các sinh vật nhỏ hơn vào đúng chỗ. Những nguyên tắc tổ chức
được sử dụng cho cả hai trường hợp, ngoại trừ một sự khác biết rất quan trọng: 
Những những lập trình Lisp khả năng chia sẻ những tính năng đã được hiện thực
tốt hơn hẵn so với đế chế Pascel. Chương trình Lisp tạo ra những thư viện với
nhiều chức năng mà tiện ích vượt qua cả ứng dụng sinh ra chúng. Danh sách, cấu
trúc dữ liệu nguyên thủy của Lisp, có vai trò chính trong việc tiện ích vượt
trội này. Cấu trúc đơn giản và tính ứng dụng một cách tự nhiên của các danh sách
được thể hiện quả những chức năng rất tổng quát. Trong Pascal việc có thể khai
báo các cấu trức dữ liệu dẫn đến việc các chức năng chỉ sử dụng cho các mục đích
riêng lẻ, ngăn cản sự hợp tác. Sẽ là tốt hơn nếu có một 100 chức năng làm việc
trên một câu trức dữ liệu hơn là có 10 chức năng làm việc trên 10 cấu trúc dữ
liệu. Như một hệ quả, các kim tự tháp phải đứng vững hàng thiên niên kỉ; các sinh
vật phải tiến hóa hoặc chết.
</p>
<p>Để minh họa sự khác nhau này, so sánh phần tài liệu và bài tập trong sách này
với bất kì sách nhập môn nào sử dụng Pascal. Đừng lười biết dưới ảo tưởng rằng
đây là sách chỉ ở <abbr>MIT</abbr>, peculiar to the breed found there.  
Đây chính xác là cái mà một sách nghiêm túc về lập trình Lisp phải có, bất kể
học sinh nào hay nơi nào dùng nó.
</p>
<p>Lưu ý rằng sách này là sách về lập trình, không giống đa phần sách về Lisp,
những sách được dùng để chuẩn bị cho công việc trong lĩnh vực trí tuệ nhân tạo.
Sau cùng, những quan tâm về lập trình của kĩ nghệ phần mềm và trí tuệ nhân tạo
có xư hướng làm cho hệ thống bên dưới trở nên lớn hơn.
Điều này giải thích vì sao sự quan tâm đến Lisp được mở rộng đến cách lĩnh vực
ngoài trí tuệ nhân tạo.
</p>
<p>Như một ai kì vọng về mục tiêu của nó, nghiên cứu về trí tuệ nhân tạo đã tạo
ra nhiều bài toán lập trình quan trọng. Trong những lĩnh vực khác, việc xuất 
hiện những vấn đề mới lại sản sinh ra các ngôn ngữ mới. Thật sự, trong những công
việc lập trình lớn thì nguyên lý tổ chức là điều khiển và cô lập sự tương tác 
giữa các mô-đun thông qua các cơ chế của ngôn ngữ. Các ngôn ngữ này có xu hướng
trở nên ít đơn giản khi một ai đó tiếp cận đến giới hạn của hệ thống nơi mà 
chúng ta người thường xuyên tiếp xúc. Như một hệ quả, những hệ thống như vậy 
chứa đựng những chức năng xử lý ngôn ngữ được lập lại nhiều lần. Lisp có một
ngữ pháp và ngữ nghĩa đơn giản nên việc phân tích được xem như công việc cơ
bản. Do đó những kĩ thuật phân tích ngôn ngữ gần như không đóng vai trò gì 
trong chương trình Lisp, và việc xây dựng bộ xử lý ngôn ngữ hiếm khi ảnh hướng
đến sự phát triển và thay đổi của những hệ thống Lisp lớn. Cuối cùng, với sự
đơn giản của ngữ pháp và ngữ nghĩa, Lisp tạo ra sự tự cũng như gánh nặng cho
mọi người lập trình Lisp. Không có chương trình Lisp, với bất kì kích thước nào,
 nằm ngoài vài dòng có thể được viết, mà không bị bão hòa bởi các chức năng
sẳn có.  Invent and fit; have fits and reinvent! 
We toast the Lisp programmer who pens his thoughts within nests of parentheses.
</p>
<p>Alan J. Perlis<br/>
New Haven, Connecticut
</p>
<hr/>
<nav class="header">
<p>
Next: <a href="Preface.xhtml#Preface" accesskey="n" rel="next">Preface</a>, Previous: <a href="Dedication.xhtml#Dedication" accesskey="p" rel="prev">Dedication</a>, Up: <a href="index.xhtml#Top" accesskey="u" rel="prev">Top</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
