<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.2.1</title>

<meta name="description" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.2.1"/>
<meta name="keywords" content="Cau truc va Y nghia cua Chuong Trinh May tinh, 2e: 5.2.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Generator" content="texi2any"/>
<meta charset="utf-8"/>
<link href="index.xhtml#Top" rel="start" title="Top"/>
<link href="Term-Index.xhtml#Term-Index" rel="index" title="Term Index"/>
<link href="index.xhtml#SEC_Contents" rel="contents" title="Table of Contents"/>
<link href="5_002e2.xhtml#g_t5_002e2" rel="prev" title="5.2"/>
<link href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" rel="next" title="5.2.2"/>
<link href="5_002e2.xhtml#g_t5_002e2" rel="prev" title="5.2"/>

<link href="css/style.css" rel="stylesheet" type="text/css" />
<link href="css/prettify.css" rel="stylesheet" type="text/css" />

<script class="prettifier" src="js/highlight/prettify.js" type="text/javascript"></script>
<script class="prettifier" src="js/highlight/lang-lisp.js" type="text/javascript"></script>
</head>

<body>
<section><a id="g_t5_002e2_002e1"></a>
<nav class="header">
<p>
Next: <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" accesskey="n" rel="next">5.2.2</a>, Previous: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="p" rel="prev">5.2</a>, Up: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="u" rel="prev">5.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>
<hr/>

<a id="The-Machine-Model"></a>
<h4 class="subsection"><span class="secnum">5.2.1</span><span class="sectitle">The Machine Model</span></h4>

<p>The machine model generated by <code>make-machine</code> is represented as a
procedure with local state using the message-passing techniques developed in
<a href="Chapter-3.xhtml#Chapter-3">Chapter 3</a>.  To build this model, <code>make-machine</code> begins by calling
the procedure <code>make-new-machine</code> to construct the parts of the machine
model that are common to all register machines.  This basic machine model
constructed by <code>make-new-machine</code> is essentially a container for some
registers and a stack, together with an execution mechanism that processes the
controller instructions one by one.
</p>
<p><code>Make-machine</code> then extends this basic model (by sending it messages) to
include the registers, operations, and controller of the particular machine
being defined.  First it allocates a register in the new machine for each of
the supplied register names and installs the designated operations in the
machine.  Then it uses an <a id="index-assembler"></a>
<em>assembler</em> (described below in 
<a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2">5.2.2</a>) to transform the controller list into instructions for the new
machine and installs these as the machine’s instruction sequence.
<code>Make-machine</code> returns as its value the modified machine model.
</p>
<div class="lisp">
<pre class="lisp">(define (make-machine register-names 
                      ops 
                      controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) 
                 register-name))
              register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
</pre></div>

<a id="Registers"></a>
<h5 class="subsubheading">Registers</h5>

<p>We will represent a register as a procedure with local state, as in
<a href="Chapter-3.xhtml#Chapter-3">Chapter 3</a>.  The procedure <code>make-register</code> creates a register that
holds a value that can be accessed or changed:
</p>
<div class="lisp">
<pre class="lisp">(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) 
               (set! contents value)))
            (else
             (error &quot;Unknown request: 
                     REGISTER&quot;
                    message))))
    dispatch))
</pre></div>

<p>The following procedures are used to access registers:
</p>
<div class="lisp">
<pre class="lisp">(define (get-contents register)
  (register 'get))

(define (set-contents! register value)
  ((register 'set) value))
</pre></div>

<a id="The-stack"></a>
<h5 class="subsubheading">The stack</h5>

<p>We can also represent a stack as a procedure with local state.  The procedure
<code>make-stack</code> creates a stack whose local state consists of a list of the
items on the stack.  A stack accepts requests to <code>push</code> an item onto the
stack, to <code>pop</code> the top item off the stack and return it, and to
<code>initialize</code> the stack to empty.
</p>
<div class="lisp">
<pre class="lisp">(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack: POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) 
             (initialize))
            (else 
             (error &quot;Unknown request: STACK&quot;
                    message))))
    dispatch))
</pre></div>

<p>The following procedures are used to access stacks:
</p>
<div class="lisp">
<pre class="lisp">(define (pop stack) (stack 'pop))
(define (push stack value)
  ((stack 'push) value))
</pre></div>

<a id="The-basic-machine"></a>
<h5 class="subsubheading">The basic machine</h5>

<p>The <code>make-new-machine</code> procedure, shown in <a href="#Figure-5_002e13">Figure&#160;5.13<!-- /@w --></a>, 
constructs
an object whose local state consists of a stack, an initially empty instruction
sequence, a list of operations that initially contains an operation to
initialize the stack, and a <a id="index-register-table"></a>
<em>register table</em> that initially contains
two registers, named <code>flag</code> and <code>pc</code> (for “program counter”).  The
internal procedure <code>allocate-register</code> adds new entries to the register
table, and the internal procedure <code>lookup-register</code> looks up registers in
the table.
</p>
<p><strong><a id="Figure-5_002e13"></a>Figure 5.13:</strong> \( \downarrow \) The <code>make-new-machine</code>
procedure, which implements the basic machine model.
</p>
<div class="lisp">
<pre class="lisp">(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list 
            (list 'initialize-stack
                  (lambda () 
                    (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) 
                 (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error 
             &quot;Multiply defined register: &quot; 
             name)
            (set! register-table
                  (cons 
                   (list name 
                         (make-register name))
                   register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val 
               (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; 
                     name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc 
                  (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! 
                pc
                the-instruction-sequence)
               (execute))
              ((eq? 
                message 
                'install-instruction-sequence)
               (lambda (seq) 
                 (set! 
                  the-instruction-sequence 
                  seq)))
              ((eq? message 
                    'allocate-register) 
               allocate-register)
              ((eq? message 'get-register) 
               lookup-register)
              ((eq? message 
                    'install-operations)
               (lambda (ops) 
                 (set! the-ops 
                       (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) 
               the-ops)
              (else (error &quot;Unknown request: 
                            MACHINE&quot;
                           message))))
      dispatch)))
</pre></div>

<p>The <code>flag</code> register is used to control branching in the simulated machine.
<code>Test</code> instructions set the contents of <code>flag</code> to the result of the
test (true or false).  <code>Branch</code> instructions decide whether or not to
branch by examining the contents of <code>flag</code>.
</p>
<p>The <code>pc</code> register determines the sequencing of instructions as the machine
runs.  This sequencing is implemented by the internal procedure <code>execute</code>.
In the simulation model, each machine instruction is a data structure that
includes a procedure of no arguments, called the <a id="index-instruction-execution-procedure"></a>
<em>instruction execution procedure</em>, 
such that calling this procedure simulates executing the
instruction.  As the simulation runs, <code>pc</code> points to the place in the
instruction sequence beginning with the next instruction to be executed.
<code>Execute</code> gets that instruction, executes it by calling the instruction
execution procedure, and repeats this cycle until there are no more
instructions to execute (i.e., until <code>pc</code> points to the end of the
instruction sequence).
</p>
<p>As part of its operation, each instruction execution procedure modifies
<code>pc</code> to indicate the next instruction to be executed.  <code>Branch</code> and
<code>goto</code> instructions change <code>pc</code> to point to the new destination.  All
other instructions simply advance <code>pc</code>, making it point to the next
instruction in the sequence.  Observe that each call to <code>execute</code> calls
<code>execute</code> again, but this does not produce an infinite loop because
running the instruction execution procedure changes the contents of <code>pc</code>.
</p>
<p><code>Make-new-machine</code> returns a <code>dispatch</code> procedure that implements
message-passing access to the internal state.  Notice that starting the machine
is accomplished by setting <code>pc</code> to the beginning of the instruction
sequence and calling <code>execute</code>.
</p>
<p>For convenience, we provide an alternate procedural interface to a machine’s
<code>start</code> operation, as well as procedures to set and examine register
contents, as specified at the beginning of <a href="5_002e2.xhtml#g_t5_002e2">5.2</a>:
</p>
<div class="lisp">
<pre class="lisp">(define (start machine)
  (machine 'start))

(define (get-register-contents 
         machine register-name)
  (get-contents 
   (get-register machine register-name)))

(define (set-register-contents! 
         machine register-name value)
  (set-contents! 
   (get-register machine register-name) 
   value)
  'done)
</pre></div>

<p>These procedures (and many procedures in <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2">5.2.2</a> and <a href="5_002e2_002e3.xhtml#g_t5_002e2_002e3">5.2.3</a>)
use the following to look up the register with a given name in a given machine:
</p>
<div class="lisp">
<pre class="lisp">(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</pre></div>

<hr/>
<nav class="header">
<p>
Next: <a href="5_002e2_002e2.xhtml#g_t5_002e2_002e2" accesskey="n" rel="next">5.2.2</a>, Previous: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="p" rel="prev">5.2</a>, Up: <a href="5_002e2.xhtml#g_t5_002e2" accesskey="u" rel="prev">5.2</a> &#160; [<a href="index.xhtml#SEC_Contents" title="Table of contents" accesskey="c" rel="contents">Contents</a>][<a href="Term-Index.xhtml#Term-Index" title="Index" accesskey="i" rel="index">Index</a>]</p>
</nav>


</section>
</body>
</html>
